<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Calligraphy and Lettering Practice Sheet Generator</title>
    <style>
        body {
            margin: 0;

        }

        html,
        body {

            height: 100%;
            margin: 0;
            overflow: hidden;
            /* This ensures that no default scrollbars appear for the body */
        }



        #container {
            display: flex;
            padding-left: 300px;
            height: 100%;
            /* Make the container fill the viewport height */


        }

        .worksheetPage {

            margin: auto;

        }

        #generatedWorksheetArea {
            height: calc(100% - 20px);
            /* Adjust as needed to leave space for headers or other content */
            width: 100%;
            overflow-y: scroll;
            /* Enable vertical scrolling for this specific div */
            scrollbar-width: none;
            /* Hide default scrollbar for Firefox */
            position: relative;
            /* Ensure proper positioning for custom scrollbar */

        }


        #controls p {
            color: white;
            font-size: 9pt;
        }

        #controls {
            width: 300px;
            padding: 10pt;
            background: rgba(255, 255, 255, 0.8);
            background: #303030;
            box-sizing: border-box;
            position: fixed;
            z-index: 20;
            bottom: 0;
            left: 0;
            top: 0;
            overflow-y: scroll;
            /* Keep scrolling enabled */
            scrollbar-width: none;
            /* Firefox */
            border-right: 2px solid rgb(101, 101, 101);
        }

        .hiddenTemporary {
            display: none;
        }

        #controls::-webkit-scrollbar {
            display: none;
            /* Chrome, Safari, and Opera */
        }





        #controls h1 {
            font-family: 'Franklin Gothic Medium', 'Arial Narrow', Arial, sans-serif;
            font-size: 10pt;
            margin-top: 0;
            color: #ccc;
            text-align: left;
            padding-top: 0;
            background-color: black;
            margin: -10pt;
            padding: 5pt;
            text-align: center;
            box-shadow: 2pt 2pt 2pt rgb(75, 75, 75);

        }

        #canvas {
            flex-grow: 1;
            display: block;
            margin: 0 auto;
        }




        #controls fieldset legend {

            box-sizing: border-box;
            text-transform: uppercase;
            background-color: #111;
            color: #7b7474;

            font-size: 10pt;
            width: 100%;

            padding-top: 5pt;

            text-align: center;
            padding-bottom: 3pt;
            box-shadow: 3pt 3pt 3pt rgb(75, 75, 75);

            border-radius: 4pt;
            font-weight: bold;
            border-bottom: 2pt solid black;

        }

        #controls fieldset .settingEnclosure {}

        #controls fieldset {
            border: 0;
            border-radius: 4pt;

            outline: 4pt solid #000;
            /* Create an inside border */
            outline-offset: -2px;
            /* Move the outline inwards */


            font-family: sans-serif;
            background-color: #111;
            color: #333;
            box-shadow: 3pt 3pt 3pt rgb(75, 75, 75);
            margin-bottom: 15pt;

            padding-top: 0pt;
            padding-bottom: 0pt;
            padding-right: 0pt;
            padding-left: 0pt;
            font-family: sans-serif;

            color: #333;
        }



        .settingEnclosure {
            padding: 5px;
            padding-left: 8pt;

            margin-top: 0px;
            margin-bottom: 1px;
            background-color: #929191;

            border: 0px solid rgb(49, 47, 47);

        }

        .settingEnclosure label {

            user-select: none;
            font-weight: bold;
        }

        .settingEnclosure label.radioLabel {
            font-weight: normal;
        }

        div.settingEnclosure.indent {
            border-left: 8pt solid black;
            background-color: #494848;
            color: black;
            font-weight: normal;

        }

        div.settingEnclosure.indent2 {
            border-left: 12pt solid black;

        }

        div.settingEnclosure.indent label {
            margin-left: 0;
            font-weight: normal;

            color: rgb(222, 222, 222) !important;
        }

        #controls fieldset label {


            font-family: sans-serif;
            font-family: 'Franklin Gothic Medium', 'Arial Narrow', Arial, sans-serif;
            /*text-transform:uppercase;*/

            font-size: 13pt;

            text-transform: ;
            color: #0d0d0d;

            display: inline-block;
        }

        .labelNote {
            color: rgb(49, 86, 30);
            font-family: monospace;
            font-size: 10pt;
        }

        #controls input[type='number'] {
            font-family: monospace;
            border-radius: 9pt;
            text-align: center;
            width: 50pt;
            font-size: 12pt;
            padding-top: 1pt;
            padding-bottom: 2pt;
            background-color: #111;

            /*background: linear-gradient(to right, #383737 10%, #0b0a0a 40%, #474646 100%);*/
            border: 2pt solid black;

            color: rgb(228, 226, 226);

            /* Apply border to create the "well" effect */

            border: 2px solid #3a3939;
            /* Darker border as a base */
            border-bottom-color: #787777;
            /* Lighter color for the top to create the highlight */
            border-right-color: #8b8989;
            /* Lighter color for the left side */


            /* Box shadow to enhance the well effect */
            box-shadow: inset 2px 2px 2px rgba(0, 0, 0, 0.2),
                inset -2px -2px 2px rgba(206, 205, 205, 0.7);

            /* Remove default styling */
            outline: none;
            appearance: none;

        }

        #controls input[type='checkbox'] {
            appearance: none;
        }

        #controls input[type='checkbox'],
        #controls input[type='radio'] {
            appearance: none;
            /* Remove default appearance */
            -webkit-appearance: none;
            /* Vendor prefix for better support */
            width: 13pt;
            height: 13pt;
            margin-right: 0px;
            vertical-align: middle;
            cursor: pointer;
            display: inline-block;

            /*  light:          background: url('data:image/svg+xml;charset=UTF-8,<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><defs><linearGradient id="grad1" x1="0%" y1="0%" x2="100%" y2="100%"><stop offset="0%" style="stop-color:%23b0b0b0;stop-opacity:1"/><stop offset="100%" style="stop-color:%23808080;stop-opacity:1"/></linearGradient></defs><rect x="0" y="0" width="24" height="24" fill="url(%23grad1)"/></svg>') no-repeat center;
  */
            background: url('data:image/svg+xml;charset=UTF-8,<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><defs><linearGradient id="grad1" x1="0%" y1="0%" x2="100%" y2="100%"><stop offset="0%" style="stop-color:%23505050;stop-opacity:1"/><stop offset="100%" style="stop-color:%232a2a2a;stop-opacity:1"/></linearGradient></defs><rect x="0" y="0" width="24" height="24" fill="url(%23grad1)"/></svg>') no-repeat center;

            background-size: cover;
            border-radius: 4px;
            /* For checkbox, adds rounded corners */
            /*transition: background 0.05s ease;*/
            border: 1px solid gray;
            /*
    border-top:1px solid black;
    border-left:1px solid black;
    border-bottom:1px solid darkgray;*/
            margin-left: -2px;
        }

        /* Checkbox Checked State */
        #controls input[type='checkbox']:checked {
            /*            background: url('data:image/svg+xml;charset=UTF-8,<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><defs><linearGradient id="grad1" x1="0%" y1="0%" x2="100%" y2="100%"><stop offset="0%" style="stop-color:%23b0b0b0;stop-opacity:1"/><stop offset="100%" style="stop-color:%23808080;stop-opacity:1"/></linearGradient></defs><rect x="0" y="0" width="24" height="24" fill="url(%23grad1)"/><polyline points="5,13 10,17 19,7" style="fill:none;stroke:%23000000;stroke-width:2"/></svg>') no-repeat center;
  */
            background: url('data:image/svg+xml;charset=UTF-8,<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><defs><linearGradient id="grad1" x1="0%" y1="0%" x2="100%" y2="100%"><stop offset="0%" style="stop-color:%23505050;stop-opacity:1"/><stop offset="100%" style="stop-color:%232a2a2a;stop-opacity:1"/></linearGradient></defs><rect x="0" y="0" width="24" height="24" fill="url(%23grad1)"/><polyline points="5,13 10,17 19,7" style="fill:none;stroke:%23ffffff;stroke-width:2"/></svg>') no-repeat center;


            background-size: cover;
        }

        /* Radio Button Styling */
        #controls input[type='radio'] {
            border-radius: 50%;
            /* Makes the radio button circular */
        }

        /* Radio Button Checked State */
        #controls input[type='radio']:checked {

            /* light:          background: url('data:image/svg+xml;charset=UTF-8,<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><defs><linearGradient id="grad1" x1="0%" y1="0%" x2="100%" y2="100%"><stop offset="0%" style="stop-color:%23b0b0b0;stop-opacity:1"/><stop offset="100%" style="stop-color:%23808080;stop-opacity:1"/></linearGradient></defs><rect x="0" y="0" width="24" height="24" fill="url(%23grad1)"/><circle cx="12" cy="12" r="6" style="fill:%23000000;"/></svg>') no-repeat center;
*/
            background: url('data:image/svg+xml;charset=UTF-8,<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><defs><linearGradient id="grad1" x1="0%" y1="0%" x2="100%" y2="100%"><stop offset="0%" style="stop-color:%23505050;stop-opacity:1"/><stop offset="100%" style="stop-color:%232a2a2a;stop-opacity:1"/></linearGradient></defs><rect x="0" y="0" width="24" height="24" fill="url(%23grad1)"/><circle cx="12" cy="12" r="6" style="fill:%23c3c3c3;"/></svg>') no-repeat center;

            background-size: cover;
        }

        /* Hover Effect for Both Checkbox and Radio Button */
        #controls input[type='checkbox']:hover,
        #controls input[type='radio']:hover {
            box-shadow: 0 0 5px rgba(0, 0, 0, 0.2);
            /* Slight shadow effect on hover */
        }


        /* Ensure label aligns well with checkbox */
        #controls label {
            cursor: pointer;
            vertical-align: middle;
        }


        #controls select {
            width: 220px;
            padding: 3pt;
            padding-left: 5pt;
            font-size: 13pt;
            border: 1px solid #ccc;
            border-radius: 5pt;
            appearance: none;
            /* Remove default styling */
            color: rgb(143, 140, 140);
            font-weight: bold;

            /* Stacking two backgrounds: gradient and the SVG arrow */
            /* Background using SVG with gradient and arrow */

            background: url('data:image/svg+xml;charset=UTF-8,<svg xmlns="http://www.w3.org/2000/svg" width="220" height="40" viewBox="0 0 220 40" preserveAspectRatio="none"><defs><linearGradient id="grad1" x1="0%" y1="100%" x2="0%" y2="0%"><stop offset="10%" style="stop-color:%23383737;stop-opacity:1" /><stop offset="40%" style="stop-color:%230b0a0a;stop-opacity:1" /><stop offset="100%" style="stop-color:%23474646;stop-opacity:1" /></linearGradient></defs><rect x="0" y="0" width="220" height="40" fill="url(%23grad1)" /><polygon points="195,15 204,25 213,15" fill="darkGray"/></svg>') no-repeat;
            background-size: 100% 100%;
            /* Make sure the SVG fills the entire select area */

            padding-right: 40px;
            /* Add space to ensure text doesn’t overlap with the arrow */

            appearance: none;
            /* Remove default dropdown arrow in some browsers */
            -webkit-appearance: none;
            /* Remove default appearance for WebKit browsers */
            -moz-appearance: none;
            /* Remove default appearance for Mozilla browsers */

            font-family: monospace;
            font-size: 10pt;
            font-weight: normal;
            border: 2pt solid black;

            /* Apply border to create the "well" effect */
            border: 2px solid #3a3939;
            /* Darker border as a base */
            border-top-color: #8a8888;
            /* Lighter color for the top to create the highlight */



        }



        #outputButtons {
            margin-top: 10pt;
            margin-bottom: 5pt;

            padding: 0pt;
        }

        #outputButtons button,
        button {
            font-family: monospace;
            background-color: #555;
            color: #ccc;
            border-radius: 4pt;
            height: 25pt;
            box-shadow: 2pt 2pt 2pt #484848;
            border: 1px solid black;

            background-color: #000;
            color: #ccc;
        }

        .darkButton1 {
            background-color: #000;
            color: #ccc;
        }




        #controlsScrollbar {
            position: fixed;
            top: 0;
            left: 20;
            width: 15px;
            height: 100%;
            background: #000;
            cursor: pointer;

        }

        #controlsScrollbar .thumb,
        #worksheetAreaScrollbar .thumb {
            position: absolute;
            top: 0;
            left: 0;
            width: 13px;

            height: 30px;
            border-radius: 0px;
            border: 1px solid black;
            margin-left: 1px;
            width: 11px;



            background: #555;

            background:
                url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='%23ffffff'%3E%3Cpath d='M12 4l6 8H6z'/%3E%3C/svg%3E") top center no-repeat,
                /* Arrow pointing up */
                url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='%23ffffff'%3E%3Cpath d='M12 20l-6-8h12z'/%3E%3C/svg%3E") bottom center no-repeat,
                /* Arrow pointing down */
                #555;
            /* Background color for hover state */
            background-size: 15px auto, 15px auto, cover;
            /*   linear-gradient(to right, #383737 10%, #0b0a0a 40%, #474646 100%);*/

            background-size: 15px auto, 15px auto, cover;
            /* Size arrows and gradient appropriately */
            border-radius: 0px;
            border: 1px solid black;
            margin-left: 1px;

        }

        #controlsScrollbar .thumb:hover,
        #worksheetAreaScrollbar .thumb:hover {

            background:
                url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='%23ffffff'%3E%3Cpath d='M12 4l6 8H6z'/%3E%3C/svg%3E") top center no-repeat,
                /* Arrow pointing up */
                url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='%23ffffff'%3E%3Cpath d='M12 20l-6-8h12z'/%3E%3C/svg%3E") bottom center no-repeat,
                /* Arrow pointing down */
                #3d3d3d;
            /* Background color for hover state */
            background-size: 15px auto, 15px auto, cover;
        }

        #controlsScrollbar .thumb:active,
        #worksheetAreaScrollbar .thumb:active {
            background: #494949;
            background:
                url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='%23ffffff'%3E%3Cpath d='M12 4l6 8H6z'/%3E%3C/svg%3E") top center no-repeat,
                /* Arrow pointing up */
                url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='%23ffffff'%3E%3Cpath d='M12 20l-6-8h12z'/%3E%3C/svg%3E") bottom center no-repeat,
                /* Arrow pointing down */
                #343434;
            /* Background color for active state */
            background-size: 15px auto, 15px auto, cover;
        }


        #generatedWorksheetArea {
            margin: auto;
            margin-left: 11pt;
            padding: 0pt;
            position: relative;
            /* Add relative positioning to keep the scroll within bounds */
            height: 100%;
            /* Set a height that makes sense for your viewport */
            overflow-y: scroll;
            /* Enable scrolling */
            scrollbar-width: none;
            /* Hide default scrollbar for Firefox */

            /*  border:1px solid red; */

        }

        #generatedWorksheetArea .worksheetAreaSpacer {
            height: 15pt;
        }

        #generatedWorksheetArea::-webkit-scrollbar {
            display: none;
            /* Hide default scrollbar for Chrome, Safari, and Opera */
        }


        #worksheetAreaScrollbar {
            position: fixed;
            top: 0;

            right: 0px;
            /* Position to the right of #generatedWorksheetArea */
            width: 15px;

            bottom: 0;
            background: #000;
            cursor: pointer;
        }





        svg.worksheetPage {
            display: block;
            box-shadow: 5px 15px 10px gray;
            border: 1pt solid black;

        }


        #worksheetPagesContainer svg {}

        /* Hide controls when printing */
        @media print {

            svg.worksheetPage {
                box-shadow: none;
                padding: 0pt !important;
                border: 0;
                margin: 0pt;
            }

            #controls,
            .scrollbar,
            .worksheetAreaSpacer {
                display: none;
            }

            #container {
                padding: 0;
            }

            #generatedWorksheetArea {
                padding: 0;

                margin: auto;

            }

            .notForPrinting {
                display: none;
            }
        }
    </style>

    <!-- Include opentype.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/opentype.js/1.3.4/opentype.min.js"></script>

    <!-- jspdf -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>

    <!-- svg2pdf -->
    <script src="https://cdn.jsdelivr.net/npm/svg2pdf.js/dist/svg2pdf.min.js"></script>



</head>

<body>
    <div id="container">
        <!-- Configuration Area -->
        <div id="controls">
            <h1>Calligraphy And Lettering Worksheet Generator</h1>




            <div id="outputButtons">

                <table style="margin:0;padding:0">
                    <tr>
                        <td> <button onclick="window.print()" id="printButton" class="darkButton1">Print</button></td>
                        <td width="100%">
                            <p style="display: block; width: 100%;text-align: right;">(To save file, choose "PDF" as
                                printer.)
                            </p>
                        </td>
                    </tr>

                </table>




                <!--<button onclick="saveWorksheetToPDF()" id="saveWorksheetToPDFButton" class="darkButton1" >Save To PDF</button>-->


                <!--
                <button id="downloadPdfButton" class="darkButton1 notWorksheetGenerating">Download As PDF</button>
            -->

            </div>

            <!-- NIB WIDTH AND GUIDE FIELDSET -->
            <fieldset>
                <legend>Nib Width and Guide</legend>

                <div class="settingEnclosure">

                    <!-- Nib Width Input -->
                    <label for="nibWidth">Nib Width:</label>
                    <input type="number" id="nibWidth" value="3.8" min="0.1" step="0.1"> <span
                        class="labelNote">mm</span>
                </div>

                <div class="settingEnclosure indent">

                    <!-- Show Nib Guideline Labels -->
                    <input type="checkbox" id="showNibGuidelineLabels" checked>
                    <label for="showNibGuidelineLabels">Show Nib Guideline Labels</label>
                </div>

                <div class="settingEnclosure indent">

                    <!-- Show Nib Squares -->
                    <input type="checkbox" id="showNibSquares" checked>
                    <label for="showNibSquares">Show Nib Squares</label>
                </div>



            </fieldset>

            <!-- x-height Settings Fieldset -->
            <fieldset>
                <legend>x-height Settings</legend>
                <div class="settingEnclosure">

                    <!-- x-height Input -->
                    <label for="xHeight">X-Height:</label>
                    <input type="number" id="xHeight" value="5" min="0.1" step="0.1"> <span class="labelNote">× nib
                        width</span>
                </div>

                <div class="settingEnclosure indent hiddenTemporary">
                    <!-- x-height Background Color Picker -->
                    <label for="xHeightColor">Background Color:</label>
                    <input type="color" id="xHeightColor" value="#f0f0f0">
                </div>
                <div class="settingEnclosure indent hiddenTemporary">
                    <!-- x-height Background Opacity -->
                    <label for="xHeightOpacity">Background Opacity (0-1):</label>
                    <input type="number" id="xHeightOpacity" value="0.4" min="0" max="1" step="0.1">
                </div>
            </fieldset>

            <!-- Slant Guides Fieldset -->
            <fieldset>
                <legend>Grid Lines</legend>
                <div class="settingEnclosure">

                    <!-- Include Slant Guides Checkbox -->
                    <input type="checkbox" name="verticalLines" id="verticalLines">

                    <label for="verticalLines">Show Vertical Lines</label>
                </div>

                <div class="settingEnclosure indent">

                    <!-- Slant Angle Input -->
                    <label for="verticalSlantAngle">Vertical Slant Angle:</label>
                    <!--<input type="range" id="verticalSlantAngleSlider" value="15" min="0" max="90" step="1"> °<br>-->
                    <input type="number" id="verticalSlantAngle" value="15" min="0" max="60" step="1"> °
                </div>

                <div class="settingEnclosure indent">

                    <!-- Slant Line Spacing -->
                    <label for="verticalLineSpacing">Vertical Line Spacing:</label><br />
                    <input type="number" id="verticalLineSpacing" value="2" min="0.1" step="0.1">
                    <span class="labelNote">× nib width</span>
                </div>
            </fieldset>


            <!-- Ascender and Descender Settings Fieldset -->
            <fieldset>
                <legend>Ascender and Descender</legend>
                <div class="settingEnclosure">

                    <!-- Capital Height Input -->
                    <label for="capitalHeight">Capital Height:</label><br>
                    <input type="number" id="capitalHeight" value="0.4" min="0" step="0.1"> <span class="labelNote">×
                        x-height</span>
                </div>
                <div class="settingEnclosure">

                    <!-- Ascender Height Input -->
                    <label for="ascenderHeight">Ascender Height:</label><br>
                    <input type="number" id="ascenderHeight" value="0.5" min="0" step="0.1"> <span class="labelNote">×
                        x-height</span>
                </div>
                <div class="settingEnclosure">

                    <!-- Descender Depth Input -->
                    <label for="descenderDepth">Descender Depth:</label><br>
                    <input type="number" id="descenderDepth" value="0.6" min="0" step="0.1"> <span class="labelNote">×
                        x-height</span>
                </div>
            </fieldset>


            <fieldset>
                <legend>Page</legend>


                <div class="settingEnclosure">

                    <label for="orientation">
                        Orientation:
                    </label> <br />

                    <input type="radio" name="orientation" id="orientationPortraitRadio" value="portrait" checked>

                    <label for="orientationPortraitRadio" class="radioLabel">
                        Portrait
                    </label>

                    <input type="radio" name="orientation" id="orientationLandscapeRadio" value="landscape">
                    <label for="orientationLandscapeRadio" class="radioLabel">
                        Landscape
                    </label>

                </div>

                <div class="settingEnclosure">

                    <label for="paperSize">Paper Size: </label><br />
                    <select id="paperSize" name="paperSize">
                        <option value="612,792" checked>Letter (8.5in x 11in)</option>
                        <option value="612,1008">Legal (8.5in x 14in)</option>
                        <option value="595,842">A4 (210mm x 297mm)</option>
                        <option value="842,1191">A3 (297mm x 420mm)</option>
                    </select>
                </div>

            </fieldset>



            <fieldset class="hiddenTemporary">
                <legend>Practice Font Characters</legend>

                <div class="settingEnclosure">

                    <input type="checkbox" id="showFont">
                    <label for="showFont">Show Practice Font Characters</label>

                </div>
                <div class="settingEnclosure indent">

                    <label for="fontForWorksheetPages">Font:</label>

                    <select id="fontForWorksheetPages" name="fontForWorksheetPages">
                        <!--<option value="Drafting" checked>Drafting Gothic</option>-->
                        <option value="BreitkopfFraktur">Fraktur - Breitkopf Fraktur </option>
                        <!--<option value="Blackletter">Blackletter</option>-->
                        <!--<option value="Uncial">Uncial</option>-->

                    </select>
                </div>



                <div class="settingEnclosure indent indent2">
                    <button id="uploadFont" class="darkButton1">Upload Font</button>
                    <input type="file" id="fontFileInput" accept=".ttf,.otf" style="display: none;">

                </div>


                <div class="settingEnclosure">
                    <label for="caseSelection">Characters:</label>
                    <select id="caseSelection" name="caseSelection">
                        <option value="lowercaseOnly" checked>Lowercase Only</option>
                        <option value="uppercaseOnly">Uppercase Only</option>
                        <option value="bothUppercaseAndLowercase">Both Lowercase and Uppercase</option>
                        <option value="customText">Custom Practice Text</option>

                    </select>


                </div>

                <div class="settingEnclosure indent">
                    <input type="checkbox" id="includeNumberCharacters">
                    <label for="includeNumberCharacters">Include Number Characters</label>
                </div>

                <div class="settingEnclosure indent">
                    <label for="customPracticeText">Custom Practice Text:</label>
                    <textarea id="customPracticeText" name="customPracticeText" rows="5" maxlength="45"></textarea>
                </div>


                <!--
<select id="extraCharacterSets" name="extraCharactersSets">
    <option value="numbersOnly" checked>Numbers</option>
    <option value="number">Numbers and Punctuation</option>
</select>
-->

                <div class="settingEnclosure">

                    <label for="practiceCharactersArrangement">Practice Characters Arrangement:</label>

                    <select id="practiceCharactersArrangement" name="practiceCharactersArrangement">
                        <option value="RowsOfCharacters" checked>Rows of Characters</option>
                        <option value="singleCharacterAtLeft">Single Character At Left</option>

                        <!--<option value="CustomText">Custom Practice Text at Top</option>-->
                    </select>

                </div>


            </fieldset>




            <!-- Generate Grid Button -->
            <!-- <button onclick="makeWorksheetPages()" id="generateWorksheet" class="darkButton1">Generate Sheet</button>-->

            <p style="text-align: center;">
                <!-- <button onclick="makeWorksheetPages()" id="resetSettingsButton" class="darkButton1">Reset Settings</button>-->
                <a id="emailLink" style="color:white;" href="mailto:calligraphy[-at-]noctivagous[-dot-]com">
                    Email </a>
            </p>
        </div>

        <div id="controlsScrollbar" class="scrollbar"></div>


        <div id="generatedWorksheetArea">
            <div class="worksheetAreaSpacer"></div>

            <div id="worksheetPagesContainer">

            </div>

            <div class="worksheetAreaSpacer"></div>

        </div>

        <div id="worksheetAreaScrollbar" class="scrollbar"></div>

    </div>

    <!-- JavaScript Code -->
    <script type="module">


        document.addEventListener('DOMContentLoaded', function () {
            // Initialize and add event listeners
            init();


        });

        document.addEventListener('DOMContentLoaded', function () {
            // Initialize the scrollbars for #controls
            const controls = document.getElementById('controls');
            const controlsScrollbar = document.getElementById('controlsScrollbar');
            const thumb = document.createElement('div');
            thumb.className = 'thumb';
            controlsScrollbar.appendChild(thumb);

            function updateThumbPosition() {
                const scrollHeight = controls.scrollHeight - controls.clientHeight;
                const thumbHeight = Math.max(30, (controls.clientHeight / controls.scrollHeight) * controlsScrollbar.clientHeight);
                thumb.style.height = thumbHeight + 'px';
                const scrollRatio = controls.scrollTop / scrollHeight;
                const thumbTop = scrollRatio * (controlsScrollbar.clientHeight - thumbHeight);
                thumb.style.top = thumbTop + 'px';
            }

            function onThumbMouseDown(event) {
                event.preventDefault();
                const startY = event.clientY;
                const startTop = parseInt(thumb.style.top, 10) || 0;

                function onMouseMove(event) {
                    const deltaY = event.clientY - startY;
                    const newTop = Math.min(
                        Math.max(0, startTop + deltaY),
                        controlsScrollbar.clientHeight - thumb.clientHeight
                    );
                    thumb.style.top = newTop + 'px';

                    const scrollHeight = controls.scrollHeight - controls.clientHeight;
                    const scrollRatio = newTop / (controlsScrollbar.clientHeight - thumb.clientHeight);
                    controls.scrollTop = scrollHeight * scrollRatio;
                }

                function onMouseUp() {
                    document.removeEventListener('mousemove', onMouseMove);
                    document.removeEventListener('mouseup', onMouseUp);
                }

                document.addEventListener('mousemove', onMouseMove);
                document.addEventListener('mouseup', onMouseUp);
            }

            thumb.addEventListener('mousedown', onThumbMouseDown);
            controls.addEventListener('scroll', updateThumbPosition);
            window.addEventListener('resize', updateThumbPosition);

            updateThumbPosition();


            // Initialize the scrollbars for #generatedWorksheetArea
            const generatedWorksheetArea = document.getElementById('generatedWorksheetArea');
            const worksheetAreaScrollbar = document.getElementById('worksheetAreaScrollbar');
            const generatedThumb = document.createElement('div');
            generatedThumb.className = 'thumb';
            worksheetAreaScrollbar.appendChild(generatedThumb);

            function updateGeneratedThumbPosition() {
                const scrollHeight = generatedWorksheetArea.scrollHeight - generatedWorksheetArea.clientHeight;
                const thumbHeight = Math.max(30, (generatedWorksheetArea.clientHeight / generatedWorksheetArea.scrollHeight) * worksheetAreaScrollbar.clientHeight);
                generatedThumb.style.height = thumbHeight + 'px';
                const scrollRatio = generatedWorksheetArea.scrollTop / scrollHeight;
                const thumbTop = scrollRatio * (worksheetAreaScrollbar.clientHeight - thumbHeight);
                generatedThumb.style.top = thumbTop + 'px';
            }

            function onGeneratedThumbMouseDown(event) {
                event.preventDefault();
                const startY = event.clientY;
                const startTop = parseInt(generatedThumb.style.top, 10) || 0;

                function onMouseMove(event) {
                    const deltaY = event.clientY - startY;
                    const newTop = Math.min(
                        Math.max(0, startTop + deltaY),
                        worksheetAreaScrollbar.clientHeight - generatedThumb.clientHeight
                    );
                    generatedThumb.style.top = newTop + 'px';

                    const scrollHeight = generatedWorksheetArea.scrollHeight - generatedWorksheetArea.clientHeight;
                    const scrollRatio = newTop / (worksheetAreaScrollbar.clientHeight - generatedThumb.clientHeight);
                    generatedWorksheetArea.scrollTop = scrollHeight * scrollRatio;
                }

                function onMouseUp() {
                    document.removeEventListener('mousemove', onMouseMove);
                    document.removeEventListener('mouseup', onMouseUp);
                }

                document.addEventListener('mousemove', onMouseMove);
                document.addEventListener('mouseup', onMouseUp);
            }

            generatedThumb.addEventListener('mousedown', onGeneratedThumbMouseDown);
            generatedWorksheetArea.addEventListener('scroll', updateGeneratedThumbPosition);
            window.addEventListener('resize', updateGeneratedThumbPosition);

            updateGeneratedThumbPosition();
        });

        document.getElementById('uploadFont').addEventListener('click', function () {
            document.getElementById('fontFileInput').click();
        });

        document.getElementById('fontFileInput').addEventListener('change', function (event) {
            var file = event.target.files[0];
            if (file) {
                var reader = new FileReader();
                reader.onload = function (e) {
                    opentype.load(e.target.result, function (err, loadedFont) {
                        if (err) {
                            alert('Could not load font: ' + err);
                        } else {
                            font = loadedFont;
                            makeWorksheetPages();
                        }
                    });
                };
                reader.readAsArrayBuffer(file);
            }
        });


        function init() {
            // Add event listeners to controls
            // Select all input, select, and textarea elements within #controls, but exclude those with the class '.notWorksheetGenerating'
            var controls = document.querySelectorAll(
                '#controls input:not(.notWorksheetGenerating), #controls select:not(.notWorksheetGenerating), #controls textarea:not(.notWorksheetGenerating)'
            );

            controls.forEach(function (control) {
                control.addEventListener('change', function () { makeWorksheetPages(); });
            });


            //  document.getElementById('downloadPdfButton').addEventListener('click', downloadPdf);


            var fontChangingControls = document.querySelectorAll('#showFont, #fontForWorksheetPages');

            fontChangingControls.forEach(function (fontRelatedControl) {
                fontRelatedControl.addEventListener('change', function () {
                    if (document.getElementById('showFont').checked) {
                        loadFontAndMakeWorksheetPages();

                    } else {
                        makeWorksheetPages(); // Generate without loading a new font
                    }
                });

            });







            // Initial grid drawing
            makeWorksheetPages();
        }

        async function downloadPdf() {
            // Import jsPDF and svg2pdf modules
            const { jsPDF } = window.jspdf;

            // Create a new jsPDF instance
            const pdf = new jsPDF({
                orientation: 'portrait',
                unit: 'pt',
                format: [paperSize[0], paperSize[1]], // Example paper size corresponding to SVG size
            });

            // Get all SVG elements representing the worksheet pages
            const svgElements = document.querySelectorAll('.worksheetPage');

            for (let i = 0; i < svgElements.length; i++) {
                if (i > 0) {
                    // Add a new page for each SVG
                    pdf.addPage();
                }

                // Get the SVG element
                const svgElement = svgElements[i];


                try {
                    // Use await to ensure that the conversion is completed before continuing
                    await convertTextToPathsWithKerning(svgElement);
                    console.log('Text elements have been converted to paths.');
                } catch (error) {
                    console.error('Error converting text to paths:', error);
                }

                // Directly use svg2pdf to convert the SVG to PDF
                await svg2pdf(svgElement, pdf, {
                    xOffset: marginHorizontal / 2,
                    yOffset: marginVertical / 2,
                    scale: 1, // Adjust scale as needed
                });
            }

            // Save the PDF
            pdf.save('worksheet.pdf');
        }


        async function convertTextToPathsWithKerning(svgElement) {
            const fontUrl = 'fonts/noto-sans.regular.ttf'; // Update with your font file location
            const font = await opentype.load(fontUrl);

            const textElements = svgElement.querySelectorAll('text');
            textElements.forEach(textElement => {
                const text = textElement.textContent;
                const fontSize = parseFloat(textElement.getAttribute('font-size')) || 16;
                const x = parseFloat(textElement.getAttribute('x')) || 0;
                const y = parseFloat(textElement.getAttribute('y')) || 0;

                let currentX = x;
                let pathData = "";

                // Get the glyphs and apply kerning manually
                const glyphs = font.stringToGlyphs(text);
                for (let i = 0; i < glyphs.length; i++) {
                    const glyph = glyphs[i];
                    const glyphPath = glyph.getPath(currentX, y, fontSize);
                    pathData += glyphPath.toPathData();

                    // Move to the next position based on the width of the current glyph
                    currentX += glyph.advanceWidth * (fontSize / font.unitsPerEm);

                    // Apply kerning between the current glyph and the next one
                    if (i < glyphs.length - 1) {
                        const kerningValue = font.getKerningValue(glyph, glyphs[i + 1]);
                        currentX += kerningValue * (fontSize / font.unitsPerEm);
                    }
                }

                // Create a new path element
                const pathElement = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                pathElement.setAttribute('d', pathData);
                pathElement.setAttribute('fill', textElement.getAttribute('fill') || 'black');

                // Replace text element with path element
                textElement.parentNode.replaceChild(pathElement, textElement);
            });
        }

        // GLOBALS
        var mmToPt = 2.83465;    // Conversion factor from mm to pt

        // SETTINGS WITH DEFAULTS
        var nibWidthMm = 3.8;
        var nibWidth = nibWidthMm * mmToPt; // Nib width in points
        var xHeightNibWidths = 4;
        var xHeightColor = document.getElementById('xHeightColor').value;
        var xHeightOpacity = 0.4;
        var showNibGuidelineLabels = true;
        var showNibSquares = true;
        var showVerticalLines = false;
        var verticalSlantAngle = 15;
        var verticalLineSpacingMultiplier = 2;
        var ascenderMultiplier = 0.5;
        var descenderMultiplier = 0.6;
        var capitalMultiplier = 0.4;
        var showFont = false;
        var fontWasLoadedForShowFont = false;
        var documentWidthPt = 500;
        var documentHeightPt = 500;

        var paperSize = document.getElementById('paperSize').value.split(',').map(Number);
        var orientation = 'portrait';

        var marginHorizontalInches = 0.4;
        var marginVerticalInches = 0.4;

        var marginHorizontal = 2 * marginHorizontalInches * 72; // Convert inches to points
        var marginVertical = 2 * marginVerticalInches * 72;     // Convert inches to points

        async function loadFontAndMakeWorksheetPages() {
            try {
                showFont = document.getElementById('showFont').checked;

                if (!showFont) {
                    makeWorksheetPages();
                    return;
                }

                const fontSelect = document.getElementById('fontForWorksheetPages');
                const fontName = fontSelect.value;
                const fontUrl = getFontUrl(fontName);

                // Load the font asynchronously
                font = await loadFontAsync(fontUrl).then(result => {
                    console.log(result);  // Outputs: "Operation successful"
                });


                //charsPerLineGlobal = calculateCharsPerLine();

                //console.log("charsPerLineGlobal:" + charsPerLineGlobal);


                fontWasLoadedForShowFont = true;
                makeWorksheetPages();  // Only called once the font is fully loaded
            } catch (error) {
                console.error(error);
                alert('Could not load font: ' + error);
                fontWasLoadedForShowFont = false;
            }
        }

        function loadFontAsync(fontUrl) {
            return new Promise((resolve, reject) => {
                opentype.load(fontUrl, function (err, loadedFont) {
                    if (err) {
                        reject('Could not load font: ' + err);
                    } else {

                        resolve(loadedFont);
                    }
                });
            });
        }


        function makeWorksheetPages() {
            pullPracticeBlockSettingsFromFormFields();
            pullPaperSizeFromFormFields();

            emptyWorksheetArea();


            loadFont(function () {
                emptyWorksheetArea();


                // Determine the number of pages based on user selections
                var numberOfPages = calculateNumberOfPages();

                for (var i = 0; i < numberOfPages; i++) {
                    // Create SVG element
                    var svg = createSVGElement();

                    // Append SVG to worksheetPagesContainer
                    var container = document.getElementById('worksheetPagesContainer');
                    container.appendChild(svg);

                    // Call drawWorksheet(svg, i)
                    drawWorksheet(svg, i);
                }
            });

        }

        var charsPerLineGlobal = 4;

        function calculateNumberOfPages() {

            if (showFont == false) {
                return 1;
            }

            var linesPerPage = calculateLinesPerPage();

            charsPerLineGlobal = calculateCharsPerLine();

            var charsPerPage = linesPerPage * charsPerLineGlobal;

            var totalCharacters = getTotalCharacters();

            var numberOfPages = Math.ceil(totalCharacters / charsPerPage);

            console.log("totalChars:" + totalCharacters);
            console.log("charsPerPage" + charsPerPage);
            console.log("charsPerLineGlobal:" + charsPerLineGlobal);

            return numberOfPages;
        }

        function getTotalCharacters() {
            // Calculate total number of characters based on user input settings
            const selectedValue = document.getElementById("caseSelection").value;
            const includeNumbers = document.getElementById("includeNumberCharacters").checked;

            let selectedCharacters = [];

            if (selectedValue === "lowercaseOnly") {
                selectedCharacters = lowercaseAlphabet;
            } else if (selectedValue === "uppercaseOnly") {
                selectedCharacters = uppercaseAlphabet;
            } else if (selectedValue === "bothUppercaseAndLowercase") {
                selectedCharacters = lowercaseAlphabet.concat(uppercaseAlphabet);
            } else if (selectedValue === "customText") {
                const customText = document.getElementById("customPracticeText").value;
                selectedCharacters = customText.split('').filter(char => char.trim() !== ''); // Exclude empty characters
            }

            if (includeNumbers && selectedValue !== "customText") {
                selectedCharacters = selectedCharacters.concat(numberCharacters);
            }

            return selectedCharacters.length;
        }

        function createSVGElement() {
            // Create SVG element
            var svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
            svg.setAttribute('class', 'worksheetPage');

            // Adjust paper width and height for margin
            var width = paperSize[0] - marginHorizontal;
            var height = paperSize[1] - marginVertical;

            // Swap width and height if landscape orientation is selected
            if (orientation === 'landscape') {
                [width, height] = [height, width];
            }

            svg.setAttribute('width', width + 'pt');
            svg.setAttribute('height', height + 'pt');
            svg.setAttribute('viewBox', `0 0 ${width} ${height}`);

            // Create background rectangle
            var rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
            rect.setAttribute('width', '100%');
            rect.setAttribute('height', '100%');
            rect.setAttribute('fill', 'white');
            svg.appendChild(rect);

            svg.classList.add("worksheetPage");


            // Apply padding to SVG

            svg.style.paddingLeft = `${marginHorizontal / 2 - 1}pt`;
            svg.style.paddingRight = `${marginHorizontal / 2}pt`;
            svg.style.paddingTop = `${marginVertical / 2}pt`;
            svg.style.paddingBottom = `${marginVertical / 2}pt`;

            return svg;
        }

        function emptyWorksheetArea() {
            var container = document.getElementById('worksheetPagesContainer');
            while (container.firstChild) {
                container.removeChild(container.firstChild);
            }
        }



        function pullPracticeBlockSettingsFromFormFields() {
            showFont = document.getElementById('showFont').checked;

            // Get nib width in mm and convert to pt
            nibWidthMm = parseFloat(document.getElementById('nibWidth').value);

            if (isNaN(nibWidthMm) || nibWidthMm <= 0) {
                document.getElementById('nibWidth').value = 3.8;
                nibWidthMm = parseFloat(document.getElementById('nibWidth').value);
                alert("Please enter a positive number for the nib width.");
                return;
            }

            nibWidth = nibWidthMm * mmToPt;

            xHeightNibWidths = parseFloat(document.getElementById('xHeight').value);
            if (isNaN(xHeightNibWidths) || xHeightNibWidths <= 0) {
                document.getElementById('xHeight').value = 4;
                xHeightNibWidths = 4;
                alert("Please enter a positive number for x-height in nib widths.");
                return;
            }


            xHeightOpacity = parseFloat(document.getElementById('xHeightOpacity').value);
            if (isNaN(xHeightOpacity) || xHeightOpacity < 0 || xHeightOpacity > 1) {
                document.getElementById('xHeightOpacity').value = 0.4;
                xHeightOpacity = 0.4;
                alert("Please enter a valid opacity between 0 and 1.");
                return;
            }

            showNibGuidelineLabels = document.getElementById('showNibGuidelineLabels').checked;
            showNibSquares = document.getElementById('showNibSquares').checked;


            // Grid Lines
            showVerticalLines = document.getElementById('verticalLines').checked;

            verticalSlantAngle = parseFloat(document.getElementById('verticalSlantAngle').value);
            if (isNaN(verticalSlantAngle) || verticalSlantAngle < 0 || verticalSlantAngle > 60) {
                document.getElementById('verticalSlantAngle').value = 0;
                verticalSlantAngle = 0;
                alert("Please enter a slant angle between 0 and 60 degrees.");
                return;
            }

            verticalLineSpacingMultiplier = parseFloat(document.getElementById('verticalLineSpacing').value);
            if (isNaN(verticalLineSpacingMultiplier) || verticalLineSpacingMultiplier <= 0) {
                document.getElementById('verticalLineSpacing').value = 2;
                alert("Please enter a positive number for slant line spacing multiplier.");
                return;
            }


            ascenderMultiplier = parseFloat(document.getElementById('ascenderHeight').value);
            if (isNaN(ascenderMultiplier) || ascenderMultiplier < 0) {
                document.getElementById('ascenderHeight').value = 0.5;
                ascenderMultiplier = 0.5;
                alert("Please enter a non-negative number for ascender height multiplier.");
                return;
            }

            descenderMultiplier = parseFloat(document.getElementById('descenderDepth').value);
            if (isNaN(descenderMultiplier) || descenderMultiplier < 0) {
                document.getElementById('descenderDepth').value = 0.6;
                descenderMultiplier = 0.6;
                alert("Please enter a non-negative number for descender depth multiplier.");
                return;
            }

            capitalMultiplier = parseFloat(document.getElementById('capitalHeight').value);
            if (isNaN(capitalMultiplier) || capitalMultiplier < 0) {
                document.getElementById('capitalHeight').value = 0.4;
                capitalMultiplier = 0.4;
                alert("Please enter a non-negative number for capital height multiplier.");
                return;
            }

            // If practice font characters are enabled, adjust practice block sizes
            showFont = document.getElementById('showFont').checked;

            if (showFont && font) {
                var fontUnitsPerEm = font.unitsPerEm;
                var ascender = font.ascender;
                var descender = font.descender;
                var xHeightValue = getSXHeight() || (ascender / 2);

                // Convert font metrics to proportions relative to x-height
                ascenderMultiplier = (ascender - xHeightValue) / xHeightValue;
                descenderMultiplier = Math.abs(descender) / xHeightValue;
                capitalMultiplier = (font.tables.os2.sCapHeight || ascender) / xHeightValue;

                // Update nib width to match font size (if needed)
                // You might adjust nibWidthMm based on font size
            }


        }

        function pullPaperSizeFromFormFields() {
            // Get selected paper size and orientation
            paperSize = document.getElementById('paperSize').value.split(',').map(Number);
            orientation = document.querySelector('input[name="orientation"]:checked').value;

            marginHorizontalInches = 0.4;
            marginVerticalInches = 0.4;

            marginHorizontal = 2 * marginHorizontalInches * 72; // Convert inches to points
            marginVertical = 2 * marginVerticalInches * 72;     // Convert inches to points
        }



        function drawWorksheet(svg, pageIndex) {
            // Get the width and height from the svg attributes
            var width = parseFloat(svg.getAttribute('width'));
            var height = parseFloat(svg.getAttribute('height'));

            // Create the main group for the worksheet
            var worksheetGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            worksheetGroup.setAttribute('class', 'worksheetGroup');
            svg.appendChild(worksheetGroup);

            // Define stroke width in points
            var strokeWidth = 0.6;

            // Draw outer rectangle
            drawOuterRectangle(worksheetGroup, width, height, strokeWidth);

            // Draw background horizontal lines at every nib width
            var backgroundLinesGroup = document.createElementNS("http://www.w3.org/2000/svg", "g");
            backgroundLinesGroup.setAttribute("class", "backgroundLines");
            worksheetGroup.appendChild(backgroundLinesGroup);

            // Draw slant guides if selected
            if (showVerticalLines) {
                var slantGroup = document.createElementNS("http://www.w3.org/2000/svg", "g");
                slantGroup.setAttribute("class", "verticalLines");
                worksheetGroup.appendChild(slantGroup);

                drawSlantGuides(slantGroup, width, height, strokeWidth);
            }

            // Draw practice blocks with x-height area shaded
            var practiceBlocksGroup = document.createElementNS("http://www.w3.org/2000/svg", "g");
            practiceBlocksGroup.setAttribute("class", "practiceBlocks");
            worksheetGroup.appendChild(practiceBlocksGroup);

            // Fetch characters to render for this page
            var charactersForPage;

            charactersForPage = getCharactersForPage(pageIndex);

            drawPracticeBlocks(practiceBlocksGroup, backgroundLinesGroup, width, height, strokeWidth, charactersForPage);
        }


        // CHARACTERS FOR PRACTICE FONT TO PLACE IN WORKSHEET
        // Define the character arrays
        const lowercaseAlphabet = ["a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z"];
        const uppercaseAlphabet = ["A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z"];
        const numberCharacters = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9"];
        /*
                function getCharactersForPage(pageIndex) {
        
                    if (showFont == false) {
                        return [""];
                    }
        
                    const selectedValue = document.getElementById("caseSelection").value;
                    const includeNumbers = document.getElementById("includeNumberCharacters").checked;
        
                    let selectedCharacters = [];
        
                    // Determine the selected characters based on the dropdown value
                    if (selectedValue === "lowercaseOnly") {
                        selectedCharacters = lowercaseAlphabet;
                    } else if (selectedValue === "uppercaseOnly") {
                        selectedCharacters = uppercaseAlphabet;
                    } else if (selectedValue === "bothUppercaseAndLowercase") {
                        selectedCharacters = lowercaseAlphabet.concat(uppercaseAlphabet);
                    }
                    else if (selectedValue === "customText") {
                        // Get custom practice text from the textarea
                        const customText = document.getElementById("customPracticeText").value;
                        // Convert custom text to an array of characters
                        selectedCharacters = customText.split('').filter(char => char.trim() !== ''); // Exclude empty characters
                    }
        
                    // Include numbers if the checkbox is checked
                    if (includeNumbers && selectedValue !== "customText") {
                        selectedCharacters = selectedCharacters.concat(numberCharacters);
                    }
        
                    return selectedCharacters;
        
                }
        */
        var font; // Global variable to hold the loaded font

        function loadFont(callback) {

            if (showFont == false) {
                callback();
                return;
            }

            var fontSelect = document.getElementById('fontForWorksheetPages');
            var fontName = fontSelect.value;

            // For custom fonts, you might handle file uploads
            var fontUrl = getFontUrl(fontName);

            opentype.load(fontUrl, function (err, loadedFont) {
                if (err) {
                    fontWasLoadedForShowFont = false;
                    alert('Could not load font: ' + err);
                    callback();
                } else {
                    font = loadedFont;
                    fontWasLoadedForShowFont = true;
                    callback();
                }
            });
        }

        function getFontUrl(fontName) {
            // Map font names to URLs
            var fontUrls = {
                //                'Drafting': 'fonts/drafting.ttf',
                'BreitkopfFraktur': 'fonts/BreitkopfFraktur.ttf',
                //              'Blackletter': 'fonts/blackletter.ttf',
                //            'Uncial': 'fonts/uncial.ttf'
            };
            return fontUrls[fontName];
        }

        function drawOuterRectangle(group, width, height, strokeWidth) {
            var outerRect = document.createElementNS("http://www.w3.org/2000/svg", "rect");
            outerRect.setAttribute("x", 0);
            outerRect.setAttribute("y", 0);
            outerRect.setAttribute("width", width);
            outerRect.setAttribute("height", height);
            outerRect.setAttribute("fill", "none");
            outerRect.setAttribute("stroke", "#000");
            outerRect.setAttribute("stroke-width", strokeWidth);
            group.appendChild(outerRect);
        }

        function drawSlantGuides(slantGroup, width, height, strokeWidth) {
            var angleRadians = verticalSlantAngle * Math.PI / 180;
            var tanAngle = Math.tan(angleRadians); // Slope of the slant lines

            // Spacing between slant lines
            var verticalLineSpacing = nibWidth * verticalLineSpacingMultiplier;

            // For vertical lines (90 degrees), handle separately
            if (verticalSlantAngle !== 90) {
                // Starting x position for slant lines
                var xStart = -height * tanAngle;
                var xEnd = width + height * tanAngle;
                for (var x = xStart; x <= xEnd; x += verticalLineSpacing) {
                    var x1 = x;
                    var y1 = 0;
                    var x2 = x - height * tanAngle;
                    var y2 = height;

                    // Clip the line to the bounds of the document
                    var clippedLine = clipLineToRect(x1, y1, x2, y2, 0, 0, width, height);
                    if (clippedLine) {
                        var line = document.createElementNS("http://www.w3.org/2000/svg", "line");
                        line.setAttribute("x1", clippedLine.x1);
                        line.setAttribute("y1", clippedLine.y1);
                        line.setAttribute("x2", clippedLine.x2);
                        line.setAttribute("y2", clippedLine.y2);
                        line.setAttribute("stroke", "#ccc");
                        line.setAttribute("stroke-width", strokeWidth);
                        slantGroup.appendChild(line);
                    }
                }
            }
        }

        function drawPracticeBlocks(practiceBlocksGroup, backgroundLinesGroup, width, height, strokeWidth, charactersForPage) {
            // Calculate total nib height per block
            var nibHeight = nibWidth; // For clarity
            var nibRectWidth = nibWidth;
            var xHeight = xHeightNibWidths * nibHeight;
            var ascenderNibWidths = xHeightNibWidths; // Assuming ascender height equal to x-height
            var capitalNibWidths = xHeightNibWidths * 0.7; // For example, 70% of x-height
            var descenderNibWidths = xHeightNibWidths; // Assuming descender height equal to x-height

            var ascenderHeight = ascenderMultiplier * xHeight;
            var capitalHeight = capitalMultiplier * xHeight;
            var descenderHeight = descenderMultiplier * xHeight;

            // totalSectionHeight
            var totalBlockHeight = ascenderHeight + capitalHeight + xHeight + descenderHeight;

            var yPosition = 0;
            var charIndex = 0;

            while (yPosition <= (height - totalBlockHeight)) {
                var charactersForLine = [""];
                if (showFont == true) {
                    //console.log(charIndex);
                    charactersForLine = getCharactersForLine(charactersForPage, charIndex, width);

                }
                drawPracticeBlock(practiceBlocksGroup, backgroundLinesGroup, yPosition, width, strokeWidth, nibHeight, xHeight, ascenderHeight, capitalHeight, descenderHeight, charactersForLine);

                yPosition += totalBlockHeight + nibHeight; // Move y to next block, adding a nibHeight gap
                charIndex += charactersForLine.length;
            }
        }



        function drawPracticeBlock(practiceBlocksGroup, backgroundLinesGroup, y, width, strokeWidth, nibHeight, xHeight, ascenderHeight, capitalHeight, descenderHeight, charactersForLine) {
            // Variables for line positions
            var ascenderY = y;
            var capitalY = ascenderY + ascenderHeight;
            var waistlineY = capitalY + capitalHeight;
            var baselineY = waistlineY + xHeight;
            var descenderY = baselineY + descenderHeight;
            var midlineY = waistlineY + xHeight / 2;


            // Shade x-height area
            shadeXHeightArea(practiceBlocksGroup, y, width, xHeight, ascenderHeight, capitalHeight);

            fillGapBetweenBlocks(practiceBlocksGroup, descenderY, width, nibHeight);


            // Draw guide lines
            drawGuideLines(practiceBlocksGroup, width, strokeWidth, ascenderY, capitalY, waistlineY, midlineY, baselineY, descenderY);

            // Draw horizontal lines
            drawHorizontalLines(backgroundLinesGroup, width, strokeWidth, nibWidth, baselineY, ascenderY, descenderY);

            // Draw nib guide if selected
            if (showNibSquares) {
                drawNibGuide(practiceBlocksGroup, ascenderY, waistlineY, baselineY, descenderY, nibHeight, nibWidth);
            }

            // Draw nib guideline labels if selected
            if (showNibGuidelineLabels) {
                drawNibGuidelineLabels(practiceBlocksGroup, ascenderY, capitalY, waistlineY, baselineY, descenderY);
            }

            // After drawing guidelines, render the characters
            renderCharacters(practiceBlocksGroup, charactersForLine, xHeight, ascenderHeight, capitalHeight, baselineY, y);

        }

        function renderCharacters(group, characters, xHeight, ascenderHeight, capitalHeight, baselineY, blockY) {
            var practiceArrangement = document.getElementById('practiceCharactersArrangement').value;

            if (!showFont || !font) return;

            // Calculate scaling factor to fit font into x-height
            var fontUnitsPerEm = font.unitsPerEm;
            var scale = xHeight / getSXHeight();

            // Set initial x position
            var xPosition = 50; // Adjust as needed
            var spacing = 20; // Space between characters

            characters.forEach(function (char) {
                var glyph = font.charToGlyph(char);
                var path = glyph.getPath(0, 0, font.unitsPerEm);

                // Create SVG path element
                var svgPath = document.createElementNS("http://www.w3.org/2000/svg", "path");
                svgPath.setAttribute("d", path.toPathData(5));
                svgPath.setAttribute("fill", "#000"); // Set desired color

                // Calculate transformation to position the character
                var x = xPosition;
                var y = baselineY + blockY;

                var transform = `translate(${x}, ${y}) scale(${scale}, ${scale})`;
                svgPath.setAttribute("transform", transform);

                group.appendChild(svgPath);

                xPosition += (glyph.advanceWidth * scale) + spacing;
            });
        }

        function getCharactersForPage(pageIndex) {
            showFont = document.getElementById('showFont').checked;
            if (!showFont) return [];

            var caseSelection = document.getElementById('caseSelection').value;
            var includeNumbers = document.getElementById('includeNumberCharacters').checked;
            var practiceArrangement = document.getElementById('practiceCharactersArrangement').value;
            var customText = document.getElementsByName('customPracticeText')[0].value.trim();

            var characters = [""];

            if (practiceArrangement === 'customText') {
                characters = customText.split('');
            } else {
                if (caseSelection === 'lowercaseOnly') {
                    characters = lowercaseAlphabet;
                }
                if (caseSelection === 'uppercaseOnly') {
                    characters = uppercaseAlphabet;
                }
                if (includeNumbers) {
                    characters = numberCharacters;
                }
            }

            // Calculate total pages
            var linesPerPage = calculateLinesPerPage();
            var charsPerPage = linesPerPage * charsPerLineGlobal;

            // Slice characters for current page
            var startIndex = pageIndex * charsPerPage;
            var endIndex = startIndex + charsPerPage;
            return characters.slice(startIndex, endIndex);
        }

        function getCharactersForLine(characters, charIndex, width) {
            var practiceArrangement = document.getElementById('practiceCharactersArrangement').value;
            var maxCharsPerLine = charsPerLineGlobal;

            var charsForLine = characters.slice(charIndex, charIndex + maxCharsPerLine);
            return charsForLine;
        }

        function calculateLinesPerPage() {
            var nibHeight = nibWidth;
            var xHeight = xHeightNibWidths * nibHeight;
            var ascenderHeight = ascenderMultiplier * xHeight;
            var capitalHeight = capitalMultiplier * xHeight;
            var descenderHeight = descenderMultiplier * xHeight;
            var totalBlockHeight = ascenderHeight + capitalHeight + xHeight + descenderHeight;


            var height = paperSize[1] - marginVertical;

            var linesPerPage = Math.floor(height / (totalBlockHeight + nibHeight));


            return linesPerPage;
        }

        function getSXHeight() {

            var estimatedXHeight = (font.tables.os2.sTypoAscender - font.tables.os2.sTypoDescender) / 2;
            var sxHeight = font.tables.os2.sxHeight || estimatedXHeight;

            return sxHeight;
        }

        function calculateCharsPerLine() {

            var practiceArrangement = document.getElementById('practiceCharactersArrangement').value;
            if (practiceArrangement === 'Single Character At Left') {
                return 1;
            }

            // Estimate character width after scaling
            var xHeight = xHeightNibWidths * nibWidth;



            var scale = xHeight / getSXHeight();
            var avgCharWidth = font.tables.hhea.advanceWidthMax * scale; // Or use an average value


            var spacing = 20; // Adjust based on your renderCharacters function

            var width = paperSize[0] - marginHorizontal - 80; // Adjust for margins and starting xPosition

            console.log("width: " + width);
            console.log("avgCharWidth: " + avgCharWidth);


            return Math.floor(width / (avgCharWidth + spacing)) * 4;
        }



        function shadeXHeightArea(practiceBlocksGroup, y, width, xHeight, ascenderHeight, capitalHeight) {
            var xHeightRect = document.createElementNS("http://www.w3.org/2000/svg", "rect");
            xHeightRect.setAttribute("x", 0);
            xHeightRect.setAttribute("y", y + ascenderHeight + capitalHeight);
            xHeightRect.setAttribute("width", width);
            xHeightRect.setAttribute("height", xHeight);
            xHeightRect.setAttribute("fill", xHeightColor);
            xHeightRect.setAttribute("fill-opacity", xHeightOpacity);
            practiceBlocksGroup.appendChild(xHeightRect);
        }

        function fillGapBetweenBlocks(practiceBlocksGroup, descenderY, width, nibHeight) {
            var gapRect = document.createElementNS("http://www.w3.org/2000/svg", "rect");
            gapRect.setAttribute("x", 0);
            gapRect.setAttribute("y", descenderY);
            gapRect.setAttribute("width", width);
            gapRect.setAttribute("height", nibHeight);
            gapRect.setAttribute("fill", "#333");
            practiceBlocksGroup.appendChild(gapRect);
        }

        function drawGuideLines(practiceBlocksGroup, width, strokeWidth, ascenderY, capitalY, waistlineY, midlineY, baselineY, descenderY) {
            // Ascender line (dashed)
            drawLine(practiceBlocksGroup, 0, ascenderY, width, ascenderY, strokeWidth, "#000", "6,2");

            // Capital line (dashed)
            drawLine(practiceBlocksGroup, 0, capitalY, width, capitalY, strokeWidth, "#000", "4,2");

            // Waistline (solid)
            drawLine(practiceBlocksGroup, 0, waistlineY, width, waistlineY, strokeWidth, "#000");

            // Midline (dashed)
            drawLine(practiceBlocksGroup, 0, midlineY, width, midlineY, strokeWidth, "#ccc", "2,2");

            // Baseline (solid)
            drawLine(practiceBlocksGroup, 0, baselineY, width, baselineY, strokeWidth, "#000");

            // Descender line (dashed)
            drawLine(practiceBlocksGroup, 0, descenderY, width, descenderY, strokeWidth, "#000", "6,2");
        }

        function drawLine(group, x1, y1, x2, y2, strokeWidth, strokeColor, dashArray) {
            var line = document.createElementNS("http://www.w3.org/2000/svg", "line");
            line.setAttribute("x1", x1);
            line.setAttribute("y1", y1);
            line.setAttribute("x2", x2);
            line.setAttribute("y2", y2);
            line.setAttribute("stroke", strokeColor);
            line.setAttribute("stroke-width", strokeWidth);
            if (dashArray) {
                line.setAttribute("stroke-dasharray", dashArray);
            }
            group.appendChild(line);
        }

        function drawHorizontalLines(backgroundLinesGroup, width, strokeWidth, nibWidth, baselineY, ascenderY, descenderY) {
            // From baseline to ascender line
            for (var y = baselineY; y > ascenderY; y -= nibWidth) {
                drawLine(backgroundLinesGroup, 0, y, width, y, strokeWidth, "#eee");
            }

            // From baseline to descender line
            for (var y = baselineY; y < descenderY; y += nibWidth) {
                drawLine(backgroundLinesGroup, 0, y, width, y, strokeWidth, "#eee");
            }
        }

        function drawNibGuide(practiceBlocksGroup, ascenderY, waistlineY, baselineY, descenderY, nibHeight, nibWidth) {
            var nibGuideGroup = document.createElementNS("http://www.w3.org/2000/svg", "g");
            practiceBlocksGroup.appendChild(nibGuideGroup);

            var nibX = 0; // Position from left edge
            var nibRectWidth = nibWidth;

            // Ascending blocks from baseline
            var nibCount = (baselineY - ascenderY) / nibHeight; // Number of squares to draw
            for (var i = 0; i < nibCount; i++) {
                var col = i % 2; // Alternate columns
                var yPosition = Math.ceil(baselineY - (i + 1) * nibHeight);
                var rectHeight = nibHeight;
                var rectY = yPosition;

                var fillColor = "#000";

                if (yPosition < waistlineY) {
                    fillColor = "#999";
                }

                if (yPosition <= ascenderY) {
                    var diff = ascenderY - yPosition;
                    rectY = yPosition + diff;
                    rectHeight = nibHeight - diff;
                }

                drawRect(nibGuideGroup, nibX + col * nibRectWidth, rectY, nibRectWidth, rectHeight, fillColor);

                if (yPosition < waistlineY && (yPosition + nibHeight - 1) > waistlineY) {
                    var rectHeightSplit = (yPosition + nibHeight) - waistlineY;
                    drawRect(nibGuideGroup, nibX + col * nibRectWidth, waistlineY, nibRectWidth, rectHeightSplit, "#000");
                }
            }

            // Descender blocks
            nibCount = (descenderY - baselineY) / nibHeight;
            var nibYStart = baselineY;
            for (var i = 0; i < nibCount; i++) {
                var col = 1 - (i % 2); // Alternate columns
                var yPosition = nibYStart + i * nibHeight;
                var rectHeight = nibHeight;
                if ((yPosition + nibHeight) > descenderY) {
                    rectHeight = descenderY - yPosition;
                }
                drawRect(nibGuideGroup, nibX + col * nibRectWidth, yPosition, nibRectWidth, rectHeight, "#999");
            }
        }

        function drawRect(group, x, y, width, height, fillColor) {
            var rect = document.createElementNS("http://www.w3.org/2000/svg", "rect");
            rect.setAttribute("x", x);
            rect.setAttribute("y", y);
            rect.setAttribute("width", width);
            rect.setAttribute("height", height);
            rect.setAttribute("fill", fillColor);
            group.appendChild(rect);
        }

        function drawNibGuidelineLabels(practiceBlocksGroup, ascenderY, capitalY, waistlineY, baselineY, descenderY) {
            var labelX = showNibSquares ? (nibWidth * 2) + nibWidth / 2 : 2; // Depends on whether nibSquares are shown
            var fontSize = (nibWidthMm < 3) ? (9 * nibWidthMm / 3) + "px" : "9px"; // Scale when below 3mm nibWidth
            var labelColor = "#444"; // Dark gray
            var fontFamily = "Helvetica, sans-serif";

            if (ascenderMultiplier > 0) {
                // Ascender Label
                drawText(practiceBlocksGroup, labelX, ascenderY - 1 + nibWidth, fontSize, "#9c9c9c", "Ascender Line⬏ ", fontFamily);
            }

            if (capitalMultiplier > 0) {
                // Capital Label
                drawText(practiceBlocksGroup, labelX, capitalY - 2, fontSize, "#9c9c9c", "Capital Line⬎", fontFamily);
            }

            // Waistline Label
            drawText(practiceBlocksGroup, labelX, waistlineY - 2, fontSize, "#9c9c9c", "Waist Line⬎", fontFamily);


            // Baseline Label
            drawText(practiceBlocksGroup, labelX, baselineY - 2, fontSize, labelColor, "Base Line⬎", fontFamily);

            if (descenderMultiplier > 0) {
                // Descender Label
                drawText(practiceBlocksGroup, labelX, descenderY - 2, fontSize, "#9c9c9c", "Descender Line⬎", fontFamily);
            }
        }

        function drawText(group, x, y, fontSize, fillColor, textContent, fontFamily) {
            var text = document.createElementNS("http://www.w3.org/2000/svg", "text");
            text.setAttribute("x", x);
            text.setAttribute("y", y);
            text.setAttribute("fill", fillColor);
            text.setAttribute("font-size", fontSize);
            text.setAttribute("font-family", fontFamily);
            text.textContent = textContent;
            group.appendChild(text);
        }

        // Function to clip a line segment to a rectangle using the Liang-Barsky algorithm
        function clipLineToRect(x1, y1, x2, y2, xmin, ymin, xmax, ymax) {
            var dx = x2 - x1;
            var dy = y2 - y1;

            var p = [-dx, dx, -dy, dy];
            var q = [x1 - xmin, xmax - x1, y1 - ymin, ymax - y1];

            var u1 = 0;
            var u2 = 1;

            for (var i = 0; i < 4; i++) {
                if (p[i] === 0) {
                    if (q[i] < 0) {
                        return null; // Line is outside the rectangle
                    }
                } else {
                    var u = q[i] / p[i];
                    if (p[i] < 0) {
                        if (u > u2) {
                            return null; // Line is outside the rectangle
                        }
                        if (u > u1) {
                            u1 = u;
                        }
                    } else if (p[i] > 0) {
                        if (u < u1) {
                            return null; // Line is outside the rectangle
                        }
                        if (u < u2) {
                            u2 = u;
                        }
                    }
                }
            }

            if (u1 > u2) {
                return null; // Line is outside the rectangle
            }

            var clippedX1 = x1 + u1 * dx;
            var clippedY1 = y1 + u1 * dy;
            var clippedX2 = x1 + u2 * dx;
            var clippedY2 = y1 + u2 * dy;

            return { x1: clippedX1, y1: clippedY1, x2: clippedX2, y2: clippedY2 };
        }

    </script>

</body>

</html>