
BIMODAL CONTROL THEORY - REFERENCE DOCUMENT
------------------------------------------

Bimodal Control (also called Dual-Input UI Theory) describes a separation of
input tasks into two distinct modalities or input sources. 

With a guitar, the left hand is selecting the notes while the right hand 
is dedicated to the task of activating them.

In Bimodal Control, each of the two modes (selecting the note vs. activating the note) 
is typically handled by a different hand or limb.  The two hands might be
playing the keyboard while the foot controls some kind of modifying device with a pedal.

In computers, the first example given is that traditional mouse usage collapses 
both cursor steering and activation (clicking) into a single device location, 
which increases cognitive load and reduces flexibility.  Today, the keyboard keys 
are never used to click in desktop software and this is an alien concept. 
But in Dual-Input UI Theory, they are the source of all clicking while the mouse is only used
for steering the cursor.  Because there are so many keys on a keyboard, the left hand on
the keyboard immediately has access to a wide assortment of click functions and a new
dynamic emerges.  The left hand can make the cursor perform a wide range of actions
on anything it hovers, whereas before the notion of a click was vague.  The program can 
do more in real-time.


When we talk about Bimodal Control Theory, it often results in
a reassignment of what it regards as collapsed input.  It discusses most input hardware
as having been configured this way. For example, in a Bimodal Control implementation of 
VR, the right hand will only serve to position the 3D cursor while the left hand is 
dedicated to clicks (button presses on the controller).  On a tablet UI, the left hand 
controls the selection of individual functions on the left side of the screen (like the
left hand setting up notes on a guitar) while the right hand undertakes them (like the 
right hand plucking the strings).  For a keyboard synthesizer, a musician could control a 
pitch bend or modulation shift with a foot pedal while the two hands continue to 
play the keyboard.  On a tablet computer, you might have the left hand tweaking a 
real-time slider while the right hand performs real-time activity that is dependent on 
that the slider's value.


Bimodal Control divides these tasks:

1. **Steering / Navigation** - Representable By The Fret Hand on The Guitar 

	Mouse movement, VR controller positioning

   - Performed by a continuous controller such as a mouse, trackpad, or
     joystick.
   - Responsible for moving the cursor, guiding crosshairs, or positioning
     elements in XY(Z) space.

2. **Function Activation - Representable By The Plucking Hand on The Guitar 

	e.g. Key-Clicks, VR controller button presses.

   - Performed by a discrete input source such as keyboard keys or secondary
     buttons.
   - Responsible for triggering functions that were traditionally bound to
     mouse clicks.

In accordance with Bimodal Control Theory, mouse clicks are for our software
replaced by keys, but they could be replaced by one or more foot pedals while
the mouse still steers. Or the foot could control the cursor by way of a 
large trackpad under the feet while the fingers click with keys.

This division mirrors how instruments like the guitar separate left-hand
navigation from right-hand triggering. Each modality focuses on its task,
producing a smoother workflow and reducing fatigue.

---

**Key-Clicks**

For Bimodal Control Theory, in practice, mouse-button clicks are typically
replaced by designated keyboard keys. For example, the **F** key deposits
points when drawing vectors, while other keys complete shapes, drag selections,
or adjust stroke width. This approach frees the steering device from having to
carry both tasks, allowing the user to maintain cursor guidance continuously
while activating functions with the other hand.  

---

The central feature of Bimodal Control when applied to desktop software is that
"clicks" and function triggers are reassigned to the keyboard. Below are three
examples that illustrate how keys are used in different application contexts.


Applications
------------

We have made demos that put key-clicks into practice.

**Consistent Key Usage Across Applications**

Across all of the demos and applications, certain keys are used in consistent
ways for predictability and to reflect tested implementations.  Preparing where
to assign the key clicks in an ergonomic way helps the user transfer habits between 
different domains (vector graphics, patch synths, timeline editors, or 
tablet-gesture equivalents).  A software developer should make deliberate choices
for various selections of the keys based on the form of a keyboard and the
type and needs of the project. 

We pay attention to the location of the keys, how big they are, and how they
can be used in the middle of live interaction.  The key-clicks elevate computer
user interaction to a real-time mode, so for something as frequent as dragging,
we often use the Spacebar for a drag lock (described below) so that objects
are picked up and dropped rapidly with the thumb.  Similarly large and easy
to hit repetitively is the Tab key, so we use that for selection clicks and
activation clicks (e.g. conventional clicks like pressing a button).
  
We use Escape, for example, to cancel any mode that was activated by a key and this 
includes clearing a selection objects.  The Escape key is easy to hit on the keyboard 
along with Tab and Spacebar.  The F key is easy to hit as well, so we sometimes
use it for conventional clicking (activation click).

We always take note of the application's needs and circumstances. 
For non-linear editor (NLE) timelines in editor applications for example, 
the Spacebar is commonly used activate the play/pause button, so for these programs 
the use of Spacebar for drag lock can be substituted with the prime key (or tilde) 
or another key on the keyboard.  

In apps that benefit from a lot of functionality, they can store the key-clicks
for the keyboard as key-click layouts and swap them out.  Modifier keys can enhance
existing key-clicks, such as scale and rotate increment/decrement buttons, that
can have their amounts increased or decreased with Shift and Alt respectively.


- **Tab or or F (Selection Clicks And Activation Clicks) **  
  The Tab key is a control that we often can use consistently across an
  interface.  Tab is generally used to toggle selection of objects on a workspace,
  like nodes or vector-objects and is assigned the equivalent of Shift-Click. 
  If nothing is selected, Tab acts as a "selection click" or "activation click" 
  on the object beneath the cursor.  The Tab key is often used for selection 
  because it is easy to hit.

  - On objects: Tab selects or toggles inclusion in the current selection set.  
  - On buttons: Tab activates the button at the cursor‚Äôs location, acting as a
    direct substitute for a mouse click.  
  - On sliders and controls: Tab moves the slider handle directly to the cursor
    position, enabling precise placement without dragging.  

  Because Tab is large and easy to reach, it becomes a reliable, global
  mechanism for activation and selection throughout the interface, though it doesn't
  always have to be used and can be substituted by F.  F is where the index finger
  is located and it is OK to use D as well because it is easier for the middle finger
  to do repetitive clicks.
  
  It embodies the principle of separating steering (cursor placement) from activation
  (keyboard trigger), ensuring the same action pattern applies everywhere in
  the UI.  

  

- **Spacebar (Drag Lock / Position Lock)**  
  Spacebar is often used to activate a drag-lock state. If there is no active selection, this
  applies to the object currently under the cursor. If there is a selection,
  drag-lock constrains movement of the selected set. While in drag-lock mode,
  the mouse or continuous controller steers the motion of the object(s) until
  the lock is released. The Tab key is used for selection because it is easy to hit.

  The Spacebar is used to enable a drag-lock mode, which fixes an object,
  selection, or control to the cursor position until released. Its role is to
  simplify continuous repositioning without requiring the user to hold down a
  mouse button.  

  - On objects: Spacebar locks the selected object(s) to the cursor, allowing
    smooth repositioning across the canvas.  
  - On single objects when there is no selection: The Spacebar will select the
  object underneath the cursor and activate the drag lock.  
  Spacebar locks the object directly under the cursor into a
    drag operation, even without a prior selection.  When the object is
  repositioned after the drag lock is turned off, the selection of the object
  is turned off because turning it off fits into the interaction scheme 
  for this operation and situation.
  
  - On sliders: Spacebar locks the slider knob (or a point on a 2D slider) to
    the cursor, enabling controlled dragging of values along a single dimension
    or across two dimensions.  

  Because the Spacebar is large, central, and easy to strike, it functions as a
  reliable universal control for engaging drag-lock operations. It pairs
  naturally with Tab, reinforcing the consistent separation between cursor
  steering and keyboard activation across the entire interface.  
  
  There is an exception which is that for video editors, the Spacebar is
  commonly used to play/pause, so it can be substituted with the prime key
  (or tilde).  


- **Esc (Cancel / Clear Selection)**  
  The Escape key universally cancels the current mode or operation. This
  includes aborting drag-lock, breaking out of connection or duplication modes,
  and clearing any active selection of objects. Its large key size and
  placement at the top-left corner of the keyboard make it quick to locate and
  reliable to strike in high-frequency workflows.
  
- **F (Point Function)**  
  In vector-drawing contexts, the F key deposits a point along the current
  path. Its position on the home row makes it an ergonomically efficient key,
  easy to reach without shifting hand position. By extension, it is well-suited
  for repetitive actions such as laying down points in drawing or initiating
  connections in patch-based systems.

- **G (Drag Line Relocation)**  
  Pressing G initiates a drag-line operation. Instead of immediately locking an
  object to the cursor like the drag lock, the system displays a dashed line that 
  stretches from the object‚Äôs center point to the cursor location. This line
  serves as a preview, allowing the user to see the prospective relocation path
  before committing.  An outline or a dashed frame of the object being dragged
  does follow the cursor, but the actual object stays in place.
  - The user can confirm by clicking another key or releasing G, which then
    moves the object to the indicated location.  
  - This method is especially valuable when repositioning patches, nodes, or
    visual elements in dense layouts, since the dashed line provides spatial
    context without disturbing existing alignments.  
  - In timeline editors, a similar principle applies when dragging clips to
    new positions: the drag line shows the intended offset before confirming.  

- **M (Copy Line Relocation)**  
  This operation demonstrates how the same convention within key-clicks can
  support multiple related functions. It mirrors the behavior of **G (Drag
  Line Relocation)**, except instead of moving the object, it clones it along
  the relocation path. The dashed guide line appears from the original object
  to the cursor, and upon confirmation, a duplicate is placed at the new
  location. This provides a consistent visual and operational language for both
  moving and copying objects, differentiated only by the chosen key.

- **Y (Live Selection Rectangle)**  
  Activates a dynamic rectangular selection tool. The first press of **Y**
  begins the rectangle, anchored at the cursor location. As the cursor is
  moved, the rectangle continuously updates, and the selection changes
  in real time based on intersections with objects (similar to the
  desktop-icon selection method on a PC). A second press of **Y**
  finalizes the selection. This two-step mechanism provides the benefits of
  direct manipulation while remaining consistent with the key-click activation
  model.

- **T (Tidy Rectangle Alignment)**  
  If the software application involves objects that should be ordered,
  this key works as a structural counterpart to **Y (Live Selection
  Rectangle)** just like a Copy Line relates to a Drag Line. 
  While **Y** is used to create and adjust a dynamic selection
  area, **T** acts on that selection by arranging the chosen objects into a
  neat horizontal or vertical stack, though its specifics are up to the
  software developer. This reduces clutter and establishes
  orderly spacing without requiring manual repositioning. In this way, **Y**
  and **T** form a natural pair: one defines the scope of selection, the
  other organizes it.


- **[ and ] (Scale Down / Scale Up)**  
  The bracket keys provide unit-based scaling for the currently selected object
  or group. By default, pressing `[` decreases the size by one unit, and `]`
  increases it by one unit.   In interface contexts, they also operate directly on number fields:
  when the cursor hovers over a numeric input, pressing `[` or `]` decrements or
  increments the value instantly.  

  This approach is faster than moving to the field, clicking, and typing a
  number. It preserves the principle of bimodal interaction: the steering hand
  positions the cursor over the field, while the trigger hand adjusts the value
  discretely.  

  - **Shift + [ / ]**: Applies a larger increment or decrement (coarse scaling),
    allowing rapid resizing.  
  - **Alt + [ / ]**: Applies a smaller increment or decrement (fine scaling),
    useful for precise adjustments.  

- **; and ' (Rotate Counterclockwise / Clockwise)**  
  The semicolon and quote keys rotate the current selection in fixed increments.
  By default, `;` rotates counterclockwise, and `'` rotates clockwise, each in
  a standard step (e.g., 15¬∞).  

  - **Shift + ; / '**: Increases the rotation increment (e.g., 45¬∞ or larger),
    enabling fast orientation changes.  
  - **Alt + ; / '**: Decreases the rotation increment (e.g., 5¬∞ or smaller),
    allowing subtle fine-tuning of alignment.  

- **- and = (Decrement / Increment Properties)**  
  The minus and equals keys are used for adjusting continuous properties in
  unit steps. A common example is stroke width in a vector-drawing demo:
  pressing `-` thins the stroke by one unit, while pressing `=` thickens it by
  one unit.  

  - **Shift + - / =**: Applies larger step adjustments (coarse changes), useful
    for quickly setting broad visual weights.  
  - **Alt + - / =**: Applies smaller step adjustments (fine changes), allowing
    precise refinement of stroke or property values.  

- **Number Pad (Grid and Extended Functions)**  
  When present, the number pad becomes a powerful extension of the bimodal
  interface. Its physical layout lends itself to spatial mappings and quick
  function access.  This isn't something to include unless specified for
  actual desktop computers because of the rarity of full number pads on laptops.

  - **3√ó3 Grid Selection**: The nine keys (1‚Äì9) naturally map to a 3√ó3 grid of
    cells. Pressing a key selects the corresponding cell, enabling fast
    exclusive selection across a visual matrix. This is useful for patch grids,
    tool palettes, or camera views.  
  - **Extended Functions**: The number pad can serve as a secondary bank of
    discrete function triggers, separate from the main alphanumeric keys.  
    Common uses include:  
      ‚Ä¢ Assigning numeric increments to values.  
      ‚Ä¢ Switching between modes or tools.  
      ‚Ä¢ Providing shortcuts to frequently used operations.  
  - **Ergonomic Advantage**: Because the number pad is spatially distinct, it
    avoids interference with the primary steering/activation hand motions and
    can host specialized, high-frequency actions without crowding the main
    keyboard.  

  In this way, the number pad operates both as a selection grid and a flexible
  command surface, expanding the reach of key-click based control while
  preserving the separation of steering and activation.  


**Assignments in Various Demos**

1. **Vector Drawing Demo (Key-Clicks for Shape Creation)**

   In this demo, the mouse steers the cursor while the keys take over all
   activation functions that would traditionally require mouse button clicks.

   - Mouse handles cursor movement.
   - Keys handle creation, completion, selection, and editing of shapes.
   - F ‚Üí Deposit a point along a path.
   - A ‚Üí End the path with a stroke (open polyline).
   - E ‚Üí End the path and fill the shape (closed, filled polygon).
   - R ‚Üí End the path with a stroked outline.
   - S ‚Üí End the path with both fill and stroke applied.
   - Tab ‚Üí Select existing objects.  This key replaces mouse-click or Shift + mouse-click.
   - Spacebar ‚Üí Toggle drag-lock for moving selections.  
   		(The object "sticks" to the cursor until the drag lock is ended by a second
   		tap of the spacebar.  If there is a selection, it turns on the drag lock
   		for the whole group.)
   - W ‚Üí Stamp a duplicate of the current selection while dragging.
   - [ and ] ‚Üí Scale selected object(s) down and up.
   - ; and ' ‚Üí Rotate selection by increments (default 15¬∞, with modifiers).
   - C and V ‚Üí Adjust stroke thickness thinner or thicker.
   - Esc ‚Üí Cancel selection or current dragging operation.

2. **Patch/Node Synth Demo (Key-Clicks for Node Manipulation)**

   Nodes ("patches") are selected, dragged, connected, and manipulated using
   key commands instead of mouse clicks.

   - Tab ‚Üí Select patches, or toggle pad squares within a patch.
   - Spacebar ‚Üí Drag-lock mode to reposition one or more selected patches.
   - G ‚Üí Drag-line relocate; moves a patch to cursor location using a guide.
   - F ‚Üí Connect or disconnect ports between patches (cable start/finish). Hangs the
   	cable on the cursor until F is pressed again when the cursor is over another port.
   - S ‚Üí Swap cable connections by detaching and reattaching to a port.
   - D ‚Üí Delete a cable connection.
   - T ‚Üí Tidy rectangle; align patches horizontally or vertically.
   - Y ‚Üí Live selection rectangle; updates selection as cursor moves.  This is the
   same as the selection rectangle used during selection of desktop icons on a PC,
   just converted into two steps: the first press of Y begins the rectangle, when the 
   mouse is moved the rectangle is adjusted and the selection changes based on intersection
   with desktop icons, and when the Y key is pressed again
   the rectangle is finalized and the selection made.  In this case it applies to patches
   instead of icons.
   
   - W ‚Üí Toggle disabled state for a patch or cable.
   - E ‚Üí Collapse/expand patch contents (header only vs. full view).
   - [ and ] ‚Üí Scale selected patches smaller or larger.
   - ; and ' ‚Üí Rotate selected patches clockwise/counterclockwise.
   - M ‚Üí Clone patches (guide line or stamping).
   - Esc ‚Üí Cancel active operations.

   This demo demonstrates how patch-based workflows can be fully navigated
   and manipulated using key commands instead of mouse clicks.

3. **NLE Timeline Editor (Key-Clicks for Editing Operations)**

   - K ‚Üí Split a clip at the current playhead location (razor/slice).
   - J ‚Üí Join two adjacent clips into a single continuous clip.
   - L ‚Üí Ripple delete (remove a clip and close the gap).
   - I ‚Üí Mark in point at playhead.
   - O ‚Üí Mark out point at playhead.
   - Tab ‚Üí Select the clip on the timeline.
   - Spacebar ‚Üí Toggle drag-lock for repositioning selected clip(s).
   - [ and ] ‚Üí Nudge selected clip earlier or later on the timeline.
   - ; and ' ‚Üí Rotate trim handles (for rolling edits, adjusting cut points).
   - W ‚Üí Duplicate/clone the selected clip at playhead position.
   - Esc ‚Üí Cancel any active trim, selection, or dragging operation.

   Here, the mouse continues to handle steering (e.g., scrubbing or navigating
   the timeline view), while the keyboard performs precise editing actions.
   This allows the editor to maintain continuous navigation with one hand and
   rapid editing triggers with the other.

## Variable State Modes

In some applications, particularly vector-drawing programs, certain modes
require multiple sequential states rather than a single on/off toggle. The
number of states depends on the operation being performed. For example,
activating a drag lock typically involves two steps: the first press of the
Spacebar establishes the lock, and a second press releases it.

By contrast, more complex operations can require a larger state cycle. Suppose
a user has selected a vector graphics object and wishes to map it into a
quadrilateral region. This operation requires four corner points to be defined
in sequence. Each key-press (e.g., **F**) establishes one corner of the
quadrilateral. The mode only completes after all four states have been reached
and the object is transformed accordingly. Pressing **Escape** at any time
cancels the unfinished sequence.

This design allows consistency with bimodal principles‚Äîsteering is continuous,
while key-clicks incrementally advance through a structured multi-state
process. Users quickly learn the rhythm of two-step, four-step, or
variable-length operations, and the interface maintains predictability by
always signaling which stage of the sequence is active.


KeyPilot Chrome Extension
------------------------------------

**Keyboard-first navigation for the web with instant visual feedback**

KeyPilot transforms your browsing experience by providing keyboard shortcuts for common web interactions, eliminating the 
need for mouse navigation.


## ‚ú® Key Features

### ‚å®Ô∏è Keyboard Navigation
- **F key**: Activate links and controls under cursor
- **S key**: Browser back navigation  
- **V key**: Browser forward navigation
- **D key**: Toggle delete mode / Delete elements
- **ESC key**: Cancel current mode / Exit text focus
- **/ key**: Close current tab

### üéõÔ∏è Global Controls
- **Alt+K**: Toggle entire extension on/off globally
- **Extension Popup**: Mouse-based toggle controls

There are two main modes in play unless the user
activates a separate one, the delete mode.

The two main activities a user engages in while using
a web browser is either clicking on links
or entering and editing text in a text field.

The extension has its own criteria of what is
clickable under the mouse.  On hover, 
clickable link objects are outlined with a green rectangle. 
Clickable text fields (inputs with text, textarea, etc.)
are given an orange outline.

There is one main mode monitored, which is text mode (text entry).
That is when keys will enter text into a text field and
the only key that KeyPilot monitors is the ESC key, which
will move the mode back to hovering over page elements.
A text mode is activated either because the page focused on a text field,
usually on load, or the user clicked a text field (with regular mouse button
clicks or the F key in KeyPilot).  This triggers a 
semi-transparent overlay frame around the page frame as an internal
border of the web page and then the orange outlines
stays in place on the text field. 

The D key activates a selection hovering mode where
the outlines is red and the second press of D deletes
that page element.  The ESC key escapes the delete mode.

Selection Rectangle

The H key activates a selection rectangle and its default mode is text.
The rectangle works like desktop file selection you 
can start from any point and drag in any direction (up, down, left,
right, or diagonally) and the rectangle will be drawn  from your starting
point to your current cursor position.   The first point
establishes that the mode has begun.  Moving the cursor adjusts
the rectangle.  A second press ends the selection rectangle.
There are three configurable parameters programmatically.
	- What data types are being selected (e.g. text).
		- What schemes there are for selecting the data
			- Should text be selected by 
				- the HTML element criteria (elements containing text),
				- paragraphs only.
				- sentences only.
				- etc.
				
	- Whether the selection is live (updates on rectangle resizing)
		- The selection occurs at the end or is updated live.
		
The / key closes a tab.  Q and W go across tabs, going left and right.

Key Mappings Configuration Page
Keys functions can be changed on a key mapping settings page.


Popover Keys
	
Available keys include I for selecting a an element or text underneath the cursor
and showing a popover for it.
	- The popover is a general structure for anything.
	- It can serve as a preview of the link clicked with I in an iframe
	- The popover can be of any size, including taking up most of the viewport.
	- It might be used to click on a word and get a dictionary definition.




The Key-Click UI Adapted to a Desktop OS GUI
------------------------------------

To make the Key-Click UI compatible with a desktop OS of today,
a desktop OS would have a meta-keyboard mode that is
entered and exited through some sequence of keys, such as pressing
Esc three times in a row.  This would be entering and exiting
the Key-Click UI meta-keyboard mode. 

Adapting the key-click UI to a desktop OS
would follow the same GUI adapter pattern as KeyPilot, a Chrome extension
that clicks on websites but also allows entering text fields. It seems
like the issue would be, just like KeyPilot, the transition and indicators
of switching between clicking and dragging objects and the editing of text
fields, as usually there are only these two activities.  For right-handed
users, double-click would be the D key, the right-click would be moved to the S 
key while the left click is moved to the F key, middle-click E.  For left-handed, the right click would be moved
to L while the double-click is assigned to K, middle-click I.  
Using Tab as a window selection key would be for right-handed users while 
the backslash key would likely be for left-handed.  In KeyPilot, 
the Backquote key is used for navigating
to the site root and this would be the equals key for left-handed
users.

Windows would be manipulated by clicking them with the Activation/Select
Key (Tab usually) and the space bar would activate the drag lock to
drag them around.  The F key would be clicking inside apps.

The drag-line will be applied to windows.  Any window or tab
that is hovered will be closed with the / (forward slash) key.

Opening a document in the File Navigator can have more than one
key, one for View and another for Edit.  


Keys in Bimodal Control Applications
------------------------------------

Across these applications, the same guiding principle applies: **one hand
steers, the other hand triggers.** (But we also point out that in the Bimodal
Control theory it isn't always about the hands.)  The specific key map adapts to the software
domain, but the division of labor is constant, yielding smoother workflows,
faster command execution, and reduced repetitive strain.



Use in Combination with Dial Knobs
------------------------------------

Instead of a keyboard key replacing
the mouse click when the mouse is
hovered over an element, use
a dial knob like the ones that protrude
from the side of devices.  This will allow
for operations like rotation and scale
on objects immediately underneath the mouse pointer.
it will also allow controlling values inside
text fields.




Application to Tablet Interfaces
--------------------------------

The principles of Key-clicks and Bimodal interfaces extend naturally into
tablet-based touch systems, where physical keys are absent but gesture and
touch-event pairs can fulfill a similar role. Instead of discrete keystrokes,
the fundamental unit of interaction is a tap, drag, or compound gesture applied
at a location in the workspace. These interactions, like keystrokes, can be
mapped into symmetric pairs (e.g., Insert/Delete, Select/Deselect, Scale
Up/Scale Down, Rotate CW/Rotate CCW, Copy/Paste) to maintain the bimodal
balance that ensures expressiveness while limiting interface complexity.

In practice, the user may touch an object to select it, then use a follow-up
gesture to scale, rotate, or transform it, with undoable actions preserving
state continuity. These are operationally parallel to keyboard-driven commands
in desktop applications: the touch replaces the physical key, but the functional
design pattern remains identical.

This framework supports more advanced roles on tablets as well. For example:

- **Drawing and Design**: Tapping to select or deselect objects, dragging to
  move, and pinching to scale provides the same reversible structure as
  keyboard shortcuts.
- **Document Editing**: Copy/Paste, Insert/Delete, and Cut/Join are expressible
  through touches with visual feedback animations.
- **Timeline and Media Control**: A tap-split gesture at a playhead, or
  swipe-join between clips, directly mirrors the ‚ÄúK to split, J to join‚Äù
  keyboard operations in non-linear editors.

By unifying these approaches, Key-clicks and Bimodal become not just a desktop
metaphor but a generalizable interaction pattern for both keyboard-based and
touch-based environments. Tablets thus benefit from the same balanced operator
set, enhancing predictability, symmetry, and ease of learning across platforms.


Video Game Controllers
-----------

Video game controllers should be seen as activating
functions.  One button activates the function for
jump.  Another activates the function for whatever
action the the onscreen character can perform.
The arrows on the arrow pads are each functions
for something.  In this way, the conventional video game
controller is a pad of activators for functions or
procedures.  There are sometimes combinations of
them and sequences assigned to additional functions.

A Bimodal Control example input device for video games
would be a long slider, possibly 5 inches wide, oriented
horizontal to the video game player and installed in a 
stable way to a table.  The video game mechanic using this would involve one
hand sliding the slider knob back and forth.  The left hand
would have from 2-4 large buttons or pads located to the left of the slider
to press while the right hand moves the knob back and forth.







Conclusion
----------

- Reassigning "clicks" to the keyboard demonstrates how dual-input UI theory
  can upgrade conventional interfaces.
- It reduces the tedium of mouse-only workflows in vector drawing, node-based
  programming, and similar GUI contexts.
- Bimodal Control highlights a generalizable design principle: **the
  alternation of input activity between two separate physical locations**,
  leading to a new vista for user interfaces.
  
  
  

  
