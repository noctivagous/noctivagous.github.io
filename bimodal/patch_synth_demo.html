<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Keyboard-Driven Node UI</title>


<!--
Project: Patch-Based Synth Demo — Keyboard-First Node UI (Updated)

Purpose
- Demonstrates a keyboard-driven patch/node interface where HTML “patch” panels are linked by Paper.js “cables.”
- Replaces common mouse gestures with explicit key commands for selection, movement, cabling, alignment, test toggles, and layout compaction.
- Serves as a reference scaffold for adapting keyboard-centric interaction patterns to other applications.

Architecture Overview
- DOM
  • #patchArea — absolute-positioned container for all .patch nodes and the cables canvas.  
  • .patch — node with <header> plus content; may include .port elements (data-dir="in" | "out").  
    – Special types:  
      ▸ .patch.numeric — numeric textfield (“type-on-hover”).  
      ▸ .patch.slider-numeric — slider + numeric textfield combo.  
      ▸ .patch.cv-receiver — displays values received via cable.  
  • #cablesCanvas — Paper.js canvas (overlays patches) for cubic Bézier cables.  
  • #instructions — dark sidebar with custom, always-visible JS scrollbar.
- Paper.js
  • One PaperScope bound to #cablesCanvas.  
  • Each connection stored in `connections: { from, to, path, disabled? }`.  
  • Hit-testing highlights hovered cables; styles are centralized via `styleCable()`.

Core Data/State
- Selection: `.patch.selected` (multi-select). `clearSelection()` removes it.  
- Drag-lock (patches): `dragLock`, `dragStart`, `initialPos` Map<patch,{left,top}>.  
- Slider drag-lock: `sliderDragLock`, `sliderDragEl`, `sliderDragStart`, window-level mousemove during session, and a live bracket path from knob→cursor.  
- Cable editing: `connecting`, `connectStart`, `previewPath`, `hoverCable`, `reattachCable` + `reattachEnd`.  
- Drag-line relocate (G): `dragLineActive`, `dragLinePatch`, `dragLinePath`.

Geometry Helpers
- `centerOf(el)` — element center in page coords.  
- `portAnchorPoint(portEl)` — if the owning patch is collapsed, anchors to the header’s vertical midline (left for inputs, right for outputs); otherwise uses the port center.  
- `refreshPath(path, p1, p2)` and `redrawCables()` — keep Bézier paths in sync as patches move/collapse.

Keyboard Map (document keydown)
- Tab — toggle selection of patch under cursor; Tab in empty space clears selection.  
  • Suppressed while any drag-lock is active (patch or slider).  
- Space — drag-lock toggle.  
  • Over a slider: locks the knob to horizontal mouse movement (no click), draws a bracket guide to the cursor; Space/Esc releases.  
  • Over patches: locks the entire selection; if none selected, auto-selects the patch under cursor for a single-item drag, then deselects on release.  
- F — connect/disconnect ports (F to start on a port, F again on a compatible port to finish; Esc cancels).  
- S — detach nearest end of hovered cable, then re-attach on another port with S.  
- D — delete hovered cable.  
- G — drag-line relocate: first G starts a dashed line from patch center; second G animates the patch to the cursor, redrawing cables every frame.  
- T — Tidy Rectangle (two-press): uses a dashed diagonal + transparent rectangle as a selector.  
  • Wide rectangle → horizontal alignment (same y); tall → vertical (same x).  
  • Prevents overlap by spacing with a configurable margin.  
- Y — Live Selection Rectangle (two-press): same visuals as T; selection updates live as patches enter/exit the rectangle.  
- W — Toggle disabled state for the targeted item.  
  • Cable: dashed, light gray; visual only unless additional logic is added.  
  • Patch: dimmed, dashed border; ports grayed; selection outline suppressed.  
- E — Collapse/Expand patches.  
  • Selection present: all-expanded → collapse all; all-collapsed → expand all; mixed → majority decides.  
  • Collapse hides everything except the header; cables re-anchor to the header midline via `portAnchorPoint()`.  
- Esc — cancels active modes (connect preview, re-patch, drag-line, tidy/live rectangles, slider drag-lock) and restores cursors/overlays.

Numeric Textfield & Slider Combo
- “Type-on-hover”: hovering `.num-value` and typing digits/“.”/“-” begins inline edit (`.editing`).  
  • Enter commits (clamp to [min,max], quantize to data-step, apply data-precision).  
  • Escape reverts; leaving the value commits with validation.  
- Brackets on hover or while editing:  
  • `[` decrement / `]` increment; Shift = big step; Alt/Option (Meta on macOS) = small step.  
  • Uses `e.code` ('BracketLeft'/'BracketRight') for layout-independent detection.  
- Slider visuals: block track with full-height rectangular thumb (WebKit/Firefox).  
- Min/Max labels: injected `.num-range` row inside numeric patches from `data-min` / `data-max`.  
- Sources/Receivers: numeric and slider patches expose `cv` outputs; cv-receiver patches display values when connected.

Initialization
- PaperScope is created and bound to `#cablesCanvas`.  
- Auto-connections on load (examples): Oscillator→Filter (audio), Pitch Number→Pitch Receiver (cv), Level Slider→Level Receiver (cv).  
- Instructions sidebar installs a custom scrollbar and keeps its thumb synced.

Reliability & UX Notes
- Window-level mousemove is used during slider drag-lock to ensure responsive updates outside `#patchArea`.  
- Cable styles (normal/hover/disabled) are applied centrally; `redrawCables()` reapplies styling after geometry updates.  
- Tab selection is blocked during any drag-lock to avoid state conflicts.  
- All preview overlays and session listeners are removed on completion or Esc.

Extensibility
- New patch types can be added by composing HTML within `.patch` and providing ports; all routing is port-based.  
- To make “disabled” affect logic (not only visuals), gate your processing on `conn.disabled` and/or `.patch.disabled`.  
- Keep this comment synchronized when features or key bindings change; update the #instructions HTML accordingly.
-->


  <!-- Paper.js for cable overlay -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/paper.js/0.12.17/paper-full.min.js"></script>
  <style>
    html,body{height:100%;margin:0;overflow:hidden;font-family:"Arial",sans-serif;background:#f4f6fa;}
    #patchArea{position:relative;width:100%;height:100%;}

    /* —— Patch block —— */
    .patch{position:absolute;z-index:10;width:170px;background:#fff;border:2px solid #0d6efd;border-radius:6px;
    
    box-shadow: 3pt 3pt 3pt gray;cursor:pointer;user-select:none;}
    .patch header{background:#0d6efd;color:#fff;font-size:0.9rem;padding:4px 8px;border-radius:4px 4px 0 0;}

    /* —— Ports —— */
    .port{width:14px;height:14px;border:2px solid #333;border-radius:50%;display:inline-block;margin:6px;vertical-align:middle;pointer-events:auto;}
    .port.input{background:#ffd7d7;border-color:#c0392b;}
    .port.output{background:#d7ffd9;border-color:#27ae60;float:right;}
    .port.hover{outline:3px solid #f1c40f;}

    /* —— Selection & drag-lock state —— */
    .selected{outline:4pt solid #dc3545 !important;}
    .dragging{opacity:0.7;}

    /* —— Cable canvas overlays patches —— */
    #cablesCanvas{position:absolute;inset:0;z-index:20;pointer-events:none;}
    
    #cablesCanvas {
    display: block; /* Removes any extra space below the canvas */
    width: 100vw;   /* Sets width to 100% of viewport width */
    height: 100vh;  /* Sets height to 100% of viewport height */
}

  </style>
  
  <style>
  /* Light dotted grid for the patch area */
  #patchArea{
    background-image: radial-gradient(circle, rgba(0,0,0,0.15) 1px, transparent 1px);
    background-size: 18px 18px;      /* grid pitch */
  }
  /* Slightly larger pitch on Hi-DPI screens */
  @media (min-resolution: 2dppx){
    #patchArea{ background-size: 24px 24px; }
  }

  /* ─────────── 2. CSS for the instruction bar ─────────── */
 #instructionsBar{
    position:fixed;           /* was: fixed */
    top:0; z-index:40;
    width:100%;
    background:rgba(255,255,255,0.95);
    border-bottom:1px solid #0d6efd;
    padding:6px 12px;
    font-size:1rem;
    font-family:Tahoma;
    line-height:1.5rem;
    pointer-events:none;
    box-shadow:0 2px 4px rgba(0,0,0,.1);
  background:black;
  }
  
  @media (min-width: 800px){      /* applies when width > 650 px */
  #instructionsBar{
    font-size: 1rem;            /* raise from 0.85 rem (≈ 14 px) to 1 rem (≈ 16 px) */
        font-size:1.2rem;
    line-height:1.8rem;
  }
}
  
kbd{
border:1pt solid silver;
border-radius:3pt;
padding:1pt;
text-align:Center;
padding-left:3pt;
padding-right:3pt;
margin-right:3pt;
background:gray;
color:#444;
}

</style>
<style>
  /* Cursor styles for different interaction states */
  #patchArea               { cursor: default;    }
  #patchArea.connecting    { cursor: crosshair;  }
  #patchArea.over-port     { cursor: pointer;    }
  #patchArea.hover-cable   { cursor: pointer;    }
  #patchArea.invalid-connect{cursor: not-allowed;}
  
  
</style>

<style>
#instructions {
  position: absolute;
  top: 10px;
  left: 10px;
  width: 500px;
  bottom:10pt;

  background: rgba(28, 28, 30, 0.95); /* dark semi-opaque */
  border: 1px solid #444;
  border-radius: 6px;
  padding: 12px 16px;
  font-family: sans-serif;
  font-size: 14pt;
  color: #e0e0e0;
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.7);
  z-index: 999;
}

#instructions h3 {
  margin-top: 0;
  font-size: 16px;
  color: #66b0ff;
  border-bottom: 1px solid #555;
  padding-bottom: 4px;
}

#instructions ul {
  padding-left: 20px;
  margin: 6px 0 12px 0;
}

#instructions li {
  margin-bottom: 4px;
  line-height: 1.5;
  color:gray;
  font-family:arial;
}

#instructions kbd {
  display: inline-block;
  background: #333;
  border: 1px solid #666;
  border-radius: 4px;
  padding: 2px 6px;
  font-size: 13px;
  font-family: monospace;
  color: #f0f0f0;
  box-shadow: inset 0 -1px 0 #000;
}

#instructions p {
  margin: 8px 0 4px 0;
  font-weight: bold;
  color: #dddddd;
}

#instructions {
  position: absolute;
  top: 10px;
  left: 10px;
  width: 450px;
	bottom:10pt;
  background: rgba(28, 28, 30, 0.95);
  border: 1px solid #444;
  border-radius: 6px;
  padding: 12px 16px 12px 12px;
    font-size:1.2rem;
    font-family:Tahoma;
    line-height:1.5rem;
  color: #e0e0e0;
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.7);
  z-index: 999;
  overflow: hidden;
}

#instructions .scroll-content {
  height: 100%;
  overflow-y: scroll;
  padding-right: 16px; /* space for fake scrollbar */
  scrollbar-width: none;     /* Firefox */
  -ms-overflow-style: none;  /* IE 10+ */
}
#instructions .scroll-content::-webkit-scrollbar {
  display: none; /* Chrome/Safari */
}

.scrollbar-track {
  position: absolute;
  top: 12px;
  right: 4px;
  width: 6px;
  height: calc(100% - 24px);
  background: #222;
  border-radius: 3px;
}

.scrollbar-thumb {
  width: 100%;
  background: #555;
  border-radius: 3px;
  position: absolute;
  top: 0;
  height: 40px;
  cursor: pointer;
}


</style>

<style>
  /* Numeric patches */
  .patch.numeric, .patch.slider-numeric { width: 220px; }

  .num-body {
    display: grid;
    grid-template-columns: 1fr auto;
    align-items: center;
    gap: 8px;
    padding: 10px;
  }

  .num-label { font-size: 0.9rem; color: #666; }

  .num-value {
    font-family: "Courier New", monospace;
    font-size: 28px;
    padding: 4px 8px;
    border: 2px solid #66b0ff;
    border-radius: 6px;
    cursor: text;
    user-select: none;
    min-width: 72px;
    text-align: right;
  }
  .num-value.hover   { border-color: #66b0ff; background: rgba(102,176,255,0.08); }
  .num-value.editing { border-color: #ffc107; background: rgba(255,193,7,0.10); }

  /* Block slider with rectangular, full-height thumb */
  .num-slider {
    -webkit-appearance: none;
    appearance: none;
    width: 100%;
    height: 32px;                /* block track height */
    background: transparent;     /* track drawn via vendor pseudo-elements */
    margin: 6px 0;
  }
  /* WebKit */
  .num-slider::-webkit-slider-runnable-track {
    height: 32px;
    background: #e9ecef;
    border: 2px solid #0d6efd;
    border-radius: 6px;
  }
  .num-slider::-webkit-slider-thumb {
    -webkit-appearance: none;
    width: 16px;
    height: 32px;                /* full height to be rectangular */
    background: #0d6efd;
    border: 0;
    border-radius: 4px;
    margin-top: 0;
    cursor: pointer;
  }
  /* Firefox */
  .num-slider::-moz-range-track {
    height: 32px;
    background: #e9ecef;
    border: 2px solid #0d6efd;
    border-radius: 6px;
  }
  .num-slider::-moz-range-thumb {
    width: 16px;
    height: 32px;
    background: #0d6efd;
    border: 0;
    border-radius: 4px;
    cursor: pointer;
  }
  .num-slider:focus { outline: none; box-shadow: 0 0 0 2px rgba(13,110,253,0.25); }
  
  .instructions-description{
  color:#a0a0a0;
  font-family:courier;
  }
  
  /* Optional: highlight slider while drag-locked via Space */
.num-slider.dragging {
  outline: 2px solid #ffc107;
  outline-offset: 2px;
}

/* Inline min/max labels row inside numeric patches */
.num-range {
  grid-column: 1 / -1;           /* span full width of the grid */
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-top: 4px;
  font-size: 12px;
  color: #6c757d;                /* muted */
  font-variant-numeric: tabular-nums;
}
.num-min, .num-max { opacity: 0.9; }

/* Receiver patches reuse numeric look */
.patch.cv-receiver { width: 220px; }

.recv-body {
  display: grid;
  grid-template-columns: 1fr auto;
  align-items: center;
  gap: 8px;
  padding: 10px;
}

.recv-label { font-size: 0.9rem; color: #666; }

.recv-value {
  font-family: "Courier New", monospace;
  font-size: 24px;
  padding: 4px 8px;
  border: 2px solid transparent;
  border-radius: 6px;
  min-width: 72px;
  text-align: right;
  color: #222;
  background: rgba(0,0,0,0.03);
}

/* Disabled patch: dimmed, dashed border; ports grayed */
.patch.disabled {
  opacity: 0.55;
  filter: grayscale(40%);
  border-color: #bbb !important;
  border-style: dashed;
}
.patch.disabled header {
  background: #6c757d !important;
}
.patch.disabled .port {
  border-color: #aaa !important;
  background: #ddd !important;
  box-shadow: none;
}
/* Optional: suppress selection outline when disabled */
.patch.disabled.selected {
  outline: none !important;
}

/* Collapse: hide all patch contents including ports; show only the header */
.patch.collapsed {
  overflow: hidden;
}

/* Hide everything except the header */
.patch.collapsed > :not(header) {
  display: none !important;
}

/* Optional: tighter header look when collapsed */
.patch.collapsed header {

  background-color:purple;
}

</style>

</head>
<body >




<div id="instructions">

  <h3>Patch/Node GUI Demo - <span style="font-weight:normal">Keyboard-Driven (Bimodal)</span></h3>

<p style="font-family:arial">Node-based or patch-based programming is found in all kinds of professional
software.  To provide a better GUI, this demo utilizes keyboard keys instead of mouse buttons to move
and manipulate patches.  Follow the instructions below step-by-step to experience this different
kind of GUI.</p>

<hr/>

  <div class="scroll-content">

  <p><strong>1. Drag-Line (G key)</strong></p>
  <span class="instructions-description">For dragging patches (option 1)</span>
  <ol>
    <li>Press <kbd>G</kbd> while hovering over a patch to begin a drag-line.
    </li>
    <li> Move the mouse. A dashed line appears from the patch's center to your mouse.</li>
    <li>Move the cursor to the desired location for the patch.</li>
    <li>Press <kbd>G</kbd> again to transport the patch to that location.</li>
  </ol>

  <p><strong>2. Drag Lock (Spacebar)</strong></p>
    <span class="instructions-description">For dragging patches (option 2).</span>
  <ol>
    <li>Press and hold <kbd>Spacebar</kbd> to drag the patch under the mouse.</li>
    <li>Move the mouse to reposition the patch.</li>
    <li>Release <kbd>Spacebar</kbd> to drop the patch.</li>
  </ol>

  <p><strong>3. Selection (Tab key)</strong></p>
      <span class="instructions-description">For selecting patches (option 1).</span>
  <ol>
    <li>Hover over a patch and press <kbd>Tab</kbd> to select it.

    	<ul>

    	<li>The <kbd>Escape</kbd> key will clear the selection, as will
    	pressing <kbd>Tab</kbd> when the cursor is located outside of a patch.</li></ul>
    </li>
    <li>After selecting one or more patches, press the <kbd>Spacebar</kbd>
    to begin the drag lock.</li>
  </ol>

 <p><strong>4. Live Selection Rectangle (Y key)</strong></p>
          <span class="instructions-description">For selecting patches (option 2).</span>
<ol>
  <li>Press <kbd>Y</kbd> anywhere on the workspace to begin drawing a live selection rectangle.</li>
  <li>Move the mouse to grow or shrink the rectangle diagonally.</li>
	<ul>

  <li>As patches intersect or enter the rectangle, they are automatically selected.</li>
  <li>If a patch is no longer inside the rectangle, it is removed from the selection.</li>
  </ul>
  <li>Press <kbd>Y</kbd> again to finalize the selection and remove the outline.</li>
  <li>Press <kbd>Esc</kbd> at any time to cancel the selection rectangle.</li>
  <li>Use in combination with the Drag Lock (<kbd>Spacebar</kbd>) for dragging.
</ol>


  <p><strong>5. Connect Cables (F key)</strong></p>
    <span class="instructions-description">For wiring up patches.</span>
  <ol>
    <li>Hover over an outlet circle and press <kbd>F</kbd> to start a connection.</li>
    <li>Move the mouse to the other outlet and press <kbd>F</kbd> again to complete.</li>
    <li>Press <kbd>Esc</kbd> at any time to cancel.</li>
  </ol>

  <p><strong>6. Delete Cables (D key)</strong></p>
      <span class="instructions-description">For removing connections.</span>
  <ol>
    <li>Hover over an existing cable and press <kbd>D</kbd> to delete it.</li>
  </ol>

  <p><strong>7. Swap Cable Outlet (S key)</strong></p>
        <span class="instructions-description">For changing connections.</span>
  <ol>
    <li>Hover over an outlet with a connected cable and press <kbd>S</kbd> to detach it.</li>
    <li>Move to a new outlet and press <kbd>S</kbd> again to attach.</li>
  </ol>
  
 

  <p><strong>8. Tidy Rectangle (T key)</strong></p>
       <span class="instructions-description">For tidying up the workspace.</span>

<ol>
  <li>Press <kbd>T</kbd> anywhere on the canvas to start a tidy rectangle outline
  for aligning patches.</li>
  <li>Move the mouse to size the rectangle; all patches intersecting or inside the outline are candidates for alignment.</li>
  <li>Press <kbd>T</kbd> again to tidy the patches:  

<ul>
<li>A <em>wide</em> rectangle aligns them horizontally (same&nbsp;<em>y</em>).  </li>
<li>    A <em>tall</em> rectangle aligns them vertically (same&nbsp;<em>x</em>).</li>
        </ul>
    </li>

  <li>Press <kbd>Esc</kbd> at any time before the second <kbd>T</kbd> to cancel.</li>
</ol>


<!-- Insert inside #instructions -->

<p><strong>9. Numeric Field: Bracket Keys</strong></p>
   <span class="instructions-description">For stepping values up or down without mouse clicks.</span>
<ol>
  <li>Hover over a numeric value (or begin typing into it) to target the field.</li>
  <li>Press <kbd>[</kbd> to decrement or <kbd>]</kbd> to increment the value.</li>
  <li>Use modifiers to change the step size:
    <ul>
      <li><kbd>Shift</kbd> + <kbd>[</kbd>/<kbd>]</kbd> → large step</li>
      <li><kbd>Alt</kbd>/<kbd>Option</kbd> + <kbd>[</kbd>/<kbd>]</kbd> → small step</li>
    </ul>
  </li>
  <li>Values are clamped to the patch’s <em>min</em>/<em>max</em> and quantized to its step.</li>
</ol>

<p><strong>10. Slider: Spacebar Drag</strong></p>
   <span class="instructions-description">For manipulating a slider without mouse clicks.</span>
<ol>
  <li>Hover over a slider and press <kbd>Space</kbd> to begin drag-lock of the knob.</li>
  <li>Move the mouse horizontally to change the slider value. The paired numeric field updates in real time. A bracket guide may be displayed from the knob to the cursor.</li>
  <li>Press <kbd>Space</kbd> again or <kbd>Esc</kbd> to release the drag-lock.</li>
  <li>While drag-lock is active, selection changes via <kbd>Tab</kbd> are disabled.</li>
</ol>

<!-- Insert inside #instructions (next item) -->

<p><strong>11. Toggle Disabled State (W key)</strong></p>
<span class="instructions-description">For testing during programming.</span>

<ol>
  <li>Hover over a <em>cable</em> or a <em>patch</em> to target it.</li>
  <li>Press <kbd>W</kbd> to toggle the disabled state of the targeted item.</li>
  <li>Behavior:
    <ul>
      <li><strong>Cable:</strong> appears <em>dashed</em> and <em>light gray</em>. Press <kbd>W</kbd> again to re-enable.</li>
      <li><strong>Patch:</strong> dims, shows a <em>dashed border</em>, and ports are grayed; selection outline is suppressed while disabled. Press <kbd>W</kbd> again to re-enable.</li>
    </ul>
  </li>

</ol>


<p><strong>12. Collapse/Expand Patches (E key)</strong></p>
<span class="instructions-description">Hide patch contents for a compact layout; cables re-anchor to the header.</span>

<ol>
  <li><strong>Single patch:</strong> Hover a patch and press <kbd>E</kbd> to toggle its collapsed state.</li>
  <li><strong>Selection:</strong> If one or more patches are selected:
    <ul>
      <li>If all are expanded → press <kbd>E</kbd> to collapse all.</li>
      <li>If all are collapsed → press <kbd>E</kbd> to expand all.</li>
      <li>If mixed → majority decides (more expanded → collapse all; more collapsed → expand all).</li>
    </ul>
  </li>
  <li><strong>Effect of collapse:</strong> Only the title bar remains visible; all other content (including ports) is hidden. Cables condense to the vertical midpoint of the header’s left/right edges.</li>
</ol>

<p><strong>13. Duplication Line (M key)</strong></p>
<span class="instructions-description">Create a copy of a patch at a new location.</span>

<ol>
  <li>Hover over a patch and press <kbd>M</kbd> to begin a duplication line (distinct dashed guide).</li>
  <li>Move the mouse; the guide follows the cursor from the patch’s center.</li>
  <li>Press <kbd>M</kbd> again (or release the mouse button) to place a copy centered at the cursor. The original remains in place.</li>
  <li>Press <kbd>Esc</kbd> at any time before the second <kbd>M</kbd> to cancel.</li>
  <li>Note: Only the patch is duplicated; existing cables are not copied.</li>
</ol>


<br/><br/>
  
    </div>
  
    <div class="scrollbar-track">
    <div class="scrollbar-thumb"></div>
  </div>
  
</div>

<!--

<div style="color:white;margin-left:10pt;">    
    1. To make a selection, hover over a node and press <kbd>Tab</kbd>.
    <br/>
    2. Start dragging the selection by pressing <kbd>Spacebar</kbd> once, then move the mouse. Press <kbd>Spacebar</kbd> again to unlock the dragging.

    <br/>
    3. Connect outlets by hovering over a circle and pressing <kbd>F</kbd>. Then move the mouse.
    While hovering over the other outlet, press <kbd>F</kbd> again.  To cancel, press <kbd>Esc</kbd>.

    <br/>
    4. To delete a cable, hover over it and press <kbd>D</kbd>.
    <br/>
	5. To unhook a cable, to place it on a different outlet, press <kbd>S</kbd> while hovering 
	over the outlet to detach.  After hovering over the other outlet, press <kbd>S</kbd> again
	to attach.
</div>-->
  <div id="patchArea">
  
<div class="patch numeric" style="left:720px;top:320px;"
     data-id="num1"
     data-min="0" data-max="127"
     data-step="1" data-small-step="0.1" data-big-step="10"
     data-fallback="0" data-precision="0">
  <header>Pitch (Number)</header>
  <div class="num-body">
    <span class="num-label">Value</span>
    <span class="num-value" tabindex="-1">64</span>
  </div>
  <span class="port output" data-dir="out" data-name="cv"></span>
</div>

<div class="patch slider-numeric" style="left:720px;top:560px;"
     data-id="param1"
     data-min="0" data-max="100"
     data-step="1" data-small-step="0.5" data-big-step="10"
     data-fallback="50" data-precision="0">
  <header>Level (Slider+Number)</header>
  <div class="num-body">
    <input class="num-slider" type="range" min="0" max="100" step="1" value="50">
    <span class="num-value" tabindex="-1">50</span>
  </div>
  <span class="port output" data-dir="out" data-name="cv"></span>
</div>


<!-- Pitch CV Receiver -->
<div class="patch cv-receiver" style="left:980px;top:400px;" data-id="pitchRecv">
  <header>Pitch CV (Receiver)</header>
  <div class="recv-body">
   
   <!--
    <span class="recv-label">Value</span>
    <span class="recv-value" tabindex="-1">--</span>
-->
  </div>
  <span class="port input" data-dir="in" data-name="cv"></span>
</div>

<!-- Level CV Receiver -->
<div class="patch cv-receiver" style="left:980px;top:620px;" data-id="levelRecv">
  <header>Level CV (Receiver)</header>
  <div class="recv-body">
   <!-- <span class="recv-label">Value</span>
    <span class="recv-value" tabindex="-1">--</span>
-->
  </div>
  <span class="port input" data-dir="in" data-name="cv"></span>
</div>


<div class="patch" style="left:760px;top:120px;" data-id="osc">
  <header>Oscillator</header>
  <span class="port output" data-dir="out" data-name="audio"></span>
</div>

<div class="patch" style="left:980px;top:220px;" data-id="filter">
  <header>Filter</header>
  <span class="port input" data-dir="in" data-name="audio"></span>
  <span class="port output" data-dir="out" data-name="audio"></span>
</div>

<div class="patch" style="left:1200px;top:320px;" data-id="amp">
  <header>Amplifier</header>
  <span class="port input"  data-dir="in"  data-name="audio"></span>
  <span class="port output" data-dir="out" data-name="audio"></span>
</div>

<div class="patch" style="left:1420px;top:420px;" data-id="out">
  <header>Output</header>
  <span class="port input" data-dir="in" data-name="audio"></span>
</div>




    <!-- Overlay for cables (now above .patch) -->
    <canvas id="cablesCanvas" resize></canvas>
  </div>

<script>

  function getNodePosition(node) {
        return {x: node.offsetLeft, y: node.offsetTop};
    }

/* ─────────────────────────────────────────────────────────────────────────
   MULTI-PATCH DRAG SUPPORT
   •  Space-bar engages “drag-lock” for every .patch in the current selection.
   •  All selected patches follow the mouse as a rigid group.
   •  Press Space again (or release mouse) to drop them, then cables redraw.
   ───────────────────────────────────────────────────────────────────────*/

/* 1 ▸ New global to keep per-patch offsets from the cursor */
const dragOffsets = new Map();       // Map<HTMLElement,{dx,dy}>
/* ───── globals ───── */
const initialPos  = new Map();   // original {left,top} of each .patch
let   dragStart   = {x:0,y:0};   // mouse position at drag-start





/*************************************************
 *  Globals
 *************************************************/
const patchArea   = document.getElementById('patchArea');
const cableCanvas = document.getElementById('cablesCanvas');
const patches     = [...document.querySelectorAll('.patch')];
let hoverCable = null;   // paper.Path currently under the cursor

/* ——— Duplication Line (M key) ——— */
let dupLineActive       = false;  // true while drawing
let dupLineSourcePatch  = null;   // source .patch to duplicate
let dupLinePath         = null;   // paper.Path preview line
let patchIdCounter      = 1;


/* Visual: bracket from knob to cursor while dragging */
let sliderBracketPath     = null;
let sliderMoveListenerRef = null;   // window mousemove listener

/*────────────────────────────  S-key “re-patch” support  ───────────────────────────
   ▸  Hover any cable, press **S** → one end is detached and follows the cursor.
   ▸  Press **F** while the cursor is over a *different* port to finish the move.
   ▸  Press **Esc** to cancel.                                                         */

let reattachCable = null;   // paper.Path currently being moved
let reattachEnd   = 1;      // 0 = start-segment, 1 = end-segment
let startPort     = null;   // port that remains fixed
let lastMouse     = {x:0, y:0};   // updated on every mouse-move

/* ——— Tidy Rectangle (T key) ——— */
let tidyRectActive     = false;   // true while drawing
let tidyStartPoint     = null;    // first corner (mouse-down or patch-centre)
let tidyLinePath       = null;    // preview diagonal
let tidyRectOutline    = null;    // preview upright rectangle

/* ——— Live Selection Rectangle (Y key) ——— */
let liveSelActive      = false;   // true while drawing
let liveSelStart       = null;    // first corner (mouse position)
let liveSelLine        = null;    // preview diagonal
let liveSelRectOutline = null;    // preview upright rectangle

/* ——— Slider drag-lock (Space on slider knob) ——— */
let sliderDragLock  = false;
let sliderDragEl    = null;     // <input class="num-slider">
let sliderDragStart = null;     // { x, value, min, max, step, width }

/* Paper.js setup */
const paperScope = new paper.PaperScope();
paperScope.setup(cableCanvas);

/* ─────────── Auto-connect on load: Osc→Filter + Pitch/Level receivers ─────────── */
window.addEventListener('load', () => {
  const pairs = [
    // Existing audio path
    ['.patch[data-id="osc"]   .port.output',
     '.patch[data-id="filter"] .port.input'],

    // New control-voltage paths
    ['.patch[data-id="num1"]  .port.output',                               // Pitch (Number)
     '.patch[data-id="pitchRecv"] .port.input'],                           // Pitch Receiver

    ['.patch.slider-numeric[data-id="param1"] .port.output',               // Level (Slider+Number)
     '.patch[data-id="levelRecv"] .port.input']                            // Level Receiver
  ];

  pairs.forEach(([fromSel, toSel]) => {
    const from = document.querySelector(fromSel);
    const to   = document.querySelector(toSel);
    if (!(from && to)) return;

    // Skip if already connected
    if (connections.some(c => c.from === from && c.to === to)) return;

    const p1 = centerOf(from);
    const p2 = centerOf(to);

    const path = new paperScope.Path({ strokeColor: '#333', strokeWidth: 2 });
    const midX = (p1.x + p2.x) / 2;
    path.moveTo(p1.x, p1.y);
    path.cubicCurveTo(midX, p1.y, midX, p2.y, p2.x, p2.y);

    connections.push({ from, to, path });
  });

  paperScope.view.update();
  window.updateCvReceivers?.();
});


/* Data for active drag-lock & cables */
let selectedPatch = null;
let dragLock      = false;
let dragOffset    = {x:0,y:0};
/* tracks a patch selected automatically by the space-bar */
let autoSelectedPatch = null;

/* Connection‑state data */
let connecting   = false;        // true → awaiting 2nd port
let connectStart = null;         // HTMLElement (first port)
let previewPath  = null;         // paper.Path for live preview
const connections = [];          // {from:HTMLElement, to:HTMLElement, path:paper.Path}

/* ——— Drag-Line relocation (G key) ——— */
let dragLineActive = false;   // true while drawing
let dragLinePatch  = null;    // HTMLElement being moved
let dragLinePath   = null;    // paper.Path preview line


// Ensure the page captures keyboard events as soon as it is shown
window.addEventListener('load', () => document.body.focus(), { once:true });
document.addEventListener('visibilitychange', () => {
  if (!document.hidden) document.body.focus();            // regain focus on tab-switch
});



patchArea.addEventListener('mousedown', e => {
  if (e.button !== 0) return;                              // left-button only
  if (!e.target.closest('.patch')) {                       // clicked outside any node
    clearSelection();
    selectedPatch = null;
    paperScope.view.update();
  }
});

/*************************************************
 *  Utility helpers
 *************************************************/
function centerOf(el){
  const r = el.getBoundingClientRect();
  return {x:r.left + r.width/2 + window.scrollX, y:r.top + r.height/2 + window.scrollY};
}
/* Replace the old single-selection helper with this multi-selection version */
function clearSelection(){
  /* remove the “selected” class from every patch that has it */
  document.querySelectorAll('.patch.selected')
          .forEach(el => el.classList.remove('selected'));

  /* reset single-patch state, if in use elsewhere */
  selectedPatch = null;
}

/* Return the anchor point for a port.
   If the owning patch is collapsed, snap to the header's vertical midline on the
   left (inputs) or right (outputs). Otherwise use the port's own center. */
function portAnchorPoint(portEl) {
  const patch = portEl.closest('.patch');
  if (!patch) return centerOf(portEl);

  if (!patch.classList.contains('collapsed')) {
    return centerOf(portEl);
  }

  const hdr = patch.querySelector('header');
  if (!hdr) return centerOf(patch);

  const r = hdr.getBoundingClientRect();
  const y = r.top + r.height / 2 + window.scrollY;
  const dir = portEl.dataset?.dir || '';  // 'in' | 'out'
  const x = (dir === 'in')
    ? (r.left + window.scrollX)   // left edge mid
    : (r.right + window.scrollX); // right edge mid

  return { x, y };
}


/** Update an existing cubic path's 4 control points to new endpoints */
function refreshPath(path, p1, p2){
  const midX=(p1.x+p2.x)/2;
  const segs = path.segments;
  if(segs.length!==4){ path.removeSegments(); path.moveTo(p1.x,p1.y); path.cubicCurveTo(midX,p1.y, midX,p2.y, p2.x,p2.y); return; }
  segs[0].point.set(p1.x,p1.y);
  segs[1].point.set(midX,p1.y);
  segs[2].point.set(midX,p2.y);
  segs[3].point.set(p2.x,p2.y);
}

function redrawCables() {
  for (const c of connections) {
    const p1 = portAnchorPoint(c.from);
    const p2 = portAnchorPoint(c.to);

    if (c.path) {
      refreshPath(c.path, p1, p2);
    } else {
      const path = new paperScope.Path();
      c.path = path;
      path.strokeColor = '#333';
      path.strokeWidth = 2;
      path.moveTo(p1.x, p1.y);
      const midX = (p1.x + p2.x) / 2;
      path.cubicCurveTo(midX, p1.y, midX, p2.y, p2.x, p2.y);
    }
  }
  paperScope.view.update();
}

function disconnect(from,to){
  const idx = connections.findIndex(c=>c.from===from && c.to===to);
  if(idx>-1){
    connections[idx].path.remove();
    connections.splice(idx,1);
    paperScope.view.update();
  }
}
function abortPreview(){
  if(previewPath){ previewPath.remove(); previewPath=null; }
  connecting=false;
  connectStart=null;
}

/*************************************************
 *  Pointer tracking
 *************************************************/
let mouse={x:0,y:0};
patchArea.addEventListener('mousemove',e=>{
  lastMouse = {x:e.clientX, y:e.clientY};                 // keep latest position
  mouse.x = e.clientX; mouse.y = e.clientY;            // keep global mouse


 if(reattachCable){                                      // move the floating end
    reattachCable.segments[reattachEnd].point =
      new paperScope.Point(e.clientX + window.scrollX,
                           e.clientY + window.scrollY);
    paperScope.view.update();
  }


  /* — group dragging — */
 
/* mouse-move: reuse the stored offsets so every patch keeps its original spacing */
if (dragLock && initialPos.size) {
  const dx = mouse.x - dragStart.x;
  const dy = mouse.y - dragStart.y;
  initialPos.forEach((pos, el) => {
    el.style.left = (pos.left + dx) + 'px';
    el.style.top  = (pos.top  + dy) + 'px';
  });
  redrawCables();                // maintain connections
  
  return;
}


 const mouse1 = { x: e.clientX, y: e.clientY };
  mouse.x=e.clientX; mouse.y=e.clientY;
  if(dragLock && selectedPatch){
    selectedPatch.style.left=(mouse.x-dragOffset.x)+'px';
    selectedPatch.style.top =(mouse.y-dragOffset.y)+'px';
    redrawCables();
    
  }

/* live update for G drag-line */
if (dragLineActive && dragLinePath) {
  dragLinePath.lastSegment.point.set(mouse.x + window.scrollX,
                                     mouse.y + window.scrollY);
  paperScope.view.update();
}

/* Copy-line */
if (dupLineActive && dupLinePath) {
  dupLinePath.lastSegment.point.set(mouse.x + window.scrollX,
                                    mouse.y + window.scrollY);
  paperScope.view.update();
}

  
 /* Cable hover detection */
if (!connecting){
  const hit = paperScope.project.hitTest(
    new paperScope.Point(mouse.x + window.scrollX, mouse.y + window.scrollY),
    { stroke: true, fill: false, segments: false, tolerance: 6 });

  const target = (hit && hit.item &&
                  connections.some(c => c.path === hit.item))
                 ? hit.item : null;

  if (target !== hoverCable){
    // restore previous cable's normal style
    if (hoverCable){
      const prev = connections.find(c => c.path === hoverCable);
      if (prev) styleCable(prev, false);
    }
    hoverCable = target;

    // apply hover style to new target
    if (hoverCable){
      const next = connections.find(c => c.path === hoverCable);
      if (next) styleCable(next, true);
    }
    paperScope.view.update();
  }
}

  
  
  
});

/*************************************************
 *  Hover state for ports
 *************************************************/
let hoverPort=null;
patchArea.addEventListener('mouseover',e=>{
  const p=e.target.closest('.port');
  if(p){hoverPort=p; p.classList.add('hover');}
});
patchArea.addEventListener('mouseout',e=>{
  const p=e.target.closest('.port');
  if(p){p.classList.remove('hover'); if(hoverPort===p) hoverPort=null;}
});




/*************************************************
 *  Keyboard control (Tab / Space / F / Esc)
 *************************************************/
/*  Focus the canvas whenever the mouse enters it  */
patchArea.tabIndex = 0;                 // make the element focus-able
patchArea.addEventListener('mouseenter', () => {
  patchArea.focus();                    // direct subsequent key events here
});


/* ──────────────────────────────────────────────────────────────────────────────
   Unified key-down handler  (revised)
   –  S  : detach nearest end of hovered cable; press S again to attach
   –  D  : delete the hovered cable
   –  F  : make / break a normal port-to-port connection
   –  ⎵  : toggle drag-lock on the *last* selected patch
   –  Tab: MULTI-SELECT patch under cursor; Tab in empty space clears selection
   –  Esc: cancel current modes (drag, preview, re-patch, selection)
   ────────────────────────────────────────────────────────────────────────────*/
document.addEventListener('keydown', e => {

  const key   = e.key;
  const lower = key.toLowerCase();

 /* ─────────────────────  G : drag-line relocation  ───────────────────── */
/* ─────────────────────  G : drag-line relocation  ───────────────────── */
if (lower === 'g') {
  e.preventDefault();
  if (!dragLineActive) {
    // Begin drag-line
    const tgt = document.elementFromPoint(mouse.x, mouse.y)?.closest('.patch');
    if (!tgt) return; // no patch under cursor
    dragLineActive = true;
    dragLinePatch  = tgt;
    const start = centerOf(tgt);
    dragLinePath = new paperScope.Path.Line({
      from: start,
      to:   start,
      strokeColor: '#0d6efd',
      strokeWidth: 2,
      dashArray: [4, 4]
    });
    return;
  } else {
  
  // Animate patch from original position to cursor location
const endX = mouse.x + window.scrollX;
const endY = mouse.y + window.scrollY;
const r = dragLinePatch.getBoundingClientRect();
const startX = r.left + window.scrollX;
const startY = r.top  + window.scrollY;

const targetX = endX - r.width / 2;
const targetY = endY - r.height / 2;

const dx = targetX - startX;
const dy = targetY - startY;

const duration = 100; // ms
const steps = 15;
let frame = 0;

function animate() {
  const t = ++frame / steps;
  if (t >= 1) {
    dragLinePatch.style.left = targetX + 'px';
    dragLinePatch.style.top  = targetY + 'px';
    dragLinePath.remove();
    dragLineActive = false;
    dragLinePatch = null;
    dragLinePath  = null;
    redrawCables();
    return;
  }
  const ease = t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t; // ease-in-out
  const x = startX + dx * ease;
  const y = startY + dy * ease;
  dragLinePatch.style.left = x + 'px';
  dragLinePatch.style.top  = y + 'px';
  redrawCables();                          // refresh cables each frame
  requestAnimationFrame(animate);
}
requestAnimationFrame(animate);

  /*
    // Complete drag-line by moving patch
    const endX = mouse.x + window.scrollX;
    const endY = mouse.y + window.scrollY;
    const r = dragLinePatch.getBoundingClientRect();
    dragLinePatch.style.left = (endX - r.width  / 2) + 'px';
    dragLinePatch.style.top  = (endY - r.height / 2) + 'px';
    dragLinePath.remove();
    dragLineActive = false;
    dragLinePatch = null;
    dragLinePath  = null;
    redrawCables();*/
    return;
  }
}

            
  /* ──────────────────────  S : detach / re-attach a cable end  ─────────────────── */
  if (lower === 's') {
    /* 1 ▸ finish reconnection if a loose end exists */
    if (reattachCable && connecting) {
      const portElem = document.elementFromPoint(lastMouse.x, lastMouse.y);
      if (!(portElem && portElem.classList.contains('port'))) return;
      if (portElem.closest('.patch') === startPort.closest('.patch')) return;

      const r = portElem.getBoundingClientRect();
      reattachCable.segments[reattachEnd].point =
        new paperScope.Point(r.left + r.width / 2 + window.scrollX,
                             r.top  + r.height / 2 + window.scrollY);

      const conn = connections.find(c => c.path === reattachCable);
      if (reattachEnd === 0) { conn.from = portElem; } else { conn.to = portElem; }

      reattachCable = null; connecting = false; startPort = null;
      setCursor?.(null);
      paperScope.view.update();
      return;
    }

    /* 2 ▸ not reconnecting yet: detach nearest end of hovered cable */
    if (hoverCable && !connecting && !reattachCable) {
      const conn = connections.find(c => c.path === hoverCable);
      if (!conn) return;

      const p0  = hoverCable.segments[0].point;
      const p1  = hoverCable.segments[1].point;
      const cur = new paperScope.Point(lastMouse.x + window.scrollX,
                                       lastMouse.y + window.scrollY);
      reattachEnd = (p0.getDistance(cur) < p1.getDistance(cur)) ? 0 : 1;

      if (reattachEnd === 0) { conn.from = null; startPort = conn.to; }
      else                   { conn.to   = null; startPort = conn.from; }

      reattachCable = hoverCable;
      connecting    = true;
      setCursor?.('connecting');
      return;
    }
  }

  /* ───────── Esc : cancel a pending re-patch (remove orphan if needed) ───────── */
  if (key === 'Escape' && reattachCable) {
    const conn = connections.find(c => c.path === reattachCable);
    if (!conn.from || !conn.to) {
      reattachCable.remove();
      connections.splice(connections.indexOf(conn), 1);
    }
    reattachCable = null; connecting = false; startPort = null;
    setCursor?.(null);
    paperScope.view.update();
    return;
  }

  /* ───────── Cursor tidy-up for Esc and D (outside re-patch mode) ───────── */
  if (key === 'Escape' || (lower === 'd' && hoverCable)) {
    setCursor?.(null);
  }

/* ────────────────────  Y : live selection rectangle  ──────────────────── */
if (lower === 'y') {
  e.preventDefault();

  /* ── first Y ▶ begin preview ─────────────────────────────────────────── */
  if (!liveSelActive) {
    /* start rectangle where the cursor is */
    liveSelStart  = { x: mouse.x + window.scrollX,
                      y: mouse.y + window.scrollY };

    liveSelActive = true;

    /* clear existing selection — rectangle defines a new one */
    clearSelection();

    liveSelLine = new paperScope.Path.Line({
      from: liveSelStart,
      to:   liveSelStart,
      strokeColor: '#00d1ff',
      strokeWidth: 0,
      dashArray: [4, 4]
    });

    liveSelRectOutline = new paperScope.Path.Rectangle({
      from: liveSelStart,
      to:   liveSelStart,
      strokeColor: '#00d1ff',
      strokeWidth: 1,
      dashArray: [4, 4],
      fillColor: null
    });

    return;                                           // wait for 2nd Y
  }

  /* ── second Y ▶ finish selection ─────────────────────────────────────── */
  liveSelActive      = false;
  liveSelStart       = null;
  liveSelLine.remove();
  liveSelRectOutline.remove();
  liveSelLine        = null;
  liveSelRectOutline = null;
  return;
}

/* ────────────────────  T : tidy-rectangle alignment  ──────────────────── */
/* ────────────────────  T : tidy-rectangle alignment  ──────────────────── */
if (lower === 't') {
  e.preventDefault();

  /* ── first T ▶ begin preview ─────────────────────────────────────────── */
  if (!tidyRectActive) {
    /* start at mouse position (centre of patch if present) */
    const patchUnder = document.elementFromPoint(mouse.x, mouse.y)?.closest('.patch');
    tidyStartPoint = patchUnder ? centerOf(patchUnder)
                                : { x: mouse.x + window.scrollX,
                                    y: mouse.y + window.scrollY };

    tidyRectActive = true;

    tidyLinePath = new paperScope.Path.Line({
      from: tidyStartPoint,
      to:   tidyStartPoint,
      strokeColor: '#ffc107',
      strokeWidth: 0,
      dashArray: [4, 4]
    });

    tidyRectOutline = new paperScope.Path.Rectangle({
      from: tidyStartPoint,
      to:   tidyStartPoint,
      strokeColor: '#ffc107',
      strokeWidth: 4,
      dashArray: [1, 1],
      fillColor: null
    });

    return;                                           // wait for second T
  }

  /* ── second T ▶ apply alignment ──────────────────────────────────────── */
  if (!tidyLinePath || !tidyStartPoint) return;

  const endPt = { x: mouse.x + window.scrollX, y: mouse.y + window.scrollY };
  const box   = {
    left:   Math.min(tidyStartPoint.x, endPt.x),
    right:  Math.max(tidyStartPoint.x, endPt.x),
    top:    Math.min(tidyStartPoint.y, endPt.y),
    bottom: Math.max(tidyStartPoint.y, endPt.y)
  };
  const w = box.right  - box.left;
  const h = box.bottom - box.top;

  /* collect patches that intersect or lie within the rectangle */
  const affected = [];
  document.querySelectorAll('.patch').forEach(el => {
    const r = el.getBoundingClientRect();
    const p = {
      left:   r.left + window.scrollX,
      right:  r.left + r.width  + window.scrollX,
      top:    r.top  + window.scrollY,
      bottom: r.top  + r.height + window.scrollY
    };
    const hit = !(p.right < box.left || p.left > box.right ||
                  p.bottom < box.top || p.top  > box.bottom);
    if (hit) affected.push(el);
  });

/* ── align patches without overlap ───────────────────────────────────── */
if (affected.length > 1) {
  const margin = 20;                       // gap between neighbouring patches

  if (w >= h) {                            // ‼ wide rectangle → horizontal row
    // sort by current x-position (left edge), leftmost first
    affected.sort((a, b) => a.offsetLeft - b.offsetLeft);

    // common y (row) is the arithmetic mean of current tops
    const rowY = affected.reduce((s, e) => s + e.offsetTop, 0) / affected.length;

    // lay patches left-to-right with no overlap (+ margin)
    let cursorX = Math.min(...affected.map(e => e.offsetLeft));
    affected.forEach(el => {
      el.style.left = cursorX + 'px';
      el.style.top  = rowY  + 'px';
      const width   = el.getBoundingClientRect().width;
      cursorX += width + margin;
    });
  } else {                                 // ‼ tall rectangle → vertical column
    // sort by current y-position (top edge), topmost first
    affected.sort((a, b) => a.offsetTop - b.offsetTop);

    // common x (column) is the arithmetic mean of current lefts
    const colX = affected.reduce((s, e) => s + e.offsetLeft, 0) / affected.length;

    // lay patches top-to-bottom with no overlap (+ margin)
    let cursorY = Math.min(...affected.map(e => e.offsetTop));
    affected.forEach(el => {
      el.style.left = colX + 'px';
      el.style.top  = cursorY + 'px';
      const height  = el.getBoundingClientRect().height;
      cursorY += height + margin;
    });
  }

  redrawCables();                          // refresh all connections
}

  /* cleanup preview */
  tidyRectActive  = false;
  tidyStartPoint  = null;
  tidyLinePath.remove();
  tidyRectOutline.remove();
  tidyLinePath    = null;
  tidyRectOutline = null;
  return;
}


/* ───────── Tab : multi-select toggle, or clear selection in empty space ───────── */
/* ───────── Tab : multi-select toggle, or clear selection in empty space ───────── */
if (e.key === 'Tab') {
  e.preventDefault();

  // Do nothing if drag-lock or sliderDragLock is active.

	if (dragLock || sliderDragLock) {
	  return;
	}


  const patchAtCursor =
        document.elementFromPoint(mouse.x, mouse.y)?.closest('.patch');

  if (patchAtCursor) {
    // Toggle selection state of the patch under the cursor
    if (patchAtCursor.classList.contains('selected')) {
      patchAtCursor.classList.remove('selected');
      if (selectedPatch === patchAtCursor) selectedPatch = null;
    } else {
      patchAtCursor.classList.add('selected'); // add to multi-selection
      selectedPatch = patchAtCursor;           // remember last-active patch
    }
  } else {
    // Cursor in empty space: clear all selected patches
    clearSelection();
    selectedPatch = null;
  }
  return;
}


/* ───────────────────────  Space : drag-lock toggle  ─────────────────────── */
if (e.code === 'Space' || e.key === ' ') {
  e.preventDefault();

  // 0) If a slider drag-lock is active, Space releases it.
  if (sliderDragLock) {
    stopSliderDrag();
    return;
  }

  // 1) If hovering a slider knob/track, Space starts slider drag-lock.
  const sliderUnderCursor =
    document.elementFromPoint(mouse.x, mouse.y)?.closest('.num-slider');
  if (sliderUnderCursor && !dragLock) {
    startSliderDrag(sliderUnderCursor, mouse.x);
    return;
  }

  // 2) Otherwise: patch drag-lock (supports multi-select + auto-select on hover)
  let selected = [...document.querySelectorAll('.patch.selected')];

  if (!dragLock) {
    // Auto-select the patch under the cursor when none is selected
    if (!selected.length) {
      const tgt = document.elementFromPoint(mouse.x, mouse.y)?.closest('.patch');
      if (!tgt) return;
      tgt.classList.add('selected');
      selected = [tgt];
      autoSelectedPatch = tgt;  // so we can deselect on release
    }

    dragLock  = true;
    dragStart = { x: mouse.x, y: mouse.y };

    initialPos.clear();
    selected.forEach(el => {
      const r = el.getBoundingClientRect();
      initialPos.set(el, { left: r.left, top: r.top });
      el.classList.add('dragging');
    });
  } else {
    // Release patch drag-lock
    dragLock = false;
    document.querySelectorAll('.patch.dragging')
            .forEach(el => el.classList.remove('dragging'));
    initialPos.clear();
    dragOffsets.clear?.();
    redrawCables();

    if (autoSelectedPatch) {
      autoSelectedPatch.classList.remove('selected');
      autoSelectedPatch = null;
    }
  }
  return;
}

  /* ───────────────────  F : connect / disconnect ports  ──────────────────── */
  if (lower === 'f') {
    e.preventDefault();
    if (!hoverPort) return;

    if (!connecting) {                       /* first press: begin */
      abortPreview();
      connecting   = true; connectStart = hoverPort;

	  const startPt = portAnchorPoint(connectStart);

      previewPath = new paperScope.Path.Line({
        from: startPt, to: startPt,
        strokeColor: '#f39c12', strokeWidth: 2, dashArray: [6, 4]
      });
      return;
    }

    /* second press: finalise */
    const start = connectStart; const end = hoverPort;
    abortPreview();
    if (start === end) return;

    const okFwd  = start.dataset.dir === 'out' && end.dataset.dir === 'in';
    const okBack = start.dataset.dir === 'in'  && end.dataset.dir === 'out';
    if (!(okFwd || okBack)) return;

    const from = okFwd ? start : end;
    const to   = okFwd ? end   : start;

    const exists = connections.some(c => c.from === from && c.to === to);
    if (exists) { disconnect(from, to); } else {
      connections.push({ from, to, path: null }); redrawCables();
    }
    return;
  }

  /* ─────────────────────  D : delete the hovered cable  ───────────────────── */
  if (lower === 'd') {
    if (hoverCable) {
      const idx = connections.findIndex(c => c.path === hoverCable);
      if (idx > -1) {
        connections[idx].path.remove();
        connections.splice(idx, 1);
      }
      hoverCable = null;
      paperScope.view.update();
    }
    return;
  }

/* ─────────────────────  W : toggle disabled (cable or patch)  ───────────────────── */
if (lower === 'w') {
  e.preventDefault();

  // 1) If hovering a cable, toggle its disabled state (existing behavior)
  if (hoverCable) {
    const conn = connections.find(c => c.path === hoverCable);
    if (conn) {
      conn.disabled = !conn.disabled;
      styleCable(conn, true);           // keep hover highlighting
      paperScope.view.update();
    }
    return;
  }

  // 2) Otherwise, toggle the patch under the cursor
  const patchAtCursor = document.elementFromPoint(mouse.x, mouse.y)?.closest('.patch');
  if (patchAtCursor) {
    const nowDisabled = patchAtCursor.classList.toggle('disabled');

    // If you prefer to clear selection when disabling:
    if (nowDisabled) {
      patchAtCursor.classList.remove('selected', 'dragging');
    }

    // Optional: if you want cables connected to this patch to visually reflect disabled state,
    // you may restyle them here (purely visual). Uncomment to use:
    /*
    connections.forEach(c => {
      if (c.from?.closest('.patch') === patchAtCursor || c.to?.closest('.patch') === patchAtCursor) {
        // No logical disable for cables here; keep their current disabled flag.
        // If you'd like to gray out connected cables when patch is disabled, do:
        // c._viaDisabledPatch = nowDisabled;
        styleCable(c, false);
      }
    });
    paperScope.view.update();
    */
    return;
  }

  // Nothing under cursor to toggle
  return;
}

/* ─────────────────────  M : duplication-line  ───────────────────── */
/* ➌ REPLACE your current M-key block with this version to give Copy Line
      a DISTINCT style (color + dash) compared to G Drag Line. */
if (lower === 'm') {
  e.preventDefault();

  // First M: begin from patch under cursor
  if (!dupLineActive) {
    const tgt = document.elementFromPoint(mouse.x, mouse.y)?.closest('.patch');
    if (!tgt) return; // must start on a patch
    dupLineActive = true;
    dupLineSourcePatch = tgt;

    const start = centerOf(tgt);
    dupLinePath = new paperScope.Path.Line({
      from: start,
      to:   start,
      strokeColor: '#d63384',   // distinct magenta
      strokeWidth: 2,
      dashArray: [2, 8]         // distinct dash pattern
    });
    paperScope.view.update();
    return;
  }

  // Second M: place a copy at the cursor
  const endX = mouse.x + window.scrollX;
  const endY = mouse.y + window.scrollY;
  duplicatePatchAt(dupLineSourcePatch, endX, endY);

  dupLinePath.remove();
  dupLineActive = false;
  dupLineSourcePatch = null;
  dupLinePath = null;

  redrawCables();
  return;
}

/* ─────────────────────  E : collapse/expand patches  ─────────────────────
   Behavior:
   - If there is a selection: 
       • all expanded  → collapse all
       • all collapsed → expand all
       • mixed         → decide by majority (more expanded → collapse all, more collapsed → expand all)
   - If no selection: operate on the patch under the cursor (single-target toggle).
---------------------------------------------------------------------------- */
if (lower === 'e') {
  e.preventDefault();

  // Resolve targets: selection, else patch under cursor
  let targets = [...document.querySelectorAll('.patch.selected')];
  if (!targets.length) {
    const p = document.elementFromPoint(mouse.x, mouse.y)?.closest('.patch');
    if (!p) return;
    targets = [p];
  }

  const total = targets.length;
  const collapsedCount = targets.reduce((n, el) => n + (el.classList.contains('collapsed') ? 1 : 0), 0);
  const expandedCount  = total - collapsedCount;

  // Decide action
  let action; // 'collapse' | 'expand'
  if (collapsedCount === total) {
    action = 'expand';            // all collapsed → expand all
  } else if (expandedCount === total) {
    action = 'collapse';          // all expanded → collapse all
  } else {
    // mixed: majority decides
    action = (expandedCount >= collapsedCount) ? 'collapse' : 'expand';
  }

  // Apply
  if (action === 'collapse') {
    targets.forEach(el => el.classList.add('collapsed'));
  } else {
    targets.forEach(el => el.classList.remove('collapsed'));
  }

  redrawCables();
  // Ports remain visible; redraw in case geometry affects cable routing
  redrawCables?.();
  return;
}

  /* ─────────────────────  Esc : cancel other operations  ──────────────────── */
  if (key === 'Escape') {
  
  /* cancel live selection rectangle */
if (liveSelActive) {
  if (liveSelLine)        liveSelLine.remove();
  if (liveSelRectOutline) liveSelRectOutline.remove();
  liveSelActive      = false;
  liveSelStart       = null;
  liveSelLine        = null;
  liveSelRectOutline = null;
}


/* cancel tidy rectangle */
if (tidyRectActive) {
  if (tidyLinePath)    tidyLinePath.remove();
  if (tidyRectOutline) tidyRectOutline.remove();
  tidyRectActive  = false;
  tidyStartPoint  = null;
  tidyLinePath    = null;
  tidyRectOutline = null;
}

/* cancel duplication line */
if (dupLineActive) {
  if (dupLinePath) dupLinePath.remove();
  dupLineActive = false;
  dupLineSourcePatch = null;
  dupLinePath = null;
}


if (sliderDragLock) {
  stopSliderDrag();
}


    if (dragLock && selectedPatch) {
      dragLock = false; selectedPatch.classList.remove('dragging');
    }
    abortPreview();
    if (dragLineActive) {
  if (dragLinePath) dragLinePath.remove();
  dragLineActive = false; dragLinePatch = null; dragLinePath = null;
	}

    clearSelection();
    paperScope.view.update();
  }
});


/*************************************************
 *  Live update of preview connection during mousemove (when connecting)
 *************************************************/
patchArea.addEventListener('mousemove',()=>{
  if(connecting && previewPath && connectStart){
    const p1=centerOf(connectStart);
    const p2={x:mouse.x+window.scrollX,y:mouse.y+window.scrollY};
    refreshPath(previewPath, p1, p2);
    paperScope.view.update();
  }
  /* live update for T tidy rectangle */
if (tidyRectActive && tidyLinePath) {
  tidyLinePath.lastSegment.point.set(mouse.x + window.scrollX,
                                     mouse.y + window.scrollY);
  paperScope.view.update();
}

/* live update for T tidy rectangle */
if (tidyRectActive && tidyLinePath) {
  const curX = mouse.x + window.scrollX;
  const curY = mouse.y + window.scrollY;

  /* update diagonal */
  tidyLinePath.lastSegment.point.set(curX, curY);

  /* update / recreate rectangle outline */
  if (tidyRectOutline) tidyRectOutline.remove();
  tidyRectOutline = new paperScope.Path.Rectangle({
    from: { x: Math.min(tidyStartPoint.x, curX),
            y: Math.min(tidyStartPoint.y, curY) },
    to:   { x: Math.max(tidyStartPoint.x, curX),
            y: Math.max(tidyStartPoint.y, curY) },
    strokeColor: '#ffc107',
    strokeWidth: 1,
    dashArray: [4, 4],
  fillColor: '#ffc107'          // give it the same hue …
});
tidyRectOutline.fillColor.alpha = 0.2;   // … but almost fully transparent

  paperScope.view.update();
}


/* live update for Y selection rectangle */
if (liveSelActive && liveSelLine) {
  const curX = mouse.x + window.scrollX;
  const curY = mouse.y + window.scrollY;

  /* update diagonal */
  liveSelLine.lastSegment.point.set(curX, curY);

  /* update rectangle outline */
  if (liveSelRectOutline) liveSelRectOutline.remove();
  liveSelRectOutline = new paperScope.Path.Rectangle({
    from: { x: Math.min(liveSelStart.x, curX),
            y: Math.min(liveSelStart.y, curY) },
    to:   { x: Math.max(liveSelStart.x, curX),
            y: Math.max(liveSelStart.y, curY) },
    strokeColor: '#00d1ff',
    strokeWidth: 0,
  fillColor: '#00d1ff'
});
liveSelRectOutline.fillColor.alpha = 0.15; // light, transparent cyan

  /* update selection membership */
  const box = {
    left:   Math.min(liveSelStart.x, curX),
    right:  Math.max(liveSelStart.x, curX),
    top:    Math.min(liveSelStart.y, curY),
    bottom: Math.max(liveSelStart.y, curY)
  };

  document.querySelectorAll('.patch').forEach(el => {
    const r = el.getBoundingClientRect();
    const p = {
      left:   r.left + window.scrollX,
      right:  r.left + r.width  + window.scrollX,
      top:    r.top  + window.scrollY,
      bottom: r.top  + r.height + window.scrollY
    };
    const hit = !(p.right < box.left || p.left > box.right ||
                  p.bottom < box.top || p.top  > box.bottom);
    el.classList.toggle('selected', hit);
  });



  paperScope.view.update();
}

});

/*************************************************
 *  Ensure canvas resizes with window
 *************************************************/
function resizeCanvas(){
  cableCanvas.width=window.innerWidth; cableCanvas.height=window.innerHeight;
  paperScope.view.update();
}

/* Utility: centralised cursor state handler */
  function setCursor(state){           // state ∈ null | class-name string
    patchArea.classList.remove(
      'connecting','over-port','hover-cable','invalid-connect');
    if(state){ patchArea.classList.add(state); }
  }

  /* —— A.  start of a cable drag —— */
   startPort=null;                  // remember first port
  document.addEventListener('mousedown',e=>{
    if(e.target.classList && e.target.classList.contains('port')){
      startPort=e.target;
      connecting=true;                 // your existing flag
      setCursor('connecting');
      /* …existing cable-start code… */
    }
  });
  
    patchArea.addEventListener('mousemove',e=>{
    const tgt=e.target;

    if(connecting){
      /* while dragging, show not-allowed when same-patch */
      const overPort = tgt.classList && tgt.classList.contains('port');
      const invalid  = overPort && startPort &&
                       (startPort.closest('.patch')===tgt.closest('.patch'));
      setCursor(invalid ? 'invalid-connect' : 'connecting');
      return;                           // nothing else while dragging
    }

    /* not dragging: highlight cable or port */
    if(hoverCable){                     // set in previous answer
      setCursor('hover-cable');
    }else if(tgt.classList && tgt.classList.contains('port')){
      setCursor('over-port');
    }else{
      setCursor(null);
    }
    
  


  });
  
   /* —— C.  end of a drag / clear cursor —— */
  document.addEventListener('mouseup',()=>{
    if(connecting){
      connecting=false;
      setCursor(null);
      startPort=null;
    }
    
    /* complete drag-line – move patch to cursor */
if (dragLineActive && dragLinePatch && dragLinePath) {
  const endX = lastMouse.x + window.scrollX;
  const endY = lastMouse.y + window.scrollY;
  const r = dragLinePatch.getBoundingClientRect();
  dragLinePatch.style.left = (endX - r.width  / 2) + 'px';
  dragLinePatch.style.top  = (endY - r.height / 2) + 'px';
  dragLinePath.remove();
  dragLineActive = false; dragLinePatch = null; dragLinePath = null;
  redrawCables();
}

/* complete duplication line – copy patch to cursor */
if (dupLineActive && dupLineSourcePatch && dupLinePath) {
  const endX = lastMouse.x + window.scrollX;
  const endY = lastMouse.y + window.scrollY;
  duplicatePatchAt(dupLineSourcePatch, endX, endY);
  dupLinePath.remove();
  dupLineActive = false;
  dupLineSourcePatch = null;
  dupLinePath = null;
  redrawCables();
}


    
  });

window.addEventListener('resize',resizeCanvas); resizeCanvas();
</script>

<script>
  const container = document.querySelector('#instructions');
  const content = container.querySelector('.scroll-content');
  const track = container.querySelector('.scrollbar-track');
  const thumb = container.querySelector('.scrollbar-thumb');

  function updateThumb() {
    const ratio = content.scrollTop / (content.scrollHeight - content.clientHeight);
    const thumbHeight = Math.max((content.clientHeight / content.scrollHeight) * track.clientHeight, 30);
    thumb.style.height = thumbHeight + 'px';
    thumb.style.top = (ratio * (track.clientHeight - thumbHeight)) + 'px';
  }

  content.addEventListener('scroll', updateThumb);
  window.addEventListener('resize', updateThumb);
  window.addEventListener('load', updateThumb);

  let dragging = false;
  let startY, startScroll;

  thumb.addEventListener('mousedown', (e) => {
    dragging = true;
    startY = e.clientY;
    startScroll = content.scrollTop;
    document.body.style.userSelect = 'none';
  });

  window.addEventListener('mousemove', (e) => {
    if (!dragging) return;
    const deltaY = e.clientY - startY;
    const scrollRatio = (content.scrollHeight - content.clientHeight) / (track.clientHeight - thumb.clientHeight);
    content.scrollTop = startScroll + deltaY * scrollRatio;
  });

  window.addEventListener('mouseup', () => {
    dragging = false;
    document.body.style.userSelect = '';
  });
</script>
<!-- 3) Logic: type-on-hover editing + [ / ] increments; slider binding -->
<script>
(() => {
  if (window.__numericInit) return;
  window.__numericInit = true;

  let hoverNumEl = null;
  let numEditActive = false;
  let numEditBuffer = "";
  let numPrevText = "";

  function getNumConfig(valueEl) {
    const patch = valueEl.closest('.patch');
    const ds = patch?.dataset || {};
    const step = isFinite(parseFloat(ds.step)) ? parseFloat(ds.step) : 1;
    return {
      min: (ds.min !== undefined && ds.min !== "") ? parseFloat(ds.min) : Number.NEGATIVE_INFINITY,
      max: (ds.max !== undefined && ds.max !== "") ? parseFloat(ds.max) : Number.POSITIVE_INFINITY,
      step,
      smallStep: isFinite(parseFloat(ds.smallStep)) ? parseFloat(ds.smallStep) : step / 10,
      bigStep:   isFinite(parseFloat(ds.bigStep))   ? parseFloat(ds.bigStep)   : step * 10,
      fallback:  isFinite(parseFloat(ds.fallback))  ? parseFloat(ds.fallback)  : 0,
      precision: Number.isInteger(parseInt(ds.precision, 10)) ? parseInt(ds.precision, 10) : 0
    };
  }

  function clamp(v, lo, hi) {
    if (Number.isFinite(lo)) v = Math.max(lo, v);
    if (Number.isFinite(hi)) v = Math.min(hi, v);
    return v;
  }

  function roundToPrecision(v, precision) {
    if (!Number.isInteger(precision) || precision < 0) return v;
    const f = Math.pow(10, precision);
    return Math.round(v * f) / f;
  }

  /* Align to nearest step from min (or 0 if min is -Infinity) */
  function quantizeToStep(v, step, min) {
    if (!isFinite(step) || step <= 0) return v;
    const origin = Number.isFinite(min) ? min : 0;
    return origin + Math.round((v - origin) / step) * step;
  }

  function displayNumber(valueEl, v) {
    const cfg = getNumConfig(valueEl);
    const out = roundToPrecision(v, cfg.precision);
    valueEl.textContent = cfg.precision > 0 ? out.toFixed(cfg.precision) : String(out);

    // Sync slider if present
    const slider = valueEl.closest('.num-body')?.querySelector('.num-slider');
    if (slider) slider.value = out;
  }

  function currentNumber(valueEl) {
    const t = valueEl.textContent.trim();
    const n = parseFloat(t);
    return isFinite(n) ? n : getNumConfig(valueEl).fallback;
  }

  function beginNumericEdit(targetEl) {
    numEditActive = true;
    numEditBuffer = "";
    numPrevText   = targetEl.textContent;
    targetEl.classList.add('editing');
  }

  function commitNumericEdit(targetEl) {
    const cfg = getNumConfig(targetEl);
    let n = parseFloat(numEditBuffer);
    if (!isFinite(n)) {
      const prev = parseFloat(numPrevText);
      n = isFinite(prev) ? prev : cfg.fallback;
    }
    n = clamp(n, cfg.min, cfg.max);
    n = quantizeToStep(n, cfg.step, cfg.min);
    displayNumber(targetEl, n);

    numEditActive = false;
    numEditBuffer = "";
    numPrevText   = "";
    targetEl.classList.remove('editing');
  }

  function cancelNumericEdit(targetEl) {
    targetEl.textContent = numPrevText;
    numEditActive = false;
    numEditBuffer = "";
    numPrevText   = "";
    targetEl.classList.remove('editing');
  }

/* Approximate the knob center in page coords based on current slider value */
function sliderKnobCenter(sliderEl) {
  const r   = sliderEl.getBoundingClientRect();
  const min = isFinite(+sliderEl.min)  ? +sliderEl.min  : 0;
  const max = isFinite(+sliderEl.max)  ? +sliderEl.max  : 100;
  const val = isFinite(+sliderEl.value)? +sliderEl.value: min;
  const t   = (max === min) ? 0 : (val - min) / (max - min);
  const x   = r.left + window.scrollX + t * r.width;
  const y   = r.top  + window.scrollY + r.height / 2;
  return { x, y };
}

/* Draw/update a bracket “]” from knob to the cursor */
function updateSliderBracket(sliderEl, mouseX, mouseY) {
  const p0 = sliderKnobCenter(sliderEl);             // knob
  const p1 = { x: mouseX + window.scrollX, y: mouseY + window.scrollY };

  if (!sliderBracketPath) {
    sliderBracketPath = new paperScope.Path({ strokeColor: '#ffc107', strokeWidth: 2 });
  } else {
    sliderBracketPath.removeSegments();
  }

  const h = 10; // half-height of the bracket “post”
  sliderBracketPath.moveTo(new paperScope.Point(p0.x, p0.y - h));
  sliderBracketPath.lineTo(new paperScope.Point(p0.x, p0.y + h));
  sliderBracketPath.lineTo(new paperScope.Point(p1.x, p1.y));
  paperScope.view.update();
}

window.startSliderDrag = function startSliderDrag(sliderEl, mouseX) {
  const r    = sliderEl.getBoundingClientRect();
  const min  = isFinite(parseFloat(sliderEl.min))  ? parseFloat(sliderEl.min)  : 0;
  const max  = isFinite(parseFloat(sliderEl.max))  ? parseFloat(sliderEl.max)  : 100;
  const step = isFinite(parseFloat(sliderEl.step)) ? parseFloat(sliderEl.step) : 1;

  sliderDragLock  = true;
  sliderDragEl    = sliderEl;
  sliderDragStart = {
    x: mouseX,
    value: isFinite(parseFloat(sliderEl.value)) ? parseFloat(sliderEl.value) : min,
    min, max, step,
    width: r.width
  };
  sliderEl.classList.add('dragging');

  // Install a window-level mousemove just for this drag session
  sliderMoveListenerRef = (e) => {
    const dx = e.clientX - sliderDragStart.x;
    const range = sliderDragStart.max - sliderDragStart.min;
    const unitsPerPx = (sliderDragStart.width > 0) ? (range / sliderDragStart.width) : 0;

    let next = sliderDragStart.value + dx * unitsPerPx;
    // reuse your existing helpers
    next = clamp(next, sliderDragStart.min, sliderDragStart.max);
    next = quantizeToStep(next, sliderDragStart.step, sliderDragStart.min);

    // Update slider and synced numeric display
    sliderDragEl.value = String(next);
    sliderDragEl.dispatchEvent(new Event('input', { bubbles: true })); // ensure visuals & bindings

    // Update bracket path
    updateSliderBracket(sliderDragEl, e.clientX, e.clientY);
  };

  window.addEventListener('mousemove', sliderMoveListenerRef);
  // Draw initial bracket
  updateSliderBracket(sliderEl, sliderDragStart.x, sliderKnobCenter(sliderEl).y - window.scrollY);
};

window.stopSliderDrag = function stopSliderDrag() {
  if (!sliderDragLock) return;
  sliderDragLock  = false;

  if (sliderMoveListenerRef) {
    window.removeEventListener('mousemove', sliderMoveListenerRef);
    sliderMoveListenerRef = null;
  }
  if (sliderBracketPath) {
    sliderBracketPath.remove();
    sliderBracketPath = null;
    paperScope.view.update();
  }
  if (sliderDragEl) sliderDragEl.classList.remove('dragging');

  sliderDragEl    = null;
  sliderDragStart = null;
};



  // Hover tracking independent of other handlers
  const patchArea = document.getElementById('patchArea');
  patchArea.addEventListener('mousemove', (e) => {
    const maybeVal = document.elementFromPoint(e.clientX, e.clientY)?.closest('.num-value');

    if (hoverNumEl !== maybeVal) {
      if (hoverNumEl) hoverNumEl.classList.remove('hover');

      // Leaving an editing field commits/reverts based on validity
      if (numEditActive && hoverNumEl && hoverNumEl !== maybeVal) {
        commitNumericEdit(hoverNumEl);
      }

      hoverNumEl = maybeVal || null;
      if (hoverNumEl) hoverNumEl.classList.add('hover');
    }
  });

  // Key handling: brackets + type-on-hover
  document.addEventListener('keydown', (e) => {
    // Bracket increments
    if (e.code === 'BracketLeft' || e.code === 'BracketRight') {
      const target = hoverNumEl || document.querySelector('.num-value.editing');
      if (target) {
        const cfg  = getNumConfig(target);
        const base = currentNumber(target);

        let delta = cfg.step;
        if (e.shiftKey) delta = cfg.bigStep;
        else if (e.altKey || e.metaKey) delta = cfg.smallStep; // Option on macOS

        if (e.code === 'BracketLeft') delta = -delta;

        let next = base + delta;
        next = clamp(next, cfg.min, cfg.max);
        next = quantizeToStep(next, cfg.step, cfg.min);
        displayNumber(target, next);

        e.preventDefault();
        return;
      }
    }

    // Type-on-hover editing
    const isEditingKey =
      (e.key.length === 1 && /[0-9.\-]/.test(e.key)) ||
      e.key === 'Backspace' || e.key === 'Delete' ||
      e.key === 'Enter'     || e.key === 'Escape';

    if ((hoverNumEl || numEditActive) && isEditingKey) {
      const target = hoverNumEl || document.querySelector('.num-value.editing');
      if (!target) return;

      e.preventDefault();
      if (!numEditActive) beginNumericEdit(target);

      if (e.key === 'Enter')    { commitNumericEdit(target); return; }
      if (e.key === 'Escape')   { cancelNumericEdit(target); return; }
      if (e.key === 'Backspace'){ numEditBuffer = numEditBuffer.slice(0, -1); }
      else if (e.key === 'Delete') { numEditBuffer = ""; }
      else { numEditBuffer += e.key; }

      // Show live buffer (validation occurs on commit)
      target.textContent = numEditBuffer;
      return;
    }
  });

  // Bind slider to numeric text
  function bindSliders() {
    document.querySelectorAll('.patch.slider-numeric').forEach(patch => {
      const slider  = patch.querySelector('.num-slider');
      const valueEl = patch.querySelector('.num-value');
      if (!slider || !valueEl) return;

      const cfg = getNumConfig(valueEl);
      if (Number.isFinite(cfg.min))  slider.min  = String(cfg.min);
      if (Number.isFinite(cfg.max))  slider.max  = String(cfg.max);
      if (Number.isFinite(cfg.step)) slider.step = String(cfg.step);

      slider.addEventListener('input', () => {
        let v = parseFloat(slider.value);
        v = clamp(v, cfg.min, cfg.max);
        displayNumber(valueEl, v);
      });
    });
  }

  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', bindSliders);
  } else {
    bindSliders();
  }
})();

/* ------- Min/Max labels inside numeric patches ------- */
(function addMinMaxLabels() {
  function fmt(n, precision) {
    if (!Number.isFinite(n)) return null;
    return (Number.isInteger(precision) && precision > 0)
      ? n.toFixed(precision)
      : String(n);
  }

  const patches = document.querySelectorAll('.patch.numeric, .patch.slider-numeric');
  patches.forEach(patch => {
    const ds = patch.dataset || {};
    const min = parseFloat(ds.min);
    const max = parseFloat(ds.max);
    const precision = Number.isInteger(parseInt(ds.precision, 10))
      ? parseInt(ds.precision, 10)
      : 0;

    const minText = `min: ${fmt(min, precision)}`;
    const maxText = `max: ${fmt(max, precision)}`;

    // If neither is finite, don’t show a labels row
    if (minText === null && maxText === null) return;

    const body = patch.querySelector('.num-body');
    if (!body) return;

    // Create the row once
    let rangeRow = patch.querySelector('.num-range');
    if (!rangeRow) {
      rangeRow = document.createElement('div');
      rangeRow.className = 'num-range';

      const minSpan = document.createElement('span');
      minSpan.className = 'num-min';

      const maxSpan = document.createElement('span');
      maxSpan.className = 'num-max';

      rangeRow.appendChild(minSpan);
      rangeRow.appendChild(maxSpan);
      body.appendChild(rangeRow);
    }

    const minEl = rangeRow.querySelector('.num-min');
    const maxEl = rangeRow.querySelector('.num-max');
    if (minEl) minEl.textContent = minText ?? '';
    if (maxEl) maxEl.textContent = maxText ?? '';
  });
})();

/* Style a cable path according to its disabled/hover state */
function styleCable(conn, hover = false) {
  if (!conn || !conn.path) return;
  const p = conn.path;

  if (hover) {
    p.strokeColor = '#895010';
    p.strokeWidth = 5;
    p.dashArray   = conn.disabled ? [6, 4] : null;   // keep dashed when hovered if disabled
  } else {
    p.strokeColor = conn.disabled ? '#bbb' : '#333'; // light gray when disabled
    p.strokeWidth = 2;
    p.dashArray   = conn.disabled ? [6, 4] : null;
  }
}

/* Unique id for new patches */
function generatePatchId(base = 'patch') {
  return `${base}-copy-${Date.now().toString(36)}-${patchIdCounter++}`;
}

/* Duplicate a patch and place its center at (pageX, pageY) */
function duplicatePatchAt(srcPatch, pageX, pageY) {
  if (!srcPatch) return null;

  const clone = srcPatch.cloneNode(true);
  clone.classList.remove('selected', 'dragging'); // keep collapsed state if any

  // Ensure a unique data-id
  const base = srcPatch.dataset?.id || 'patch';
  clone.dataset.id = generatePatchId(base);

  // Position so the clone's center lands at (pageX, pageY)
  const r = srcPatch.getBoundingClientRect();
  const w = r.width, h = r.height;
  clone.style.left = (pageX - w / 2) + 'px';
  clone.style.top  = (pageY - h / 2) + 'px';

  // Insert into patch area
  patchArea.appendChild(clone);

  // If this is a slider+numeric patch, bind the slider to its numeric value
  const valueEl = clone.querySelector('.num-value');
  const slider  = clone.querySelector('.num-slider');
  if (valueEl && slider && typeof getNumConfig === 'function') {
    const cfg = getNumConfig(valueEl);
    if (Number.isFinite(cfg.min))  slider.min  = String(cfg.min);
    if (Number.isFinite(cfg.max))  slider.max  = String(cfg.max);
    if (Number.isFinite(cfg.step)) slider.step = String(cfg.step);
    slider.addEventListener('input', () => {
      let v = parseFloat(slider.value);
      v = clamp(v, cfg.min, cfg.max);
      displayNumber(valueEl, v);
      window.updateCvReceivers?.();
    });
  }

  // If you auto-insert min/max labels, re-run your helper here if needed
  // window.addMinMaxLabels?.(clone);

  window.updateCvReceivers?.();
  return clone;
}
</script>
</body>
</html>
