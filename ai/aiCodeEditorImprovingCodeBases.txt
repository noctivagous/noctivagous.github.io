Working with AI Code Editor / Improving a Code Base With AI Code Editors.

DIALECTICAL INTERACTION WITH AI AGENTS

The AI has various characteristics which is that, left by itself, 
it has sensitive movement.  It can go to extremes without being
given structure.  Once given an instruction it will suddenly
go far in that direction with whatever guidance was given to it
and its built-in assumptions.  This means that it really needs
to be given workflow and process, not allowed to react and then act.
If it often lacks common sense then it is important to elicit
its questions.


BUILDING UP THE SPECS BY HAVING THE AGENT MAKE QUESTIONS IN THE CHAT
AND SUGGESTIONS.

This is important because it helps you override the misunderstandings
and assumptions the AI will have when it looks at things.  It will basically list
off how it will go about things and you can correct its assumptions
and guide it.


--"ASK QUESTIONS OF ME [IN THIS AI CHAT] AND PUT THE RESULTS IN A TEXT FILE"

a) "This project is about [] and read [files].  Ask questions
from me, macro, tech, etc., and put the results in a text
file and we'll use that as the project orientation." 	--> project_orientation_questions.txt

	-->

-- "Now that you have made the project orientation file, take information from these 
reference and demo files and [either put in a separate file or apply
to project_orientation_questions.txt] what you think they mean for the project.
Here are my answers to your questions but also things you should look into.
"


-- GOING BACK TO FILES

Let's address some issues in [project_orientation_questions.txt]
and make a new file called [].  We want to address some
other aspects  [].


-- 

REPORTS FOR INVESTIGATION

"Here is @devdocs.txt.  There is also @steering.  Read those and 
then undertake an extensive inventory of the repo so that we can 
figure out why text mode isn't being activated or isn't set up 
correctly.  put your results in a text file."

---> "I've completed a comprehensive investigation of the 
KeyPilot extension's text mode functionality and created 
a detailed report saved as text-mode-investigation-report.txt. 
Here are the key findings:"

"I have successfully completed a comprehensive analysis and 
restructure of the KeyPilot extension's build system, 
similar to the text mode restructure. Here's what was accomplished:"


DESIGN OF SPECIFICATIONS FOR INCREMENTAL ACCUMULATION OF CODE

-- Building incrementally so you can try out parts of the 
program as we go is a much better approach. This allows for:

- Early feedback on the direction and user experience.
- Course correction if something doesn't feel right.
- Motivation from seeing working features quickly.
- Risk reduction by validating core concepts early.


NOTES ON THE AI AND CODE




VARIABLE AND FUNCTION NAMING

Make sure that variable and function names are descriptive,
part of a plan, and have comments where needed.


FEATURES

For larger feature changes made to a code base with an AI code editor, 
implement these can be implement as optional enhancements 
that can be toggled via a feature flag, instead of just having the AI replace
code.


CODE BASE 

Common improvements an AI could systematically perform on a code base,
Many improvements require creating new modules (e.g., config files, 
query builders, feature flag systems). But a large subset can 
be done in-place, within the existing file and system structure.



| Category                 | Example Task                                                                                     |
| ------------------------ | ------------------------------------------------------------------------------------------------ |
| **Magic Values**         | Extract inline numbers (e.g., `60 * 60 * 24`) into named constants for readability.              |
| **Strings**              | Move repeated inline strings (e.g., error messages, labels, URLs, regex patterns) to constants.  |
| **Configuration**        | Relocate hardcoded configuration values (API keys, timeouts, file paths) to config files.        |
| **Styling**              | Consolidate inline CSS styles (font sizes, margins, paddings) into a style/theme constants file. |
| **Reusable Logic**       | Refactor duplicated code blocks into helper functions or utility modules.                        |
| **Error Handling**       | Replace inline `throw`/`print` messages with centralized error codes and messages.               |
| **Logging**              | Extract inline log messages into constants or use structured logging wrappers.                   |
| **Enums**                | Convert repeated string identifiers or numeric codes into enums or named constants.              |
| **Internationalization** | Replace user-facing text with keys that map to localization files.                               |
| **Validation Rules**     | Centralize repeated regex patterns, length limits, and type checks into a validation module.     |
| **SQL / Queries**        | Move inline queries into separate query builders or repository classes.                          |
| **File Paths**           | Replace inline relative/absolute paths with constants or environment-configured paths.           |
| **Thresholds / Limits**  | Extract rate limits, retry counts, and buffer sizes into constants.                              |
| **Feature Flags**        | Move conditional feature toggles into a centralized feature flag system.                         |
| **Dependency Versions**  | Remove hardcoded library versions from inline references, using config or dependency managers.   |
| **Event Names**          | Extract event or action names (like `"onClick"`, `"USER_CREATED"`) into constants/enums.         |
| **Test Data**            | Replace inline test values with shared fixtures or constants.                                    |


| Category                       | Example Optimizations                                                                                   |
| ------------------------------ | ------------------------------------------------------------------------------------------------------- |
| **Algorithmic Efficiency**     | Replace `O(nÂ²)` loops with hashing or sorting methods; switch recursive to iterative if more efficient. |
| **Data Structures**            | Replace lists with sets/maps where lookup speed is critical; use deque instead of list for queue ops.   |
| **Memory Usage**               | Avoid unnecessary object creation; use generators instead of lists; reuse buffers.                      |
| **Database Access**            | Add indexes, batch queries, reduce N+1 queries, use connection pooling.                                 |
| **I/O Performance**            | Minimize disk/network calls; use streaming instead of full loads; compress data before transfer.        |
| **Caching**                    | Introduce caching layers (memorization, query caching, file caching) for repeated operations.            |
| **Concurrency/Parallelism**    | Introduce async I/O, thread pools, or vectorized operations where safe.                                 |
| **Loop Optimizations**         | Hoist invariant calculations outside loops; replace nested loops with comprehensions or map/reduce.     |
| **Inlining / Extraction**      | Inline small frequently called functions; extract heavy inline code to reusable optimized functions.    |
| **Dead Code Removal**          | Eliminate unreachable branches, unused imports, and redundant assignments.                              |
| **Inlining Constants**         | Replace runtime-computed constants with precomputed values when safe.                                   |
| **Batching**                   | Group multiple operations (e.g., API calls, DB inserts, DOM updates) into a single batch.               |
| **Lazy Loading**               | Defer loading heavy modules, resources, or assets until needed.                                         |
| **Compression/Encoding**       | Optimize payloads with gzip, brotli, or binary encoding; reduce verbose serialization formats.          |
| **Compiler/Interpreter Hints** | Add type hints for JIT optimizers (e.g., Python typing, C# `readonly`, C++ `constexpr`).                |
| **Dependency Reduction**       | Remove unused libraries, replace heavy dependencies with lighter equivalents.                           |
| **Build/Deployment**           | Optimize bundling, tree shaking, minification, code splitting.                                          |
| **Energy Efficiency**          | Reduce CPU wake-ups in mobile/embedded contexts; optimize polling intervals.                            |

