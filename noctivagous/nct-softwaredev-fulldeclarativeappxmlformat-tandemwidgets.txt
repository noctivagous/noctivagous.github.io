
TANDEM WIDGETS

- Matching widgets on server scripts and client pages
that can talk to each other.

- Matching stock components for server and client sides 
for lists, tables, image galleries, etc.  

Because the server widget has conventions built in for
receiving commands from client widget and the client
widget has commands for talking to server, as
well as either periodic timers or observers for updates both ways,
the situation is more effortless for the software developer.

  

CLIENT:>
<!-- talks to shelfList list widget with widgetId "shelfList" located
at list1.py -->
<listview-clientwidget src="list1.py" widgetId="shelfList">
</listview-clientwidget>

SERVER:

obj shelfList = ListViewServerWidget(format:[1]); // one level for the list. 
shelfList = ["shelf object 1","shelf object 2"];



FOR DESKTOP/MOBILE SOFTWARE

We are doing this for the web, but we can discuss how this would apply to desktop software, with the object classes inside the program's code conforming to a widget protocol (what would be the "server" side) and then the GUI system would have the equivalent of the "client" for what is in the window.

The window is not controlling the app. Itâ€™s reflecting it.


EXAMPLE WIDGET PROTOCOL

Both server and client widgets conform to a standard interface:

class TandemWidgetProtocol:
    def get_data(self) -> Any
    def set_data(self, data: Any)
    def command(self, name: str, *args)  # e.g. "select", "filter"
    def on(self, event: str, callback)   # e.g. "select", "change"
    def refresh(self)
    def destroy(self)


HISTORICAL REASONS

Widgets are a concept that haven't been applied to server-side scripts
and programs. Then, when they are there, they naturally fit with the client-side
widgets, and the two sides can be designed together and result in pairs 
that talk to each other. With there now being server-side widgets, other configurations are 
possible besides just the tandem client-server widget combination, but this gets
the situation started.

Beyond simple client-server pairs, you can build:

Server-to-Server Widgets: For batch processing or logging.
Client-to-Client Widgets: For collaborative UIs (e.g., shared whiteboard).
Observer Networks: Multiple clients observing one server widget (e.g., a master-detail view).








