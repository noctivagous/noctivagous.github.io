
<!DOCTYPE html>
<html>

<head>


  <style>
    html,
    body {
      margin: 0;
      height: 100%;
    }

    /* Scale canvas with resize attribute to full size*/


    canvas[resize] {
      width: 100%;
      height: 100%;
      cursor: crosshair;
    }



    body {
      margin: 10px;
      padding: 0px;
    }

    body {
      font-size: 2em;
      font-family: 'Franklin Gothic Medium', 'Arial Narrow', Arial, sans-serif;

    }

    #canvas {

      height: 800px;
      background-color: #F8F8F8;

      max-width: 100%;
    }


    #intro {
      padding: 10px;
    }
  </style>



  <script>
    window.addEventListener('keydown', function (event) {
      if (event.key === ' ' || event.key === 'Tab') {
        event.preventDefault();
      }
    });



  </script>
  <!--<script type="text/javascript" src="paper-full.js"></script>-->

  <script type="text/javascript"
    src="https://cdnjs.cloudflare.com/ajax/libs/paper.js/0.12.17/paper-full.min.js"></script>




</head>

<body>

  <div id="intro">

    <h1>The Key-Click UI</h1>
    <p>The key-click UI is an improved software user interface for the desktop computer.

      <br><br>A software program that implements the key-click UI treats the keys
      on a keyboard as click buttons. The mouse buttons are entirely ignored.
      Although this can be explained, before reading further, please try out the vector-drawing demo below.

    <p>
      The concept is that&mdash; and real-world use of the key-click UI has shown&mdash;
      there is currently too much work assigned to an individual hand.
      Compared to the key-click UI, the hand is currently burdened.
      It has to do two things at once: coordinate the position of the cursor <i>and</i> click the buttons with the index
      finger.
      In a vector-drawing program, especially, this is too much; the
      standard mouse interface is too simplistic for drawing vectors. Thus, to
      establish a normal situation for
      drawing vectors with a mouse, it's important first to modify the overall interface,
      and that is the key-click UI. It later is applied to other parts of the desktop UI,
      outside of vector-drawing.


      <!--
<p>The key-click UI is not in contradiction with the history of the mouse, as Douglas Engelbart's
  1968 demo of the mouse in fact also featured a .  During the demo, to the left of his keyboard
  he was using a five-key device in tandem with the mouse, which also had click buttons.  
  That five-key device did not make it into personal computers but its essence is the same as the key-click UI.
 </p>
-->



    <p>Separating the click from the mouse divides the labor of
      manipulating cursor activity to two hands instead of one. This leads to a leap in possible dexterity.
      Each hand has been given its own role: the mouse hand just moves the cursor and
      the clicking hand just clicks with keys. This opens up a totally different interactive
      dynamic with the desktop computer, because previously there was never such alternation occuring between
      two hands (move, click, move, click).
    </p>





    <h1 id="drawingDemo" style="margin-bottom: 10px;">Vector-Drawing Demo</h1>
        
        <div style="border: 1px solid black;font-size: 70%;margin-bottom: 10px;margin-top:0px;">
          <div style="padding-left:10px;padding-top:10px;">Move your cursor into the gray area below, then use the following keys.</div>
          <table cellspacing="30">
            <tr><td style="vertical-align: top;">   <h3 style="margin-top: 0px;">DRAWING</h3>
              1. Press the <kbd>F</kbd> key to deposit a point.
              <br /> 2. Move the mouse. <br />
              3. Press the <kbd>F</kbd> key
              again to deposit another point.
              <br />
              <p></p>
              4. Repeat until
              it is desired to press an END key:
              <br/>
              <br/>&nbsp;&nbsp;&nbsp;<kbd>A</kbd> - END the stroke.
              <br/>&nbsp;&nbsp;&nbsp;<kbd>E</kbd> - END and fill the shape.
              <br/>&nbsp;&nbsp;&nbsp;<kbd>R</kbd> - END and stroke the shape.
            
            
            </td>
              
              
              
              <td style="vertical-align: top;">    
                <h3 style="margin-top: 0px;">SELECTING AND DRAGGING</h3>
              1.Select objects with <kbd>Tab</kbd>.  <br/>
          
              2.To drag the selection, turn on the drag-lock with <kbd>SPACEBAR</kbd>.
              <!-- /wp:paragraph -->
              <br/>
              3. Stamp a selection with <kbd>E</kbd>.
              <br/>
              4. Scale a selection down and up  with <kbd>[</kbd> and <kbd>]</kbd>.
              <br/>
              5. Rotate a selection forwards and backwards by 15 degrees with <kbd>;</kbd> and <kbd>'</kbd>.
              <br/>
              6. The <kbd>Esc</kbd> key will also cancel the selection and dragging.

              <h3>STROKE WIDTH</h3>
              1. To thin or thicken the stroke, use <kbd>C</kbd> and <kbd>V</kbd>.  


          </td></tr>
          </table>
       
 
  
  
    </div>

    <div id="canvasContainer">
      
      <canvas id="canvas" resize></canvas>
    </div>

    <!-- wp:html -->
    <style>
      #canvas {
        border: 0px solid #000;
        height: 800px;
        background-color: #cccccc;
        max-width: 100%;
      }

      canvas[resize] {}

      kbd {
        display: inline-block;
        border: 1px solid black;
        border-radius: 3pt;
        padding: 5px;
        background-color: #333;
        color:white;
        font-family:  monospace;
      }
    </style>
    <!-- /wp:html -->

    <!-- wp:html -->
    <script type="text/paperscript" canvas="canvas">

  var globalStrokeWidth = 1.0;
  var maxStrokeWidth = 20.0;
  var isDrawing = false;

  var mousePt;
  var lastMousePt = null;

  var path;
  
var isCapsLockOn = false;
var selectionRect = null;
var selectionRectangleStartPoint = null;
var selectionRectangleEndPoint = null;
var selectedItems = [];


  // Variables to track selected items and drag-lock status
	var selectedItems = [];

  var _isInDragLock = false;

// Create a property with a setter for _isInDragLock

function setIsInDragLock(status) {
  _isInDragLock = status;
  updateTextContent();
}



var textItem1 = new PointText({
  content: 'Selected Objects: 0\nDrag-Lock: Off',
  point: new Point(10, 40),
  fillColor: "#333333",
  fontSize: '20pt',
  fontWeight: 'bold',
  fontFamily: 'Arial',
        
});



function updateTextContent() {
  var selectedCount = selectedItems.length;
  textItem1.content = 'Selected Objects: ' + selectedCount + '\n';
  textItem1.content += 'Drag-Lock: ' + (_isInDragLock ? 'On' : 'Off');
}

      


      view.onMouseLeave =
      function (event)
      {
        if(isDrawing)
        {
            endShape();
        }

      }
      
      function onMouseMove(event)
      {



        mousePt = event.point;

        
        
        if(isDrawing)
        {

          if(path)
          {
         
            if(path.segments.length == 1)
          {
            path.add(mousePt);


          }

          if(path.segments.length > 1 )
          {
          
            path.removeSegment(path.segments.length - 1);
            path.add(mousePt);

          }
        
         }

        }
        
  

          // Implement drag-lock functionality
          if (_isInDragLock) {
             
            // If lastMousePt is null, initialize it
            if (lastMousePt === null) {
              lastMousePt = mousePt;
            }


            // Calculate the delta
            var delta = mousePt.subtract(lastMousePt);
        

          
        // Apply the delta to the position of all selected items
          for (var i = 0; i < selectedItems.length; i++) {
          selectedItems[i].position = selectedItems[i].position.add(delta);
        }

        // Update lastMousePt for the next onMouseMove event
        lastMousePt = mousePt;

          } else {
            // Reset lastMousePt when drag lock is off
            lastMousePt = null;
          }
          



      }


      function collectiveBounds(selectedItems) {
        var bounds = null;
        for (var i = 0; i < selectedItems.length; i++) {
          if (bounds === null) {
            bounds = selectedItems[i].bounds.clone();
          } else {
            bounds = bounds.unite(selectedItems[i].bounds);
          }
        }
        return bounds;
      }

      // When adding an item to selectedItems
function addItemToSelection(item) {
  item.selected = true;
  selectedItems.push(item);
  //addGlow(item);
}
//
      
      // When removing an item from selectedItems
      function removeItemFromSelection(item) {
        var index = selectedItems.indexOf(item);
        if (index !== -1) {
          item.selected = false;
          selectedItems.splice(index, 1);
          //removeGlow(item);
        }
      }


      function collectiveCenter(selectedItems) {
        var bounds = collectiveBounds(selectedItems);
        return bounds ? bounds.center : new paper.Point(0, 0);
      }



 function onKeyDown(event) {



if (event.key == 'f') {

 polyLineKC();
  
}

/*

if (event.key == 'j') {
  changeStrokeWidth(1);
}
if (event.key == 'k') {
  changeStrokeWidth(2);
}
if (event.key == 'l') {
  changeStrokeWidth(3);
}
if (event.key == ';') {
  changeStrokeWidth(4);
}
*/

if (event.key == 'c') {
  thinStrokeWidth();
}
if (event.key == 'v') {
  thickenStrokeWidth();
}

if (event.key === 'e' && _isInDragLock) {
  stampItems(selectedItems);
}





  if (event.key === '[') {

    var center = collectiveCenter(selectedItems);


    for (var i = 0; i < selectedItems.length; i++) {
      selectedItems[i].scale(0.9, center);
    }
  }

  if (event.key === ']') {

    var center = collectiveCenter(selectedItems);


    for (var i = 0; i < selectedItems.length; i++) {
      selectedItems[i].scale(1.1, center);
    }
  }

  if (event.key === ';') {

    var center = collectiveCenter(selectedItems);

    for (var i = 0; i < selectedItems.length; i++) {
      selectedItems[i].rotate(-15, center);
    }
  }

  if (event.key === "'") {

    var center = collectiveCenter(selectedItems);

    for (var i = 0; i < selectedItems.length; i++) {
      selectedItems[i].rotate(15, center);
    }
  }

  if (event.key === 'backspace') {
    for (var i = selectedItems.length - 1; i >= 0; i--) { // Loop in reverse to avoid array index issues
      var item = selectedItems[i];
      removeItemFromSelection(item); // Assuming you have a function to remove the glow and other selection properties
      item.remove(); // This removes the item from the Paper.js project
    }
    selectedItems = []; // Clear the selection array
  }


if(isDrawing)
{
// close and end shape
if( event.key == 'r'){

  closeShapeAndEnd();
}

// close and end shape
if( event.key == 'e'){
  closeShapeAndEndWithFill();


}

// close and end shape
if( event.key == 'a'){
  endShape();


}

}



  // Tab key for selecting object under cursor
  if (event.key === 'tab') {
    // Hit test to find object under cursor
    var hitResult = project.hitTest(mousePt);

    if (hitResult && hitResult.item) {
      // Check if this item is already selected
      var alreadySelected = selectedItems.indexOf(hitResult.item) !== -1;

      if (alreadySelected) {
        hitResult.item.selected = false;
        selectedItems.splice(selectedItems.indexOf(hitResult.item), 1);
      } else {

        addItemToSelection(hitResult.item);
        //hitResult.item.selected = true;
        //selectedItems.push(hitResult.item);
      }
    } else {
      // If nothing is underneath the cursor, clear the selection
      clearOutSelection();
    }
  }

  // Spacebar for drag-lock
  if (event.key === 'space' && (selectedItems.length > 0)) {
    setIsInDragLock(!_isInDragLock); // Toggle drag-lock status
  }

  // Escape key for cancelling all
  if (event.key === 'escape') {
    for (var i = 0; i < selectedItems.length; i++) {
      selectedItems[i].selected = false;
    }
    selectedItems = [];
    setIsInDragLock(false);
  }

  updateTextContent();


  
}// END keydown


function clearOutSelection()
{
  // If nothing is underneath the cursor, clear the selection
  for (var i = 0; i < selectedItems.length; i++) {
    selectedItems[i].selected = false;
  }
  selectedItems = [];

}

function changeStrokeWidth(strokeVal)
{
var localStrokeVal = strokeVal;

if(localStrokeVal < 1)
{
  localStrokeVal = 1;
}
if(localStrokeVal > maxStrokeWidth)
{
  localStrokeVal = maxStrokeWidth;
}

globalStrokeWidth = localStrokeVal;

if(path)
{
  path.strokeWidth = localStrokeVal;
}
g
}

function thinStrokeWidth()
{
changeStrokeWidth(globalStrokeWidth - 1);

}

function thickenStrokeWidth()
{
changeStrokeWidth(globalStrokeWidth + 1);
}

// When adding an item to selectedItems
function addItemToSelection(item) {
  item.selected = true;
  selectedItems.push(item);
}


function stampItems(itemsToStamp)
{

  if(itemsToStamp === null)
  {
    return;
  }

  for (var i = 0; i < itemsToStamp.length; i++) {
    var clone = itemsToStamp[i].clone();
    clone.selected = false; // Optionally deselect the clone
    project.activeLayer.addChild(clone);
  }
}


function endShape()
{
if (path) {
   path.selected = false;
   project.activeLayer.addChild(path);

   isDrawing = false;
   path = null;
  }

}

function closeShapeAndEnd()
{

  if (path) {
    path.closed = true;
    path.selected = false;
    project.activeLayer.addChild(path);
    isDrawing = false;
    path = null;
   }

}

function closeShapeAndEndWithFill()
{

  if (path) {
    path.closed = true;
    path.selected = false;
    path.fillColor = new Color(0, 0, 0);
    project.activeLayer.addChild(path);
    isDrawing = false;
    path = null;
   }


}



  function polyLineKC() 
  {

    if(!path)
    {
          // Create a new path and set its stroke color to black:
          path = new Path({
              segments: [mousePt],
              strokeColor: 'black',
              strokeWidth: globalStrokeWidth,
              // Select the path, so we can see its segment points:
              fullySelected: true
          });
      }
      else
      {
        path.add(mousePt);
      }

     if(isDrawing == false)
     {
         isDrawing = true;
      }

  }

      function onMouseDown(event) {

   
      
     }



      // While the user drags the mouse, points are added to the path
      // at the position of the mouse:
      function onMouseDrag(event) {
   
      }

      // When the mouse is released, we simplify the path:
      function onMouseUp(event) {
     
      }



  </script>
    <!-- /wp:html -->

    <p>
      A single vector line can be used by the program as:
    <ul>
      <li>the diameter of a circle.</li>
      <li>the radius of a circle.</li>
      <li>the diagonal of a rectangle.</li>
      <li>the circumradius of a regular polygon.</li>
      <li>etc.</li>
    </ul>
    </p>


    <h1>Implementing Selection And Dragging of Objects in The Key-Click UI</h1>

    <p>


    <h2>The <kbd>Tab</kbd> Key Is Used for The Selection Click</h2>
    <p>

      To select an individual object, you press the
      <kbd>tab</kbd> key, and it is selected immediately underneath the cursor
      as if you had pressed <kbd>shift</kbd>+<kbd>left mouse button</kbd>. The

      <kbd>tab</kbd> key
      selects and de-selects. It is the <i>selection
        click</i>.



    <p>Though any key could be used for this, <kbd>tab</kbd>
      has been chosen because of its location on the keyboard.


      The purpose of assigning <kbd>shift</kbd>+<kbd>left mouse button</kbd>
      to the <kbd>tab</kbd> key is that the key-click UI works better with the <kbd>shift</kbd> modifier for selections
      most of the time. For one, it is far easier to select multiple objects at a time with the key-click UI, so
      <kbd>shift</kbd> is implemented.
      Tweaks and modifications like this are needed to make the key-click UI translate existing conventions.
      Just like before, clicking outside of the selection de-selects everything.
    </p>

    <h2>The <kbd>Spacebar</kbd> Implements a Drag-Lock on The Current Selection</h2>
    <p>
      In a convention specific to the key-click UI, the <kbd>tab</kbd> key has been paired with the <kbd>spacebar</kbd>
      key to move objects around the screen.

    <p>
      To drag an object, you press
      the <kbd>spacebar</kbd> key after the object has been selected (using <kbd>tab</kbd> click), and the
      object moves in lock step with the cursor. In other words, this is a drag lock, affixing objects to the
      cursor relative to their position at the time of the drag lock. To release the drag lock, press the
      <kbd>spacebar</kbd> key again
      and then the objects are left at their location.

    <p>
      For ease of providing terminology this is called a drag-lock, but it is also called
      "carting" by Noctivagous, in place of "dragging". It is named as such because a cart moves its contents
      briskly using wheels on the ground whereas the dragging of something on the ground makes lots of noise.
      That is the degree of UI improvement that carting provides.
    </p>

    <h2>The <kbd>Escape</kbd> Key Cancels All Drag Locks And Selections</h2>

    <p>If the <kbd>Escape</kbd> is pressed and there is any drag lock occurring, it will
      be turned off. The current selection will be canceled as well.
      Using the <kbd>Escape</kbd> for this is not only a convenience, it fits into the whole
      of using of the keyboard to click when using the key-click UI.</p>


    <h2>The Opportunities That Arise When The Drag Lock Is Used</h2>

    <p>Moving objects around on screen is very smooth when a drag lock is
      used in the way described above. But in addition to this, it provides
      opportunities to operate with the selection or apply functions to it.
    </p>

    <p>In a vector-drawing program, the selection is be scaled up or down with
      the bracket keys (<kbd>[</kbd> and <kbd>]</kbd>).

      The two keys below the bracket keys (<kbd>;</kbd> and <kbd>'</kbd>)
      rotate the selection by an increment of 15 degrees clockwise and counterclockwise.

      The selection can be stamped
      with the <kbd>E</kbd> key. So this means that transformed copies of
      the dragged selection can occur in real time. This is how Floating Marker works.

    </p>

    <!--For example, in a desktop user interface, if the <kbd>K</kbd> key
is used for copying an object into multiple folders.</p>-->





  </div>

</body>

</html>