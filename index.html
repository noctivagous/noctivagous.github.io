
<html>
    <head>

      <meta charset="UTF-8">
  
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
     
      <meta http-equiv='cache-control' content='no-cache'> 
<meta http-equiv='expires' content='0'> 
<meta http-equiv='pragma' content='no-cache'>

<style>
  /* You can add any additional styles here */
  .non-link {
      pointer-events: none;
      cursor: default;
      text-decoration: none;
      color: inherit;
  }

  h3{ text-transform: capitalize;
</style>

        <link href="https://fonts.googleapis.com/css2?family=Source+Sans+Pro:wght@400&display=swap" rel="stylesheet">


<style>
body
{
font-size:2em;
font-family: 'Arial Narrow', Arial, sans-serif;

}

p {
color:#333;
text-align: justify;
font-weight:normal;
}

h1
{
    font-family:'Franklin Gothic Medium', 'Arial Narrow', Arial, sans-serif;

}
 

h2,h3,h4,h5,h6
{
font-family: Arial, Helvetica, sans-serif;
color:#333;
margin-top: 2.5em;

}

h2{
margin-top: 3em;

}

</style>

<style>

code, pre {
font-family: 'Source Sans Pro','Menlo', Courier,monospace;
color:#ccff33;
font-size: :16px;
margin:0px;

}
p code, h3 code, li code{
font-family:Courier,monospace;
}


.ideCodeArea code, .ideCodeArea code pre
{
font-size:20px;
}

.ideCodeArea
{
font-family:'Source Sans Pro','Menlo', courier, courier new, monaco;
	background-color:gray;
	padding:10px;
   color:#ccff33;
   
   margin-top:60px;
   margin-bottom:60px;
  box-shadow: 5px 5px 5px #222;
border-right:1px solid #333;
border-bottom:1px solid #333;
margin-right:40px;
font-size:20px;
}
.editableTextAreaDiv
{
	background-color:#333;
	width:100%;
	border:2px solid black;
	padding-left:6px;
	outline: none;
}

div.editableTextAreaDiv:hover
{
	background-color:#555;
	border:4px solid black;
}

span.codeInText
{
	font-size:1em;
	font-family:monospace;
	color:#336600;
}

span.codekeyword{
	color:#ff3399;
}


.funcSignatureStyling
{
color:#ccff33;

}

.funcKeywordStyling{
color:orange;
}

.commentsKeywordStyling{
color:#6600cc;
}

.commentsKeywordStyling2{
color:#9966ff;
}


.variableKeywordStyling{
color:#993333;
}

.variableNameStyling{
color:lightGreen;
}

.code{
	font-family:'Source Sans Pro','Menlo', courier, courier new, monaco;
	font-size:16px;
	
}

kbd {
	font-family:'Source Sans Pro','Menlo', courier, courier new, monaco;
	color:white;
	font-size:17px;
	padding:3px;
	padding-top:2px;
	padding-bottom:2px;
	border:1px solid gray;
	border-radius:5px;
	background-color:#bbb;
	  box-shadow: 2px 2px grey;
	  margin-right:3px;

}



/* Style the tab */
.tab {
  overflow: hidden;
  border-bottom: 1px solid #333;
  
  
}

/* Style the buttons inside the tab */
.tab button {
  background-color: #555;
  margin-top:3px;
  margin-right:3px;
  float: left;
  border: none;
  outline: none;
  cursor: pointer;
  padding: 14px 16px;
  transition: 0.3s;
  font-size: 17px;
  color:orange;
  font-weight:bold;
  font-family:'Source Sans Pro','Menlo',Courier;
  border-right:1px solid black;
  font-weight:normal;
  border-top-left-radius	:10px;
}

/* Change background color of buttons on hover */
.tab button:hover {
  background-color: #333;
}

/* Create an active/current tablink class */
.tab button.active {
  background-color: #111;
}
.tabcontent h3{
margin-top:0px;
padding-top:0px;

}

.tab button.tablinks2{color:lightBlue}

/* Style the tab content */
.tabCContainer {
	font-family:'Source Sans Pro','Menlo',Courier;
  display: none;
  margin-top:0px;
  border: 2px solid #333;
  /*border-bottom: 3px solid #333;*/
  
  font-size:14pt;
/*  background-color:#555;*/

}

.tablinks4a.active, .tablinks2.active{
background-color: black;
}

.tabCContainer.navgridtabcontent
{
border:0px;
}


.tabCContainer.navgridtabcontent .tabCContainer
{
background-color:#111;
padding-top: 10px;
padding-bottom: 10px;
}


.tabcontent2 {
padding-top:10px;
padding-bottom:10px;
}

.tabContentCodeArea
{
height:400px;

}

.tabContentCodeArea:focus 
{ 
    outline: none; 
} 

</style>

<style>
li{
padding-top:1em;
}

ol li{
font-weight:bold;
}

ol li ol li{
font-weight:normal;
}

</style>
    </head>
    <body  onload="disableHashLinks()">




<div style="width:90%;max-width:1200px;margin:auto;">


<!--  <h1>Code Editor Features With Web Demos</h1>-->



<!--
<p>
  <iframe width="560" height="315" src="https://www.youtube.com/embed/WFm77oOqzp0" title="YouTube video player" 
  frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; 
  picture-in-picture; web-share" allowfullscreen></iframe>


</p>
-->


<h2>NOCTIVAGOUS</h2>


<img src="img/nct_header4.svg" width="100%">

<h1>Introduction</h1>



<p>
  Though AI is currently introducing a new paradigm to the world, 
  there is still much about computers that needs to be upgraded. 
  First, computer code files should be made out of structured data. 
  Code files are still stored and processed as plain text. In 
  practice, this is utilized in modern software development as if 
  it provides structured data even though it does not. All recent 
  trends in software engineering are moving in this direction, 
  which is the modernization of code without carrying it out in 
  a deliberate way. The code notebook programs (e.g. Jupyter Notebook) 
  intended for developing AI place the Python programming language 
  into an interactive format to provide a dynamic input prompt 
  with graphical output, but this is actually just a usable hack; 
  Python itself has not been upgraded to function like this, and it 
  doesn't normally support this usage.  All the same, after this upgrade
  to code was made, the interactive code notebook became 
  an essential tool of the AI industry.
  
  
  <p>
    Meanwhile, in mainstream software development, IDEs are increasingly 
    providing enhancements to code that improve its interactive capabilities
     and provide greater control. But to do this, they project 
     non-existent structure onto the code for the benefit of user 
     interaction: they analyze it constantly in the background to make 
     collapsible code sections with arrow controls, 
     dropdown menus of the file's contents, and code completion popovers. 
     This shows that regular IDEs have begun to treat 
     a single file of code (.TXT) as a conventional application document 
     but this phenomenon is happening in an unrecognized 
     way. The IDEs undertake user interface gymnastics with this stream
      of ASCII characters to implement the code features just mentioned. 
      In actuality, the most honest picture of how code exists is available 
      by opening it up in a basic text editor like Microsoft's Notepad. 
      Everything else code can offer the software engineer that is interactive
      is actually a hack, including keyword coloring (code, of course, provides no coloring 
       markup in the plain text file data).

<p>
  Many benefits will emerge when code is finally converted to a formal document format
  from the ground up, including a leap in parseability by the compilers and the IDEs themselves, as 
  they will be parsing structured data like XML instead of plain text.
   Plain text carries much ambiguity for live parsing and so the 
   analyzers are not always accurate; deleting just one curly brace 
   can totally confuse the compiler.  When code is finally translated 
   into a document format, which will support interactivity naturally, 
   the quality of users' experience with code will improve greatly and 
   typos will be preventable that entirely halt compilation (such as 
   deleting a single character). Many features will become feasible, 
   such as the ability to survey a project of code in the form of a
    map or schematics overview.  It will be zoomable just like CAD
   because the code files have formal structure in them. 
   Especially if the code files are made out of XML, 
   the ability to add attributes to the underlying markup will 
   take computer programming languages to a new level.
    A function will not just show up in the markup as
    &lt;function&gt; but allow the insertion of custom attributes inside the &lt;function&gt; XML element 
      that provide for much broader configuration, rendered for the programmer in the IDE.
       In addition, an individual line of code will be more powerful
        because it can contain more complex statements, 
        made out of graphical components and even allowing 
        interactive controls natively like data tables and tab views.  An object variable will be assignable to a tab view control that has many configuration parameters for that object.
        A spline object variable will be assignable to a spline editor control where it can be edited inside 
       the line of code.


 <p> 
  Resistance to changing the file format of code and modernizing 
  it often comes out of a lack of understanding of the problems 
  that result from keeping .TXT as the file format today, and addressing that 
  starts with some discussion about graphic design.
 For the graphic designer, though not necessarily
  the software engineer, once today's computer code is revealed as completely 
  tied to the rudimentary .TXT file format, all of the feature differences 
  discussed among the programming languages are  
  taking place inside a tiny frame of view, 
  which is what can be typed into the .TXT file format, a sequence of ASCII or Unicode characters.   
The graphic designer knows immediately how limiting this is because the means of dividing information
on the page amounts to manually-typed line breaks and whitespace and nothing more. 
  Consider that in some programming languages, functions start and end 
 with the keywords "define" and "end" while in most others (C++, Java, C#) there are beginning and 
 ending curly braces.  To the graphic designer, all of this is using typographic characters 
 to establish box boundaries. The result is a mess of curly braces scattered
 down the page, and the only provided way to keep it tidy is through the tab key.  It's too primitive.
 There is only vertical division of information (line breaks between sections of code) in plain text, 
 and nothing can flow horizontally.
 <p>
 In a programming language that is not constrained by .TXT, there will be no typing out of beginning and 
 ending curly braces just to establish the box boundaries of a body of code.  This a task the software
 engineer shouldn't have to deal with, the maintenance of box boundaries.   
 Instead, the contents of a function (or other code section) will be enclosed in a graphical, bordered box, 
 as the file of text will no longer be .TXT but rendered from a document format (e.g. rendered from XML).
 The bordered boxes (the containers for sections of code) will not only flow vertically as in plain text but 
 will be flowable horizontally at the same time, like how a magazine layout has multiple columns.
 At that point, the focus of the user interface will move away from simple typing to a more complex dynamic.
<!-- Replacing the curly braces will be the modifying, adding, or removing the bordered graphical boxes rapidly (the ones
that enclose the loops, functions, and other bodies of code). -->
 It will involve making use of interactive keyboard commands to control the layout and insertion of code, 
 not typing out '{' or '}', and the IDE will begin to resemble a media production app, like a vector-drawing program or animation program,
 because the code will be modernized; the code document will offer modern software capabilities. 
 The user interface principles will have to be more sophisticated than
 what is currently used for code, which is typing, and so discussed on this page are the key-click UI and
 other user interface concepts such as Noctivagous' npsurfer web browsing extension that demonstrates
 a UI for accessing a certain section of the screen quickly without the mouse. In short,
 future code interactivity should not rely on the mouse unless the mouse is used as part of the key-click UI.
 Reluctance to upgrading code is also frequently a result of apprehension by software engineers
 that the clicking mouse will be the focus instead of the much faster keyboard, which shows its
 strengths in the classic command line interface.

 
 <p>
  The replacement of curly brace characters with bordered boxes brings with it broad-ranging
  opportunities in other areas of code and what a document of code can offer the software engineer,
  including interactive components in a line of code that have a lot of power and configuration built in.
  Promisingly, it opens the possibility of customization of the programming language itself; the ability
  to add features to the code document (through scripting and descriptions) will naturally
  make sense as a feature of programming, far more than if the code is plain text.  The software engineer
  will be able to program his own interactive components that make up a line of code, tailored for his
  own project if necessary.
  <p>
  Just this one change demonstrates how the features of any mainstream programming language are currently
  severely confined to what the .TXT file format provides, as .TXT cannot draw graphical boxes and so it cannot
  draw anything else and is stuck in the early days of mainframe computing.  
  Speaking within the constraints of that primitive file format, it is a debate about what characters should 
  define the bounds of a function (will it be curly braces, line breaks, or keywords?) and all similar
  personal preferences, such as whether a line should end in semicolon.  But that kind of debate
 disappears when it is a graphical box enclosing the contents of a function.  When a line of code
 is rendered from XML it doesn't need to have semicolons terminating it.  Omitting a semicolon or 
 removing a single curly brace won't break the entire project of code, as is currently the case.
 <p>
 Thus, the design decisions that differentiate one programming language from another
  actually just exist within this limited and ubiquitous file format, plain text. 
  Since it is so restrictive, having no structured data inside it and being
  a 1:1 monospaced rendering of the data contents of the file, what is actually the case is that the feature
  differences between programming languages are rather miniscule compared to the open
  vista that a document format will provide.  The
  mainstream programming languages all currently exist within what characters .TXT accepts, but
  a document format will extend far beyond lines of monospaced, typewritten characters.
  A programming language can someday manifest as anything that involves
  a more graphical and interactive dynamic: it can include semiotical diagrams, images,
  multimedia, and a line of code can branch out into multiple lines.  Importantly,
  the organization of the information on the page will finally include graphic design
  layout, with a more compact and readable distribution of information, resulting in 
  far less scrolling.

 </p>

 <p>On another topic in software engineering, the work processes and what dynamic should be emphasized, it's 
  also important to note that many software applications today
  could be written in a live programming environment making use of JIT compilation, but for some
   reason this is only treated by the computing industry as relevant for a web app.  
   Many complex apps written for the web are fully ready for use as soon as "reload" is
   executed in a web browser, and this is in stark contrast to the inconvenience
   of compiling AOT (ahead-of-time compiled) code for equivalent 
   apps in desktop and mobile software development.  
   Something should be done to bring this JIT dynamic into mainstream software engineering
   as the central activity so that at least the software is developed in real time 
   but it can be compiled conventionally for optimization at the very end.
   For instance, a calendar software application is very lightweight for today's computers,
  and there is no reason that an application like that would need to
  be written in code that has to be recompiled after every change.  But the tools offered for
  web development, where live programming is most possible, are too undeveloped to replace
  conventional software engineering.  A calendar app is so lightweight
  that its code and user interface could be written and modified while it is opened, in a situation
  even better than reloading a web page.  
  The mindset of the software engineering community did not catch up
  with the major increase in computing processing power, the gains that were provided to JIT compilers
  as a result, and software applications today are written in a style that 
  is a holdover of the slower machines of the 1990s.  With web apps today, 
  they can be edited and then reloaded immediately, whereas the same app in an
   IDE may take 30 seconds or more to be recompiled.
  Of course, in the 1970s the original goal of Smalltalk-80 was to
  allow the programmer to edit the software in real time and that is what it could do.
  Other programming languages didn't adopt that feature, but now they can more easily than ever.
  For many types of apps, their functionality could
  be assembled and edited by the software engineer live because they
  only have certain functions that are processing intensive.  GUI is always
  lightweight for today's machines, but it wasn't for computers of the 1990s.
  That is why large software applications could be sketched out and filled in during an 
  execution mode.  Many professional apps could have their foundation assembled in
  real time.  Instead, any app has to be rebuilt (recompiled) unless it is a web app
  made out of JavaScript, because JIT code editing
  not been made a priority for mainstream software development.

 </p>

 <p>
 On another topic, the traditional UNIX command line interface also needs an upgrade
because when long sequences of logs and operations occur, they fly by so fast that 
they are completely unreadable, which often makes the situation absurd and pointless.  
Take for example that the command line, the line where commands are entered, is entirely
a vestige of the 1970s screens because it exist as part of the terminal output, 
displayed inside the overall grid of monospaced characters.  Since GUI is available, 
the command line can be separated from the output viewport and made its own
text area, which has been the case for CAD programs for a long time.  Then, what
is the terminal output area?  It no longer has to be confined to a VT100 emulation,
a grid of ASCII characters.  It can be redesigned to include graphics.
</p>

<p>
The command line should at least 
 be upgraded such that graphical progress bars appear inside the terminal window when 
 operations are taking place, and all terminal software should be graphics capable; 
 they should be able to show thumbnails of images inside the terminal window after 
 a command is executed, capable of showing them in a grid while listing a directory for example.
A terminal should be able to play videos too, even 5 at a time simultaneously.  
 Many aspects of the UNIX era should be upgraded.  Addressing the problem of a stream of 
 unreadable logs that quickly passes by: all log entires should declare their category or purpose so they 
 are grouped into boxes as they show up in the terminal.  Moreover, these boxes 
 should appear in multi-column format.  
 
</p>

<p>

</p>


<ol>
  <li>
    <h3>
    <a href="graphicdesignersandcode/">Future Code Requires The Integration of Graphic Design into Software Development Environments</a>
  </h3>

  </li>

    <li>
      <h3>
      Opportunities to Upgrade Computer Code’s Form inside The Editor
    </h3>

    <P style="text-align: center;">
      <img src="img/codeFileFormatUpgrade.webp" width="90%" style="border:1px solid gray"/>
      
          </P>

          
    <p>
      Programming languages designed for application software development are more capable than a few decades
      ago, but not by much. Any progress has occurred inside the plain text file format.
      They haven't been upgraded in a comprehensive way that
      utilizes the new graphical capabilities of computers.  It's all terminal type.
      To give an illustrative example that adds to the two shown above, 
      an object variable should be assignable to an interactive vector field
      in the code editor.  A UI control embedded in a line of code can do much more than alphanumeric type
      in complex situations, across a wide range of subjects.  Instructions can someday be expressed semiotically, even,
      if graphics are embraced as elements inside a line of code.  So far, there has never been
      a semiotical programming language system.
      
      <p>
        When graphics are included, the resulting depth of command over the operations of a computer
      will not be matched by any current sequence of plain text.  Small experiments
      have shown that this is much superior,
      it's just that there are doubts expressed by some over whether it can match the
      speed of editing plain text&mdash; in other words the user interface. We address this here.  What seems like an insurmountable
      obstacle, making graphical code's interface comparable to plain text in editing power, is
      actually a matter of taking a different approach.  In every single case, previous attempts abandoned 
      too much of what was in active use in the practice of programming inside plain text and tried to come up with something foreign, which means
      that the code conventions did not match what people were trying to do when they program.
      Instead, Noctivagous' plan is to gradually add augmentations to plain text as it exists today.  A little bit
      later, code can break free from plain text and sit inside its own document file format.  (Already
      there are movements in this direction with Jupyter Notebook, just not for the code itself, only the output.)
      So, initially it is that UI and widgets additions are allowed inside a line of plain text code,
      just like right now when a color can be assigned to a color picker control. 
      After a color picker has been used in code for a while, it is felt as missing when not available. 
      In this way, graphical widgets and controls won't only be a matter of convenience.  When they
      are placed into code, they will be able to 
      summarize large sequences of computer instructions such that
      no one will want to go backwards to just typing out regular terminal type (monospaced type).
      <!--
          This is a path that makes sense because code's intricacies
      might be difficult to impose from the outside with an artificial scheme.

    -->

      <p>
        The importance of this effort can be explained in the following.
      Producing a competing web browser engine that is as
       complete as Chromium or WebKit can't be done in a short period
      of time, and when this isn't possible it represents a dead end for software
      development.  Those two software projects will never be unseated because
      there is little incentive to surpass them, as what is written from scratch 
      with current programming languages will
      basically end up being the same in outcome.  Even with AI programming
      assistants, this does not change because those engines have reached
      the ceiling of what plain text code will produce without an upgrade.
      
      </p>
      It is possible to escape this dead end and it is by breaking from
      the fusion of computer code to the typewriter.  For a major upgrade to happen,
      alterations like the above image have to occur, because code has to look more like
      the software it produces, not just raw, monospaced type.  It has to be able to express
      complex operations in terms of signs and symbol someday.
       Computer science mindsets that refuse collaboration with graphic design
       won't suffice, then, as software development has stayed inside terminal
       type all this time.
      When code is upgraded, the initial subjects of concern turn out to be different;
      they will have to incorporate graphic design and media design
      principles.  The areas of expertise involved are often outside of what is 
      found in mainstream software engineering discussions.
      
      <p>
      As explained in the articles on this page, the obstacle to a deeper level of
      progress in software development is the confining, primitive offerings of the 
      file format plain text, that it has been stretched far beyond
      its bare capabilities to serve increasingly large and complex needs, blowing past 
      the environment of 1980s and 1990s computing when it formed the programming languages
      still in active use today, like C++, Python, and Java.
      
      This primitive code medium is largely accidental, it doesn't lend itself to a surveyable view, 
      a zoomable map like CAD, and it of course by definition cannot accommodate rich text inside the code
      without odd adaptations.  Since it has so many limitations for today's world, it has to be
      transcended.
    
    <p>
      A collection like an array or 
      dictionary  is still not
      editable by way of a data table GUI control inside a line of code.  Instead, the programmer clumsily
      navigates through commas with the arrow keys.
      In addition to this, future computer code needs to be editable in multiple newspaper-like columns to
      make efficient use of screen space.  Plain text is too raw of a file format for programming software in the 21st century,
      and it doesn't allow inclusion of modern GUI controls for formulating groups of instructions. 
      
    </p>

    <p>Noctivagous starts with the plain text code 
      as programmers work with it today and then adds GUI to that as the first step, continuing
      the trend of exists today where the value of a color variable is controllable by an inline color picker.
      It is believed that later the code file should be transformed into a document file format 
      for truly rich code editing.   Each article below explains these issues.</p>
 
        <ol type="a">
            <li><a href="advancingmoderncodeeditor/">Advancing the Modern Code Editor By One UI Step</a> (Includes Demos)</li>
            <li><a href="#">Computer Code Needs A Document File Format</a></li>
            <li><a href="movingcomputercodeintoadocformat/">Moving Computer Code into a Document File Format</a></li>
        </ol>
    </li>

    <li>
      <h3>The Upgrade of User Interface</h3>
        <ol type="a">
            <li><a href="keyclickui/">The Key-Click UI</a> (Demo)</li>
            <li><a href="#">It’s Difficult for Users to Organize Files on Computers When Provided a Such a Basic File Tree Hierarchy.</a></li>
            <li><a href="#">Connect Some Windows with Node Wires If You Like. Software Applications Now Operate In Isolation From One Another.</a>
            
            <p>Noctivagous will let you wire up application windows as if they are nodes in node-based programming,
               because the input and outputs will be on the back of the window and it can flip around. 
               Different applications will interact with each other, providing their complex features to each other, publishing and receiving 
               data as the user decides. 

            </p>
            </li>
            <li><a href="movingpastios/movingpastios.txt">Moving Past The iOS And Android Touchscreen User Interface</a></li>
        </ol>
    </li>

    <li><h3>AI</h3>
      <ol type="a">
          <li><a href="ai/aifacilitationvstakeover.txt">AI Facilitation of Work Processes Vs. AI Takeover of Human Jobs</a>
          <p>
            Discussing What Should Be The Aim for AI Technology, Using The Example of a Vegetable-Cutting Kitchen Appliance That Is Driven by AI
          </p>
          </li>
      </ol>
  </li>

    <li><h3>Graphics And File Formats</h3>
        <ol type="a">
            <li><a href="#">.NVAD - Noctivagous Vector Authoring. A vector 
              graphics file format that acknowledges aesthetic needs and concerns 
              at the code level.</a></li>
        </ol>
    </li>

</ol>

</div><!-- end container-->




<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>

<script>
  function disableHashLinks() {
      // Get all anchor tags in the document
      const links = document.querySelectorAll('a');
      
      // Loop through each link
      links.forEach(link => {
          if (link.getAttribute('href') === '#') {
              link.removeAttribute('href');
              link.classList.add('non-link');
          }
      });
  }
</script>

</body>
</html>