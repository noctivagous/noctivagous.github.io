<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Patch‑Based Synth Demo – Dual‑Input UI</title>

  <!-- Paper.js for cable overlay -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/paper.js/0.12.17/paper-full.min.js"></script>
  <style>
    html,body{height:100%;margin:0;overflow:hidden;font-family:"Arial",sans-serif;background:#f4f6fa;}
    #patchArea{position:relative;width:100%;height:100%;}

    /* —— Patch block —— */
    .patch{position:absolute;z-index:10;width:170px;background:#fff;border:2px solid #0d6efd;border-radius:6px;
    
    box-shadow: 3pt 3pt 3pt gray;cursor:pointer;user-select:none;}
    .patch header{background:#0d6efd;color:#fff;font-size:0.9rem;padding:4px 8px;border-radius:4px 4px 0 0;}

    /* —— Ports —— */
    .port{width:14px;height:14px;border:2px solid #333;border-radius:50%;display:inline-block;margin:6px;vertical-align:middle;pointer-events:auto;}
    .port.input{background:#ffd7d7;border-color:#c0392b;}
    .port.output{background:#d7ffd9;border-color:#27ae60;float:right;}
    .port.hover{outline:3px solid #f1c40f;}

    /* —— Selection & drag-lock state —— */
    .selected{outline:4pt solid #dc3545 !important;}
    .dragging{opacity:0.7;}

    /* —— Cable canvas overlays patches —— */
    #cablesCanvas{position:absolute;inset:0;z-index:20;pointer-events:none;}
    
    #cablesCanvas {
    display: block; /* Removes any extra space below the canvas */
    width: 100vw;   /* Sets width to 100% of viewport width */
    height: 100vh;  /* Sets height to 100% of viewport height */
}

  </style>
  
  <style>
  /* Light dotted grid for the patch area */
  #patchArea{
    background-image: radial-gradient(circle, rgba(0,0,0,0.15) 1px, transparent 1px);
    background-size: 18px 18px;      /* grid pitch */
  }
  /* Slightly larger pitch on Hi-DPI screens */
  @media (min-resolution: 2dppx){
    #patchArea{ background-size: 24px 24px; }
  }

  /* ─────────── 2. CSS for the instruction bar ─────────── */
 #instructionsBar{
    position:fixed;           /* was: fixed */
    top:0; z-index:40;
    width:100%;
    background:rgba(255,255,255,0.95);
    border-bottom:1px solid #0d6efd;
    padding:6px 12px;
    font-size:1rem;
    font-family:Tahoma;
    line-height:1.5rem;
    pointer-events:none;
    box-shadow:0 2px 4px rgba(0,0,0,.1);
  background:black;
  }
  
  @media (min-width: 800px){      /* applies when width > 650 px */
  #instructionsBar{
    font-size: 1rem;            /* raise from 0.85 rem (≈ 14 px) to 1 rem (≈ 16 px) */
        font-size:1.2rem;
    line-height:1.8rem;
  }
}
  
kbd{
border:1pt solid silver;
border-radius:3pt;
padding:1pt;
text-align:Center;
padding-left:3pt;
padding-right:3pt;
margin-right:3pt;
background:gray;
color:#444;
}

</style>
<style>
  /* Cursor styles for different interaction states */
  #patchArea               { cursor: default;    }
  #patchArea.connecting    { cursor: crosshair;  }
  #patchArea.over-port     { cursor: pointer;    }
  #patchArea.hover-cable   { cursor: pointer;    }
  #patchArea.invalid-connect{cursor: not-allowed;}
  
  
</style>

<style>
#instructions {
  position: absolute;
  top: 10px;
  left: 10px;
  width: 500px;
  bottom:10pt;

  background: rgba(28, 28, 30, 0.95); /* dark semi-opaque */
  border: 1px solid #444;
  border-radius: 6px;
  padding: 12px 16px;
  font-family: sans-serif;
  font-size: 14pt;
  color: #e0e0e0;
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.7);
  z-index: 999;
}

#instructions h3 {
  margin-top: 0;
  font-size: 16px;
  color: #66b0ff;
  border-bottom: 1px solid #555;
  padding-bottom: 4px;
}

#instructions ul {
  padding-left: 20px;
  margin: 6px 0 12px 0;
}

#instructions li {
  margin-bottom: 4px;
  line-height: 1.5;
  color:gray;
  font-family:arial;
}

#instructions kbd {
  display: inline-block;
  background: #333;
  border: 1px solid #666;
  border-radius: 4px;
  padding: 2px 6px;
  font-size: 13px;
  font-family: monospace;
  color: #f0f0f0;
  box-shadow: inset 0 -1px 0 #000;
}

#instructions p {
  margin: 8px 0 4px 0;
  font-weight: bold;
  color: #dddddd;
}

#instructions {
  position: absolute;
  top: 10px;
  left: 10px;
  width: 450px;
	bottom:10pt;
  background: rgba(28, 28, 30, 0.95);
  border: 1px solid #444;
  border-radius: 6px;
  padding: 12px 16px 12px 12px;
    font-size:1.2rem;
    font-family:Tahoma;
    line-height:1.5rem;
  color: #e0e0e0;
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.7);
  z-index: 999;
  overflow: hidden;
}

#instructions .scroll-content {
  height: 100%;
  overflow-y: scroll;
  padding-right: 16px; /* space for fake scrollbar */
  scrollbar-width: none;     /* Firefox */
  -ms-overflow-style: none;  /* IE 10+ */
}
#instructions .scroll-content::-webkit-scrollbar {
  display: none; /* Chrome/Safari */
}

.scrollbar-track {
  position: absolute;
  top: 12px;
  right: 4px;
  width: 6px;
  height: calc(100% - 24px);
  background: #222;
  border-radius: 3px;
}

.scrollbar-thumb {
  width: 100%;
  background: #555;
  border-radius: 3px;
  position: absolute;
  top: 0;
  height: 40px;
  cursor: pointer;
}


</style>
</head>
<body >


<!--
<h3 style="margin:0;color:gray;">Patch/Node Programming GUI Demo</h3>
-->

<div id="instructions">

  <h3>Patch/Node Programming GUI Demo</h3>

  <div class="scroll-content">

  <p><strong>1. Drag-Line (G key)</strong></p>
  <ol>
    <li>Press <kbd>G</kbd> while hovering over a patch to begin a drag-line.</li>
    <li>A dashed line appears from the patch center to your mouse.</li>
    <li>Move the cursor to a new location.</li>
    <li>Press <kbd>G</kbd> again to transport the patch to that location.</li>
  </ol>

  <p><strong>2. Drag Lock (Spacebar)</strong></p>
  <ol>
    <li>Press and hold <kbd>Spacebar</kbd> to drag the patch under the mouse.</li>
    <li>Move the mouse to reposition the patch.</li>
    <li>Release <kbd>Spacebar</kbd> to drop the patch.</li>
  </ol>

  <p><strong>3. Selection (Tab key)</strong></p>
  <ol>
    <li>Hover over a patch and press <kbd>Tab</kbd> to select it.

    	<ul>
		<li>Repeat to make a group selection.</li>
    	<li>The <kbd>Escape</kbd> key will clear the selection, as will
    	pressing <kbd>Tab</kbd> when the cursor is outside of a patch.</li></ul>
    </li>
    <li>After selecting one or more patches, press the <kbd>Spacebar</kbd>
    to begin the drag lock.</li>
  </ol>

  <p><strong>4. Connect Cables (F key)</strong></p>
  <ol>
    <li>Hover over an outlet circle and press <kbd>F</kbd> to start a connection.</li>
    <li>Move the mouse to the other outlet and press <kbd>F</kbd> again to complete.</li>
    <li>Press <kbd>Esc</kbd> at any time to cancel.</li>
  </ol>

  <p><strong>5. Delete Cables (D key)</strong></p>
  <ol>
    <li>Hover over an existing cable and press <kbd>D</kbd> to delete it.</li>
  </ol>

  <p><strong>6. Swap Cable Outlet (S key)</strong></p>
  <ol>
    <li>Hover over an outlet with a connected cable and press <kbd>S</kbd> to detach it.</li>
    <li>Move to a new outlet and press <kbd>S</kbd> again to attach.</li>
  </ol>
  
  <p><strong>7. Tidy Rectangle (T key)</strong></p>
<ol>
  <li>Press <kbd>T</kbd> anywhere on the canvas to start a tidy rectangle outline
  for aligning patches.</li>
  <li>Move the mouse to size the rectangle; all patches intersecting or inside the outline are candidates for alignment.</li>
  <li>Press <kbd>T</kbd> again to tidy the patches:  

<ul>
<li>A <em>wide</em> rectangle aligns them horizontally (same&nbsp;<em>y</em>).  </li>
<li>    A <em>tall</em> rectangle aligns them vertically (same&nbsp;<em>x</em>).</li>
        </ul>
    </li>

  <li>Press <kbd>Esc</kbd> at any time before the second <kbd>T</kbd> to cancel.</li>
</ol>

<p><strong>8. Live Selection Rectangle (Y key)</strong></p>
<ol>
  <li>Press <kbd>Y</kbd> anywhere on the canvas to begin drawing a live selection rectangle.</li>
  <li>Move the mouse to grow or shrink the rectangle diagonally.</li>
	<ul>

  <li>As patches intersect or enter the rectangle, they are automatically selected.</li>
  <li>If a patch exits the rectangle, it is removed from the selection.</li>
  </ul>
  <li>Press <kbd>Y</kbd> again to finalize the selection and remove the outline.</li>
  <li>Press <kbd>Esc</kbd> at any time to cancel the selection rectangle.</li>
</ol>


<br/><br/>
  
    </div>
  
    <div class="scrollbar-track">
    <div class="scrollbar-thumb"></div>
  </div>
  
</div>

<!--

<div style="color:white;margin-left:10pt;">    
    1. To make a selection, hover over a node and press <kbd>Tab</kbd>.
    <br/>
    2. Start dragging the selection by pressing <kbd>Spacebar</kbd> once, then move the mouse. Press <kbd>Spacebar</kbd> again to unlock the dragging.

    <br/>
    3. Connect outlets by hovering over a circle and pressing <kbd>F</kbd>. Then move the mouse.
    While hovering over the other outlet, press <kbd>F</kbd> again.  To cancel, press <kbd>Esc</kbd>.

    <br/>
    4. To delete a cable, hover over it and press <kbd>D</kbd>.
    <br/>
	5. To unhook a cable, to place it on a different outlet, press <kbd>S</kbd> while hovering 
	over the outlet to detach.  After hovering over the other outlet, press <kbd>S</kbd> again
	to attach.
</div>-->
  <div id="patchArea">

  <div class="patch" style="left:580px;top:100px;" data-id="osc">
  <header>Oscillator</header>
  <span class="port output" data-dir="out" data-name="audio"></span>
</div>

<div class="patch" style="left:620px;top:220px;" data-id="filter">
  <header>Filter</header>
  <span class="port input" data-dir="in" data-name="audio"></span>
  <span class="port output" data-dir="out" data-name="audio"></span>
</div>

<div class="patch" style="left:680px;top:340px;" data-id="amp">
  <header>Amplifier</header>
  <span class="port input"  data-dir="in"  data-name="audio"></span>
  <span class="port output" data-dir="out" data-name="audio"></span>
</div>

<div class="patch" style="left:720px;top:460px;" data-id="out">
  <header>Output</header>
  <span class="port input" data-dir="in" data-name="audio"></span>
</div>
    <!-- Overlay for cables (now above .patch) -->
    <canvas id="cablesCanvas" resize></canvas>
  </div>

<script>

  function getNodePosition(node) {
        return {x: node.offsetLeft, y: node.offsetTop};
    }

/* ─────────────────────────────────────────────────────────────────────────
   MULTI-PATCH DRAG SUPPORT
   •  Space-bar engages “drag-lock” for every .patch in the current selection.
   •  All selected patches follow the mouse as a rigid group.
   •  Press Space again (or release mouse) to drop them, then cables redraw.
   ───────────────────────────────────────────────────────────────────────*/

/* 1 ▸ New global to keep per-patch offsets from the cursor */
const dragOffsets = new Map();       // Map<HTMLElement,{dx,dy}>
/* ───── globals ───── */
const initialPos  = new Map();   // original {left,top} of each .patch
let   dragStart   = {x:0,y:0};   // mouse position at drag-start





/*************************************************
 *  Globals
 *************************************************/
const patchArea   = document.getElementById('patchArea');
const cableCanvas = document.getElementById('cablesCanvas');
const patches     = [...document.querySelectorAll('.patch')];
let hoverCable = null;   // paper.Path currently under the cursor

/*────────────────────────────  S-key “re-patch” support  ───────────────────────────
   ▸  Hover any cable, press **S** → one end is detached and follows the cursor.
   ▸  Press **F** while the cursor is over a *different* port to finish the move.
   ▸  Press **Esc** to cancel.                                                         */

let reattachCable = null;   // paper.Path currently being moved
let reattachEnd   = 1;      // 0 = start-segment, 1 = end-segment
let startPort     = null;   // port that remains fixed
let lastMouse     = {x:0, y:0};   // updated on every mouse-move

/* ——— Tidy Rectangle (T key) ——— */
let tidyRectActive     = false;   // true while drawing
let tidyStartPoint     = null;    // first corner (mouse-down or patch-centre)
let tidyLinePath       = null;    // preview diagonal
let tidyRectOutline    = null;    // preview upright rectangle

/* ——— Live Selection Rectangle (Y key) ——— */
let liveSelActive      = false;   // true while drawing
let liveSelStart       = null;    // first corner (mouse position)
let liveSelLine        = null;    // preview diagonal
let liveSelRectOutline = null;    // preview upright rectangle


/* Paper.js setup */
const paperScope = new paper.PaperScope();
paperScope.setup(cableCanvas);

/* ─────────────  Auto-connect Oscillator → Filter  ───────────── */
window.addEventListener('load', () => {
  const oscOut   = document.querySelector('.patch[data-id="osc"]   .port.output');
  const filterIn = document.querySelector('.patch[data-id="filter"] .port.input');
  if (!(oscOut && filterIn)) return;          // ports not found

  const p1   = centerOf(oscOut);
  const p2   = centerOf(filterIn);
  const path = new paperScope.Path({
    strokeColor: '#333',
    strokeWidth: 2
  });
  const midX = (p1.x + p2.x) / 2;
  path.moveTo(p1.x, p1.y);
  path.cubicCurveTo(midX, p1.y, midX, p2.y, p2.x, p2.y);

  connections.push({ from: oscOut, to: filterIn, path });
  paperScope.view.update();
});


/* Data for active drag-lock & cables */
let selectedPatch = null;
let dragLock      = false;
let dragOffset    = {x:0,y:0};
/* tracks a patch selected automatically by the space-bar */
let autoSelectedPatch = null;

/* Connection‑state data */
let connecting   = false;        // true → awaiting 2nd port
let connectStart = null;         // HTMLElement (first port)
let previewPath  = null;         // paper.Path for live preview
const connections = [];          // {from:HTMLElement, to:HTMLElement, path:paper.Path}

/* ——— Drag-Line relocation (G key) ——— */
let dragLineActive = false;   // true while drawing
let dragLinePatch  = null;    // HTMLElement being moved
let dragLinePath   = null;    // paper.Path preview line


// Ensure the page captures keyboard events as soon as it is shown
window.addEventListener('load', () => document.body.focus(), { once:true });
document.addEventListener('visibilitychange', () => {
  if (!document.hidden) document.body.focus();            // regain focus on tab-switch
});



patchArea.addEventListener('mousedown', e => {
  if (e.button !== 0) return;                              // left-button only
  if (!e.target.closest('.patch')) {                       // clicked outside any node
    clearSelection();
    selectedPatch = null;
    paperScope.view.update();
  }
});

/*************************************************
 *  Utility helpers
 *************************************************/
function centerOf(el){
  const r = el.getBoundingClientRect();
  return {x:r.left + r.width/2 + window.scrollX, y:r.top + r.height/2 + window.scrollY};
}
/* Replace the old single-selection helper with this multi-selection version */
function clearSelection(){
  /* remove the “selected” class from every patch that has it */
  document.querySelectorAll('.patch.selected')
          .forEach(el => el.classList.remove('selected'));

  /* reset single-patch state, if in use elsewhere */
  selectedPatch = null;
}

/** Update an existing cubic path's 4 control points to new endpoints */
function refreshPath(path, p1, p2){
  const midX=(p1.x+p2.x)/2;
  const segs = path.segments;
  if(segs.length!==4){ path.removeSegments(); path.moveTo(p1.x,p1.y); path.cubicCurveTo(midX,p1.y, midX,p2.y, p2.x,p2.y); return; }
  segs[0].point.set(p1.x,p1.y);
  segs[1].point.set(midX,p1.y);
  segs[2].point.set(midX,p2.y);
  segs[3].point.set(p2.x,p2.y);
}
function redrawCables(){
  for(const c of connections){
    const p1=centerOf(c.from);
    const p2=centerOf(c.to);
    if(c.path){
      refreshPath(c.path, p1, p2);
    }else{
      const path=new paperScope.Path();
      path.strokeColor='#333'; path.strokeWidth=2;
      path.moveTo(p1.x,p1.y);
      const midX=(p1.x+p2.x)/2;
      path.cubicCurveTo(midX,p1.y, midX,p2.y, p2.x,p2.y);
      c.path=path;
    }
  }
  paperScope.view.update();
}
function disconnect(from,to){
  const idx = connections.findIndex(c=>c.from===from && c.to===to);
  if(idx>-1){
    connections[idx].path.remove();
    connections.splice(idx,1);
    paperScope.view.update();
  }
}
function abortPreview(){
  if(previewPath){ previewPath.remove(); previewPath=null; }
  connecting=false;
  connectStart=null;
}

/*************************************************
 *  Pointer tracking
 *************************************************/
let mouse={x:0,y:0};
patchArea.addEventListener('mousemove',e=>{
  lastMouse = {x:e.clientX, y:e.clientY};                 // keep latest position
  mouse.x = e.clientX; mouse.y = e.clientY;            // keep global mouse


 if(reattachCable){                                      // move the floating end
    reattachCable.segments[reattachEnd].point =
      new paperScope.Point(e.clientX + window.scrollX,
                           e.clientY + window.scrollY);
    paperScope.view.update();
  }


  /* — group dragging — */
 
/* mouse-move: reuse the stored offsets so every patch keeps its original spacing */
if (dragLock && initialPos.size) {
  const dx = mouse.x - dragStart.x;
  const dy = mouse.y - dragStart.y;
  initialPos.forEach((pos, el) => {
    el.style.left = (pos.left + dx) + 'px';
    el.style.top  = (pos.top  + dy) + 'px';
  });
  redrawCables();                // maintain connections
  
  return;
}


 const mouse1 = { x: e.clientX, y: e.clientY };
  mouse.x=e.clientX; mouse.y=e.clientY;
  if(dragLock && selectedPatch){
    selectedPatch.style.left=(mouse.x-dragOffset.x)+'px';
    selectedPatch.style.top =(mouse.y-dragOffset.y)+'px';
    redrawCables();
    
  }

/* live update for G drag-line */
if (dragLineActive && dragLinePath) {
  dragLinePath.lastSegment.point.set(mouse.x + window.scrollX,
                                     mouse.y + window.scrollY);
  paperScope.view.update();
}

  
  /* Cable hover detection */
      if (!connecting){                          // skip while drawing a new cable
        const hit = paperScope.project.hitTest(
          new paperScope.Point(mouse.x + window.scrollX, mouse.y + window.scrollY),
          { stroke: true, fill: false, segments: false, tolerance: 6 });

        const target = (hit && hit.item &&
                        connections.some(c => c.path === hit.item))
                       ? hit.item : null;

        if (target !== hoverCable){
          if (hoverCable){ hoverCable.strokeColor = '#333'; hoverCable.strokeWidth = '3'}
          hoverCable = target;
          if (hoverCable){ hoverCable.strokeColor = '#895010'; hoverCable.strokeWidth = '5' }
          paperScope.view.update();
        }
      }
  
  
  
  
});

/*************************************************
 *  Hover state for ports
 *************************************************/
let hoverPort=null;
patchArea.addEventListener('mouseover',e=>{
  const p=e.target.closest('.port');
  if(p){hoverPort=p; p.classList.add('hover');}
});
patchArea.addEventListener('mouseout',e=>{
  const p=e.target.closest('.port');
  if(p){p.classList.remove('hover'); if(hoverPort===p) hoverPort=null;}
});




/*************************************************
 *  Keyboard control (Tab / Space / F / Esc)
 *************************************************/
/*  Focus the canvas whenever the mouse enters it  */
patchArea.tabIndex = 0;                 // make the element focus-able
patchArea.addEventListener('mouseenter', () => {
  patchArea.focus();                    // direct subsequent key events here
});


/* ──────────────────────────────────────────────────────────────────────────────
   Unified key-down handler  (revised)
   –  S  : detach nearest end of hovered cable; press S again to attach
   –  D  : delete the hovered cable
   –  F  : make / break a normal port-to-port connection
   –  ⎵  : toggle drag-lock on the *last* selected patch
   –  Tab: MULTI-SELECT patch under cursor; Tab in empty space clears selection
   –  Esc: cancel current modes (drag, preview, re-patch, selection)
   ────────────────────────────────────────────────────────────────────────────*/
document.addEventListener('keydown', e => {

  const key   = e.key;
  const lower = key.toLowerCase();

 /* ─────────────────────  G : drag-line relocation  ───────────────────── */
/* ─────────────────────  G : drag-line relocation  ───────────────────── */
if (lower === 'g') {
  e.preventDefault();
  if (!dragLineActive) {
    // Begin drag-line
    const tgt = document.elementFromPoint(mouse.x, mouse.y)?.closest('.patch');
    if (!tgt) return; // no patch under cursor
    dragLineActive = true;
    dragLinePatch  = tgt;
    const start = centerOf(tgt);
    dragLinePath = new paperScope.Path.Line({
      from: start,
      to:   start,
      strokeColor: '#0d6efd',
      strokeWidth: 2,
      dashArray: [4, 4]
    });
    return;
  } else {
  
  // Animate patch from original position to cursor location
const endX = mouse.x + window.scrollX;
const endY = mouse.y + window.scrollY;
const r = dragLinePatch.getBoundingClientRect();
const startX = r.left + window.scrollX;
const startY = r.top  + window.scrollY;

const targetX = endX - r.width / 2;
const targetY = endY - r.height / 2;

const dx = targetX - startX;
const dy = targetY - startY;

const duration = 100; // ms
const steps = 15;
let frame = 0;

function animate() {
  const t = ++frame / steps;
  if (t >= 1) {
    dragLinePatch.style.left = targetX + 'px';
    dragLinePatch.style.top  = targetY + 'px';
    dragLinePath.remove();
    dragLineActive = false;
    dragLinePatch = null;
    dragLinePath  = null;
    redrawCables();
    return;
  }
  const ease = t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t; // ease-in-out
  const x = startX + dx * ease;
  const y = startY + dy * ease;
  dragLinePatch.style.left = x + 'px';
  dragLinePatch.style.top  = y + 'px';
  redrawCables();                          // refresh cables each frame
  requestAnimationFrame(animate);
}
requestAnimationFrame(animate);

  /*
    // Complete drag-line by moving patch
    const endX = mouse.x + window.scrollX;
    const endY = mouse.y + window.scrollY;
    const r = dragLinePatch.getBoundingClientRect();
    dragLinePatch.style.left = (endX - r.width  / 2) + 'px';
    dragLinePatch.style.top  = (endY - r.height / 2) + 'px';
    dragLinePath.remove();
    dragLineActive = false;
    dragLinePatch = null;
    dragLinePath  = null;
    redrawCables();*/
    return;
  }
}

            
  /* ──────────────────────  S : detach / re-attach a cable end  ─────────────────── */
  if (lower === 's') {
    /* 1 ▸ finish reconnection if a loose end exists */
    if (reattachCable && connecting) {
      const portElem = document.elementFromPoint(lastMouse.x, lastMouse.y);
      if (!(portElem && portElem.classList.contains('port'))) return;
      if (portElem.closest('.patch') === startPort.closest('.patch')) return;

      const r = portElem.getBoundingClientRect();
      reattachCable.segments[reattachEnd].point =
        new paperScope.Point(r.left + r.width / 2 + window.scrollX,
                             r.top  + r.height / 2 + window.scrollY);

      const conn = connections.find(c => c.path === reattachCable);
      if (reattachEnd === 0) { conn.from = portElem; } else { conn.to = portElem; }

      reattachCable = null; connecting = false; startPort = null;
      setCursor?.(null);
      paperScope.view.update();
      return;
    }

    /* 2 ▸ not reconnecting yet: detach nearest end of hovered cable */
    if (hoverCable && !connecting && !reattachCable) {
      const conn = connections.find(c => c.path === hoverCable);
      if (!conn) return;

      const p0  = hoverCable.segments[0].point;
      const p1  = hoverCable.segments[1].point;
      const cur = new paperScope.Point(lastMouse.x + window.scrollX,
                                       lastMouse.y + window.scrollY);
      reattachEnd = (p0.getDistance(cur) < p1.getDistance(cur)) ? 0 : 1;

      if (reattachEnd === 0) { conn.from = null; startPort = conn.to; }
      else                   { conn.to   = null; startPort = conn.from; }

      reattachCable = hoverCable;
      connecting    = true;
      setCursor?.('connecting');
      return;
    }
  }

  /* ───────── Esc : cancel a pending re-patch (remove orphan if needed) ───────── */
  if (key === 'Escape' && reattachCable) {
    const conn = connections.find(c => c.path === reattachCable);
    if (!conn.from || !conn.to) {
      reattachCable.remove();
      connections.splice(connections.indexOf(conn), 1);
    }
    reattachCable = null; connecting = false; startPort = null;
    setCursor?.(null);
    paperScope.view.update();
    return;
  }

  /* ───────── Cursor tidy-up for Esc and D (outside re-patch mode) ───────── */
  if (key === 'Escape' || (lower === 'd' && hoverCable)) {
    setCursor?.(null);
  }

/* ────────────────────  Y : live selection rectangle  ──────────────────── */
if (lower === 'y') {
  e.preventDefault();

  /* ── first Y ▶ begin preview ─────────────────────────────────────────── */
  if (!liveSelActive) {
    /* start rectangle where the cursor is */
    liveSelStart  = { x: mouse.x + window.scrollX,
                      y: mouse.y + window.scrollY };

    liveSelActive = true;

    /* clear existing selection — rectangle defines a new one */
    clearSelection();

    liveSelLine = new paperScope.Path.Line({
      from: liveSelStart,
      to:   liveSelStart,
      strokeColor: '#00d1ff',
      strokeWidth: 0,
      dashArray: [4, 4]
    });

    liveSelRectOutline = new paperScope.Path.Rectangle({
      from: liveSelStart,
      to:   liveSelStart,
      strokeColor: '#00d1ff',
      strokeWidth: 1,
      dashArray: [4, 4],
      fillColor: null
    });

    return;                                           // wait for 2nd Y
  }

  /* ── second Y ▶ finish selection ─────────────────────────────────────── */
  liveSelActive      = false;
  liveSelStart       = null;
  liveSelLine.remove();
  liveSelRectOutline.remove();
  liveSelLine        = null;
  liveSelRectOutline = null;
  return;
}

/* ────────────────────  T : tidy-rectangle alignment  ──────────────────── */
/* ────────────────────  T : tidy-rectangle alignment  ──────────────────── */
if (lower === 't') {
  e.preventDefault();

  /* ── first T ▶ begin preview ─────────────────────────────────────────── */
  if (!tidyRectActive) {
    /* start at mouse position (centre of patch if present) */
    const patchUnder = document.elementFromPoint(mouse.x, mouse.y)?.closest('.patch');
    tidyStartPoint = patchUnder ? centerOf(patchUnder)
                                : { x: mouse.x + window.scrollX,
                                    y: mouse.y + window.scrollY };

    tidyRectActive = true;

    tidyLinePath = new paperScope.Path.Line({
      from: tidyStartPoint,
      to:   tidyStartPoint,
      strokeColor: '#ffc107',
      strokeWidth: 0,
      dashArray: [4, 4]
    });

    tidyRectOutline = new paperScope.Path.Rectangle({
      from: tidyStartPoint,
      to:   tidyStartPoint,
      strokeColor: '#ffc107',
      strokeWidth: 4,
      dashArray: [1, 1],
      fillColor: null
    });

    return;                                           // wait for second T
  }

  /* ── second T ▶ apply alignment ──────────────────────────────────────── */
  if (!tidyLinePath || !tidyStartPoint) return;

  const endPt = { x: mouse.x + window.scrollX, y: mouse.y + window.scrollY };
  const box   = {
    left:   Math.min(tidyStartPoint.x, endPt.x),
    right:  Math.max(tidyStartPoint.x, endPt.x),
    top:    Math.min(tidyStartPoint.y, endPt.y),
    bottom: Math.max(tidyStartPoint.y, endPt.y)
  };
  const w = box.right  - box.left;
  const h = box.bottom - box.top;

  /* collect patches that intersect or lie within the rectangle */
  const affected = [];
  document.querySelectorAll('.patch').forEach(el => {
    const r = el.getBoundingClientRect();
    const p = {
      left:   r.left + window.scrollX,
      right:  r.left + r.width  + window.scrollX,
      top:    r.top  + window.scrollY,
      bottom: r.top  + r.height + window.scrollY
    };
    const hit = !(p.right < box.left || p.left > box.right ||
                  p.bottom < box.top || p.top  > box.bottom);
    if (hit) affected.push(el);
  });

/* ── align patches without overlap ───────────────────────────────────── */
if (affected.length > 1) {
  const margin = 20;                       // gap between neighbouring patches

  if (w >= h) {                            // ‼ wide rectangle → horizontal row
    // sort by current x-position (left edge), leftmost first
    affected.sort((a, b) => a.offsetLeft - b.offsetLeft);

    // common y (row) is the arithmetic mean of current tops
    const rowY = affected.reduce((s, e) => s + e.offsetTop, 0) / affected.length;

    // lay patches left-to-right with no overlap (+ margin)
    let cursorX = Math.min(...affected.map(e => e.offsetLeft));
    affected.forEach(el => {
      el.style.left = cursorX + 'px';
      el.style.top  = rowY  + 'px';
      const width   = el.getBoundingClientRect().width;
      cursorX += width + margin;
    });
  } else {                                 // ‼ tall rectangle → vertical column
    // sort by current y-position (top edge), topmost first
    affected.sort((a, b) => a.offsetTop - b.offsetTop);

    // common x (column) is the arithmetic mean of current lefts
    const colX = affected.reduce((s, e) => s + e.offsetLeft, 0) / affected.length;

    // lay patches top-to-bottom with no overlap (+ margin)
    let cursorY = Math.min(...affected.map(e => e.offsetTop));
    affected.forEach(el => {
      el.style.left = colX + 'px';
      el.style.top  = cursorY + 'px';
      const height  = el.getBoundingClientRect().height;
      cursorY += height + margin;
    });
  }

  redrawCables();                          // refresh all connections
}

  /* cleanup preview */
  tidyRectActive  = false;
  tidyStartPoint  = null;
  tidyLinePath.remove();
  tidyRectOutline.remove();
  tidyLinePath    = null;
  tidyRectOutline = null;
  return;
}


/* ───────── Tab : multi-select toggle, or clear selection in empty space ───────── */
/* ───────── Tab : multi-select toggle, or clear selection in empty space ───────── */
if (e.key === 'Tab') {
  e.preventDefault();

  // Do nothing if drag-lock is active.
  if (dragLock) {
    return;
  }

  const patchAtCursor =
        document.elementFromPoint(mouse.x, mouse.y)?.closest('.patch');

  if (patchAtCursor) {
    // Toggle selection state of the patch under the cursor
    if (patchAtCursor.classList.contains('selected')) {
      patchAtCursor.classList.remove('selected');
      if (selectedPatch === patchAtCursor) selectedPatch = null;
    } else {
      patchAtCursor.classList.add('selected'); // add to multi-selection
      selectedPatch = patchAtCursor;           // remember last-active patch
    }
  } else {
    // Cursor in empty space: clear all selected patches
    clearSelection();
    selectedPatch = null;
  }
  return;
}

/* ───────────────────────  Space : drag-lock toggle  ─────────────────────── */
if (e.key === ' ') {          // inside your key-down handler
  e.preventDefault();

  /* current selection, if any */
  let selected = [...document.querySelectorAll('.patch.selected')];

  /* auto-select the patch under the cursor when none is selected */
  if (!selected.length) {
    const tgt = document.elementFromPoint(mouse.x, mouse.y)?.closest('.patch');
    if (!tgt) return;                         // nothing under cursor
    tgt.classList.add('selected');
    selected = [tgt];
    autoSelectedPatch = tgt;                  // remember for later un-select
  }

  /* ── engage drag-lock ─────────────────────────────────────────────── */
  if (!dragLock) {
    dragLock  = true;
    dragStart = { x: mouse.x, y: mouse.y };

    initialPos.clear();
    selected.forEach(el => {
      const r = el.getBoundingClientRect();
      initialPos.set(el, { left: r.left, top: r.top });
      el.classList.add('dragging');
    });
  }
  /* ── release drag-lock ────────────────────────────────────────────── */
/* ── release drag-lock ────────────────────────────────────────────── */
else {
  dragLock = false;

  /* remove .dragging from all affected patches */
  document.querySelectorAll('.patch.dragging')
          .forEach(el => el.classList.remove('dragging'));

  initialPos.clear();
  dragOffsets.clear();          // remains empty in current logic
  redrawCables();

  /* deselect the patch that was auto-selected at lock-start */
  if (autoSelectedPatch) {
    autoSelectedPatch.classList.remove('selected');
    autoSelectedPatch = null;
  }
}

  return;
}

  /* ───────────────────  F : connect / disconnect ports  ──────────────────── */
  if (lower === 'f') {
    e.preventDefault();
    if (!hoverPort) return;

    if (!connecting) {                       /* first press: begin */
      abortPreview();
      connecting   = true; connectStart = hoverPort;

      const startPt = centerOf(connectStart);
      previewPath = new paperScope.Path.Line({
        from: startPt, to: startPt,
        strokeColor: '#f39c12', strokeWidth: 2, dashArray: [6, 4]
      });
      return;
    }

    /* second press: finalise */
    const start = connectStart; const end = hoverPort;
    abortPreview();
    if (start === end) return;

    const okFwd  = start.dataset.dir === 'out' && end.dataset.dir === 'in';
    const okBack = start.dataset.dir === 'in'  && end.dataset.dir === 'out';
    if (!(okFwd || okBack)) return;

    const from = okFwd ? start : end;
    const to   = okFwd ? end   : start;

    const exists = connections.some(c => c.from === from && c.to === to);
    if (exists) { disconnect(from, to); } else {
      connections.push({ from, to, path: null }); redrawCables();
    }
    return;
  }

  /* ─────────────────────  D : delete the hovered cable  ───────────────────── */
  if (lower === 'd') {
    if (hoverCable) {
      const idx = connections.findIndex(c => c.path === hoverCable);
      if (idx > -1) {
        connections[idx].path.remove();
        connections.splice(idx, 1);
      }
      hoverCable = null;
      paperScope.view.update();
    }
    return;
  }


  /* ─────────────────────  Esc : cancel other operations  ──────────────────── */
  if (key === 'Escape') {
  
  /* cancel live selection rectangle */
if (liveSelActive) {
  if (liveSelLine)        liveSelLine.remove();
  if (liveSelRectOutline) liveSelRectOutline.remove();
  liveSelActive      = false;
  liveSelStart       = null;
  liveSelLine        = null;
  liveSelRectOutline = null;
}


/* cancel tidy rectangle */
if (tidyRectActive) {
  if (tidyLinePath)    tidyLinePath.remove();
  if (tidyRectOutline) tidyRectOutline.remove();
  tidyRectActive  = false;
  tidyStartPoint  = null;
  tidyLinePath    = null;
  tidyRectOutline = null;
}



    if (dragLock && selectedPatch) {
      dragLock = false; selectedPatch.classList.remove('dragging');
    }
    abortPreview();
    if (dragLineActive) {
  if (dragLinePath) dragLinePath.remove();
  dragLineActive = false; dragLinePatch = null; dragLinePath = null;
	}

    clearSelection();
    paperScope.view.update();
  }
});


/*************************************************
 *  Live update of preview connection during mousemove (when connecting)
 *************************************************/
patchArea.addEventListener('mousemove',()=>{
  if(connecting && previewPath && connectStart){
    const p1=centerOf(connectStart);
    const p2={x:mouse.x+window.scrollX,y:mouse.y+window.scrollY};
    refreshPath(previewPath, p1, p2);
    paperScope.view.update();
  }
  /* live update for T tidy rectangle */
if (tidyRectActive && tidyLinePath) {
  tidyLinePath.lastSegment.point.set(mouse.x + window.scrollX,
                                     mouse.y + window.scrollY);
  paperScope.view.update();
}

/* live update for T tidy rectangle */
if (tidyRectActive && tidyLinePath) {
  const curX = mouse.x + window.scrollX;
  const curY = mouse.y + window.scrollY;

  /* update diagonal */
  tidyLinePath.lastSegment.point.set(curX, curY);

  /* update / recreate rectangle outline */
  if (tidyRectOutline) tidyRectOutline.remove();
  tidyRectOutline = new paperScope.Path.Rectangle({
    from: { x: Math.min(tidyStartPoint.x, curX),
            y: Math.min(tidyStartPoint.y, curY) },
    to:   { x: Math.max(tidyStartPoint.x, curX),
            y: Math.max(tidyStartPoint.y, curY) },
    strokeColor: '#ffc107',
    strokeWidth: 1,
    dashArray: [4, 4],
  fillColor: '#ffc107'          // give it the same hue …
});
tidyRectOutline.fillColor.alpha = 0.2;   // … but almost fully transparent

  paperScope.view.update();
}


/* live update for Y selection rectangle */
if (liveSelActive && liveSelLine) {
  const curX = mouse.x + window.scrollX;
  const curY = mouse.y + window.scrollY;

  /* update diagonal */
  liveSelLine.lastSegment.point.set(curX, curY);

  /* update rectangle outline */
  if (liveSelRectOutline) liveSelRectOutline.remove();
  liveSelRectOutline = new paperScope.Path.Rectangle({
    from: { x: Math.min(liveSelStart.x, curX),
            y: Math.min(liveSelStart.y, curY) },
    to:   { x: Math.max(liveSelStart.x, curX),
            y: Math.max(liveSelStart.y, curY) },
    strokeColor: '#00d1ff',
    strokeWidth: 0,
  fillColor: '#00d1ff'
});
liveSelRectOutline.fillColor.alpha = 0.15; // light, transparent cyan

  /* update selection membership */
  const box = {
    left:   Math.min(liveSelStart.x, curX),
    right:  Math.max(liveSelStart.x, curX),
    top:    Math.min(liveSelStart.y, curY),
    bottom: Math.max(liveSelStart.y, curY)
  };

  document.querySelectorAll('.patch').forEach(el => {
    const r = el.getBoundingClientRect();
    const p = {
      left:   r.left + window.scrollX,
      right:  r.left + r.width  + window.scrollX,
      top:    r.top  + window.scrollY,
      bottom: r.top  + r.height + window.scrollY
    };
    const hit = !(p.right < box.left || p.left > box.right ||
                  p.bottom < box.top || p.top  > box.bottom);
    el.classList.toggle('selected', hit);
  });

  paperScope.view.update();
}

});

/*************************************************
 *  Ensure canvas resizes with window
 *************************************************/
function resizeCanvas(){
  cableCanvas.width=window.innerWidth; cableCanvas.height=window.innerHeight;
  paperScope.view.update();
}

/* Utility: centralised cursor state handler */
  function setCursor(state){           // state ∈ null | class-name string
    patchArea.classList.remove(
      'connecting','over-port','hover-cable','invalid-connect');
    if(state){ patchArea.classList.add(state); }
  }

  /* —— A.  start of a cable drag —— */
   startPort=null;                  // remember first port
  document.addEventListener('mousedown',e=>{
    if(e.target.classList && e.target.classList.contains('port')){
      startPort=e.target;
      connecting=true;                 // your existing flag
      setCursor('connecting');
      /* …existing cable-start code… */
    }
  });
  
    patchArea.addEventListener('mousemove',e=>{
    const tgt=e.target;

    if(connecting){
      /* while dragging, show not-allowed when same-patch */
      const overPort = tgt.classList && tgt.classList.contains('port');
      const invalid  = overPort && startPort &&
                       (startPort.closest('.patch')===tgt.closest('.patch'));
      setCursor(invalid ? 'invalid-connect' : 'connecting');
      return;                           // nothing else while dragging
    }

    /* not dragging: highlight cable or port */
    if(hoverCable){                     // set in previous answer
      setCursor('hover-cable');
    }else if(tgt.classList && tgt.classList.contains('port')){
      setCursor('over-port');
    }else{
      setCursor(null);
    }
  });
  
   /* —— C.  end of a drag / clear cursor —— */
  document.addEventListener('mouseup',()=>{
    if(connecting){
      connecting=false;
      setCursor(null);
      startPort=null;
    }
    
    /* complete drag-line – move patch to cursor */
if (dragLineActive && dragLinePatch && dragLinePath) {
  const endX = lastMouse.x + window.scrollX;
  const endY = lastMouse.y + window.scrollY;
  const r = dragLinePatch.getBoundingClientRect();
  dragLinePatch.style.left = (endX - r.width  / 2) + 'px';
  dragLinePatch.style.top  = (endY - r.height / 2) + 'px';
  dragLinePath.remove();
  dragLineActive = false; dragLinePatch = null; dragLinePath = null;
  redrawCables();
}

    
  });

window.addEventListener('resize',resizeCanvas); resizeCanvas();
</script>

<script>
  const container = document.querySelector('#instructions');
  const content = container.querySelector('.scroll-content');
  const track = container.querySelector('.scrollbar-track');
  const thumb = container.querySelector('.scrollbar-thumb');

  function updateThumb() {
    const ratio = content.scrollTop / (content.scrollHeight - content.clientHeight);
    const thumbHeight = Math.max((content.clientHeight / content.scrollHeight) * track.clientHeight, 30);
    thumb.style.height = thumbHeight + 'px';
    thumb.style.top = (ratio * (track.clientHeight - thumbHeight)) + 'px';
  }

  content.addEventListener('scroll', updateThumb);
  window.addEventListener('resize', updateThumb);
  window.addEventListener('load', updateThumb);

  let dragging = false;
  let startY, startScroll;

  thumb.addEventListener('mousedown', (e) => {
    dragging = true;
    startY = e.clientY;
    startScroll = content.scrollTop;
    document.body.style.userSelect = 'none';
  });

  window.addEventListener('mousemove', (e) => {
    if (!dragging) return;
    const deltaY = e.clientY - startY;
    const scrollRatio = (content.scrollHeight - content.clientHeight) / (track.clientHeight - thumb.clientHeight);
    content.scrollTop = startScroll + deltaY * scrollRatio;
  });

  window.addEventListener('mouseup', () => {
    dragging = false;
    document.body.style.userSelect = '';
  });
</script>

</body>
</html>
