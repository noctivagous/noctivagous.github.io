
A Declarative Application XML Format

The issue being addresed  is that app SDKs are still providing very low level 
conventions for writing apps, such as having people manually specify,
inside keyDown event functions, each key combination with if statements.
There is too much like this that is a common activity that can be
abstracted into higher-level components, and then when this is done the
apps can be constructed more rapidly because the right utilities are in place. 
Today's app SDKs, and for the last few decades, have just been supplying direct 
functions, variables, and object classes that work inside the programming 
languages.  They aren't identifying situations where the work is unnecessarily 
tedious and manual for the job of making an app.

Consider:

    - Programming inside keyDown(), mouseDown(), mouseDragged(), etc. for more
    than simple scenarios is too low level and is the wrong software 
    architecture for apps requiring complex input software designs.
        - The example: 
        Programming each key's corresponding character code 
        and what it does inside an if statement in a keyDown() event function 
        vs. 
        A keyMap property list that
        defines actions (functions to call) for keyDown, keyUp for each keyCode.  
        
        

    - This is then rearchitected further to a higher level and into
    a different set of concepts.   The keyMap can be wrapped inside an 
    input context (inputContext) so that it is self-contained
    and separated from other inputContexts of the app, as needed.  For the same window,
    different inputContexts might be swapped out.
        
        - An inputContext covers a set of input definitions (e.g. key mappings)
        for a loaded context, which can be swapped out.  Within an inputContext, there
        are additional conventions to make swapping out different types of
        input interactions possible.  Thus other aspects become modular
        and swappable.
    - Conventions are provided in this application format
    and states and workflows are natively supported.


In short, there are many app scenarios that could be set up completely 
in a declarative file format, it's just that more conveniences and 
other conventions need to be provided that result from identifying 
various patterns where the programmer is involve in relatively low level code
for making an app.  Then these patterns, which occur in many places in
the code of application software development,can be re-architected into 
higher-level components, building on top of the declarative app formats of
past, such as MXML and XUL.

A calculator app is an example we use because it should be, by now, 
describable through a provided set of higher-level conceptual components 
that make it easy to construct at the outset.  They are components that haven't
existed before in any app SDK because, to begin with, they address the
inadequacies and oversights of existing SDKs when they ask the software developer
to write certain code situations with the bare tools of the programming language.

By placing this inside an XML format we also address the integration of
GUI into the app code as well.

--> Is cross-platform as long as a runtime or interpreter 
is built for any given programming language and system.


A set of these components will be generalized so that they can be utilized in 
other app scenarios as well.


This kit can be developed while testing it against different scenarios,
calculator, a tetris-style game, vector-editor, and then.


APPLICATION SETUP

- app <app id="com.example.calculator" version="1.0">
- appSettings


- Application Scenes <appScene>
--- Like game scenes, can be swapped out.
--- Can be inside a <window> or wrap a <window> or <windowGroup>.



INPUT CONTEXTS

- Input Contexts <inputContext>
--- Swaps out the events within an appScene.
--- example:
    In an inputContext, a list of buttons (<button>), such as for a calculator,
    carry an attribute not only for what happens when they are pressed (onPress),
    but also a keyMapping attribute to indicate which key activates
    them.  By placing them inside a inputContext, their
    keyMappings


KEY MAPPINGS

- Key Map <keyMap>
---Is a property list placed inside an input context for keyboard actions.

- Key Mappings <keyMapping>
---The mapping for a specific key.

- Key Mapping Action <keymappingAction event="keyDown">
--- The action for an event for a specific key. Placed inside a <keyMapping>.


<keyMap>
                <keymapping keyCode="48" label="0">
                        <keymappingAction event="keyDown" target="#display" action="append" value="0"/>
                    </keymapping>
                    <keymapping keyCode="49" label="1">
                        <keymappingAction event="keyDown" target="#display" action="append" value="1"/>
                    </keymapping>
                    <keymapping keyCode="50" label="2">
                        <keymappingAction event="keyDown" target="#display" action="append" value="2"/>
                    </keymapping>
</keyMap>
                    
                    
ARRAYS

- Selected Item Array <selectedItemArray>,<selectedItemsArray> 
--- Arrays never carry their index, but this can help.
--- Wraps a list that has a selected index
--- For multiple scenarios both inside the code and to set up GUI controls with indices.
--- Default index value is 0


FUNCTION CONVENIENCES (SUBCLASSES OF FUNCTION)

Functions are used for a variety of classifiable purposes and instead of defining
plain a function for everything the software developer can use premade components
for the various uses of them.

- Converters <converter>
--- <valueConverter name="radToDeg" type="float" output="input * PI / 180" ... >
OR
<converter name="radToDeg" input="{v}" output="{v * 180 / PI}"/>


- Repeat
--- <repeat from="i" to="10" step="1" ><printLog string="${i}"></repeat>
--- 
<repeat from="i" to="10">
  <button label="Item {i}"/>
</repeat>



- Timer
<timer interval="2s" once="true" onTimeout="state:ready;mesg:...;state#button1:off" />



- Selected Item Array - Can be shown in different views
<selectedItemArray id="tools" activeIndex="0">
  <item name="select"/>
  <item name="pencil"/>
  <item name="eraser"/>
</selectedItemArray>


LAYERED PROPERTY RELATIONS TABLE/GRID

A grid of boxes in which each cell has multiple layers.

A grid of buttons. Layers of properties and data compiled from diff places:
- The background style
- The text of the button
- The action (what the button does)
- The associated data (such as a sound to play).




MESSAGE SENDING BETWEEN OBJECTS

Historically the declarative formats lacked a lot of the functions
found in code.  You weren't able to control one object from another 
or its styles.  The code in the attributes can do things if there
is message passing.

Every action in the application is triggered by sending short, readable messages. You write these messages directly inside event attributes (onPress, onChange, keyDown actions, etc.). A message is always a simple string, and the runtime instantly knows what to do with it because it follows a few crystal-clear rules.
If the message name has no caret (ˆ), it is a built-in action that the system guarantees every component understands, or it is an official system command.

Example Message Sending:


<button title="Increment"
        onPress="msg#numField1:(INCREMENTBY:1) ; 
                 msg#numField2:(INCREMENTBY:2) ;
                 msg#alertArea:^(ROTATEBOX: deg=40, duration=0.3)" />

<numberField id="numField1"
             onChange="msg#alertArea:^(FLASHTEXT:'Incremented') ;
                       sys:log('field1 changed to {#value}')" />

<textArea id="alertArea">
  <!-- These are custom → must use ^ when calling -->
  <!-- Inside any component you can declare exactly which custom (ˆ) messages it understands: -->
  <messageHandler name="FLASHTEXT" params="text">
    <animate property="background" from="#ffff00" to="transparent" duration="0.5s"/>
    <set property="text" value="{text}"/>
  </messageHandler>

  <messageHandler name="ROTATEBOX" params="deg=0, duration=0.2">
    <animate property="rotate" to="{deg}deg" duration="{duration}s" ease="easeOutBack"/>
  </messageHandler>
</textArea>




Examples:
msg#display:clear – every text display knows how to clear itself.
msg#counter:(SET:10) – every counter, number field, slider, etc. understands SET.
sys:log('hello') – official runtime command to write to the console.
sys:swapInputContext('gameplay') – official command to change input mode.
If the message name starts with a single caret (ˆ), it is a custom action defined by you inside the target component itself.
Examples:

What you can actually write
You can chain as many messages as you want with semicolons; they fire in exact order:


---

<app> 
<appScene name="Calculator"> 
<inputContext> 
<!-- selectedItemArray wraps a list, allows swapping active element, such as swapping out the active keyMapping ---> <selectedItemArray active="first"> <keyMappings> <keymapping hid="" keyCode="1" modifiers=""> <keymappingAction event="keyDown"> </keymappingAction> </keymapping> </keyMappings> </selectedItemArray> </inputContext> </appScene> </app>



STATES AND WORKFLOW

<app id="com.example.calculator">

  <!-- Define all possible states.  Only applies to documentStateContext -->
  <states id="documentOpened" stateContext="documentStateContext">
    <state name="ready"          default="true" />
    <state name="editing" />
    <state name="result" />
    <state name="error" />
    <state name="historyOpen" />
  </states>

  <!-- Optional: declarative transitions with actions -->
  <workflow id="documentOpened">
    <transition from="ready"     event="startEdit"     to="editing" />
    <transition from="editing"   event="equals"        to="result" />
    <transition from="*"         event="clear"         to="ready" 
                do="msg#display:clear ; sys:log('cleared')" />
    <transition from="*"         event="showHistory"   to="historyOpen" />
    <transition from="historyOpen" event="hideHistory" to="ready" />
  </workflow>

</app>


StateContext like InputContext allows wrapping
a set of things with a context so that, like a namespace,
there is separation of code.

<StateContext>
</StateContext>


onPress="state:ready"
onPress="state#button3:presentation.on" <!-- sets the state of button3 to presentation.on (hierarchical state)
-->


Hierarchical States

<states>
  <state name="game.playing"  />
  <state name="game.paused"   />
  <state name="ui.modalOpen"  />   <!-- can be active at the same time -->
</states>

You can test with <banner visibleOnState="game.playing !ui.modalOpen"/>

More:

<states type="hierarchical">
  <state name="game" default="true">
    <entry do="msg#hud:show"/>
    <exit  do="msg#hud:hide"/>

    <state name="playing">
      <state name="normal"/>
      <state name="aiming"/>
      <state name="paused" />
    </state>

    <state name="menu"/>
  </state>
</states>




Attribute,Meaning,Example
visibleOnState,Visible only when app is in one of these states (space or comma separated),"visibleOnState=""error"""
hiddenOnState,Hidden in these states (opposite of above),"hiddenOnState=""ready editing"""
enabledOnState,Enabled only in these states,"enabledOnState=""editing"""
activeOnState,Receives input focus / is the “active tool” only in these states,"activeOnState=""editing"""
inputContextOnState,Automatically swap inputContext when entering these states,"inputContextOnState=""historyOpen"""
sceneOnState,Show this entire scene only in these states,"sceneOnState=""historyOpen"""


STATE MACHINE TIERS – Plain-text reference for the XML format

────────────────────────────────────────────────────────────
TIER 1 – Simple / Flat (default, recommended for 95% of apps)
────────────────────────────────────────────────────────────
One single active state at a time. No nesting.

<states>
  <state name="ready"      default="true"/>
  <state name="editing"/>
  <state name="result"/>
  <state name="error"/>
</states>

<workflow>
  <transition from="*"        event="clear"   to="ready"/>
  <transition from="editing"  event="equals"  to="result"/>
  <transition from="*"        event="error"   to="error"/>
</workflow>

Usage:
onPress="transition:clear"        or   "state:ready"
visibleOnState="error"
enabledOnState="editing"
inputContextOnState="ready editing"
sceneOnState="result"

Perfect for: calculators, forms, dialogs, settings screens, login flows.

────────────────────────────────────────────────────────────
TIER 2 – Hierarchical (opt-in with one attribute)
────────────────────────────────────────────────────────────
Add type="hierarchical" → nesting, entry/exit actions, history.

<states type="hierarchical">
  <state name="app" default="true">
    <entry do="msg#hud:show"/>
    <exit  do="msg#hud:hide"/>

    <state name="menu"/>
    
    <state name="game">
      <state name="playing">
        <state name="normal"/>
        <state name="aiming"/>
        <state name="paused"/>
      </state>
      <state name="inventory"/>
      <history type="deep"/>   <!-- remember last sub-state when leaving/re-entering "game" -->
    </state>
  </state>
</states>

Transitions automatically trigger entry/exit actions of all affected states.
State names use dot notation: state:game.playing.paused
visibleOnState="game.playing !game.playing.paused"

Perfect for: games, vector editors, IDE-style tools, anything with deep modes.

────────────────────────────────────────────────────────────
TIER 3 – Full / Parallel (explicit opt-in, rare)
────────────────────────────────────────────────────────────
type="parallel" or type="scxml"

Allows multiple independent regions, guards, event parameters, etc.

<states type="parallel">
  <region id="power">   off | booting | on </region>
  <region id="mode">    menu | gameplay | map </region>
  <region id="audio">   muted | sfxOnly | full </region>
</states>

<transition event="equals" 
            when="{#operand2 != 0}" to="result"
            otherwise="error"/>

Used only for extremely complex apps (flight simulators, MMOs, industrial control).

────────────────────────────────────────────────────────────
Summary – how to choose
────────────────────────────────────────────────────────────
- Default → Tier 1 (flat)          – start here, covers almost everything
- Need sub-modes or entry/exit? → add type="hierarchical" (Tier 2)
- Need multiple independent states at once? → type="parallel" (Tier 3)

All tiers are 100% backward compatible – you can upgrade later without breaking anything.



