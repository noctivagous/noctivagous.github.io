<!DOCTYPE html>
<html>

<head>

  <link rel="stylesheet" href="main.css?v=0.3151433">
  <link rel="stylesheet" href="keyboard.css?v=0.3151433">

<style>
  body{
font-family: 'Arial Narrow', Arial, sans-serif;
  }
h3,h2{
margin-top:50pt;
}

P{
margin-left:0pt;
}

ul, ol{
margin-left:40pt;
}

article{
  max-width:800pt;
width:80%;
margin:auto;
}
</style>
  <script>
    window.addEventListener('keydown', function (event) {
      if (event.key === ' ' || event.key === 'Tab') {
        event.preventDefault();
      }
    });
  </script>


  <script type="text/javascript"
    src="https://cdnjs.cloudflare.com/ajax/libs/paper.js/0.12.17/paper-full.min.js"></script>



<title>Bimodal Control / Dual-Input</title>

</head>

<body>

  <div id="intro">



    <article>
      <h1>Bimodal Control / Dual-Input (UI Theory)</h1>

      <h3>Guitar As Introduction for Bimodal Control UI</h3>
  <p>Consider how the guitar exists as an instrument.
    The hands are assigned separate tasks: 
  </p>

  
  <ol><li><b>The left hand navigates to the note and sets it up to be played.</b>
  <ul><li>It moves across the fretboard before pressing down on the string(s)</li></ul>
  </li>
  <br/><br/>
  <li> <b>The right hand triggers the note's sound </b>
<ul><li>It holds the guitar pick and picks the string(s) according to the timing.</li></ul>

  </li>
  </ol>

<p>The two activities are interdependent.  For the note to be played
  it has to be set up by the left hand.<!--For the song to change
  notes, they will happen in alternation in a continous process,
  with the fretboard hand setting up the note and the
  pick hand playing it.-->
</p>



  <h3>The Mouse</h3>
  <p>
  Noctivagous explains that the mouse and desktop computer
  should follow the same principle. As the mouse is used today,
  it places too much cognitive load on the computer user by
  combining triggering of functionality (clicking things) and steering
  (moving the cursor) into a single device and location, then assigning that to one hand. 
  Making these roles distinct, then separating them into two input locations for both hands, 
  provides the user greater control over software.  The mouse or trackpad can, for example,
  continue to steer the cursor while the "clicks" are received elsewhere, controlled by 
  the other hand for the first time.  
  An altogether different software dynamic emerges, as shown in the demo below. 
  For the software developer the opportunities in UI theory open up.


    <p>Just one person is associated with devising the mouse in 1968, Douglas Engelbart,
      and it has remained unchanged since that time.  Touchscreen tablets
      did not make it irrelevant because straight-on touch of a screen object
      is not precise.  At the same time, 
      there is much room for improvement.  Its introduction was
      an upgrade to the personal computer at the time, but decades later,
      in many instances, it produces a tedious and tiresome way to work with 
      a computer.
      <p>
 
    <h2>Vector-Drawing Canvas Demo</h2>
    <p>Experience this UI theory by trying out the vector-drawing demo below.  
      It uses the keyboard keys to click instead of the mouse buttons.
      
    </p>
    
  </article>
   

    
    <p>
   <!-- 
    is an alternative way to draw vectors, curves,
    and shapes with the mouse and keyboard.  Simple on the surface, it is capable of establishing 
    the new industry standard for interactivity 
    in font-making software, vector-drawing software,
    and OS user interfaces across the world. It can make the tedium associated
    with these programs disappear. Try out the demo:

   The
    dual-input UI is an upgrade and reconfiguration of input taken from the mouse
    and keyboard.-->
    

      <!--
      
     Explaining isn't necessary: try out the demo below to experience a 
    completely different setup for vector drawing input that uses the keys to click, instead of using mouse buttons.

  It's important first to modify the setup for vector-drawing.  This is what the dual-input UI is about.
  Try out the demo below to experience it.  A software program that implements the dual-input UI treats the keys
  on a keyboard as click buttons. The mouse buttons are entirely ignored.</p>
-->



    <div style="border: 2px dashed black;font-size: 80%;margin-bottom: 10px;margin-top:0px;">
      <div style="padding-left:10px;padding-top:10px;">After moving your cursor into the gray drawing area below, use the following
        keys. 
        <br/>
        There is also an interactive keyboard inside the drawing area that shows what keys can be pressed.</div>
      <table cellspacing="10">
        <tr>
          <td style="vertical-align: top; color:rgb(146, 106, 106);padding: 10px;">
            <h3 style="margin-top: 0px;">DRAWING:</h3>
            1. Press the <kbd style="color:rgb(234, 171, 171)">F</kbd> key to deposit a point.
            <br /> 2. Move the mouse. <br />
            3. Press the <kbd style="color:rgb(234, 171, 171)">F</kbd> key
            again to deposit another point.
            <br />

            4. Repeat until you wish to press an END key:
            <br />
            <br />&nbsp;&nbsp;&nbsp;<kbd style="color:red">A</kbd> - END the stroke path.
            <br />&nbsp;&nbsp;&nbsp;<kbd style="color:red">E</kbd> - END and fill the shape.
            <br />&nbsp;&nbsp;&nbsp;<kbd style="color:red">R</kbd> - END and stroke the shape.
            <br />&nbsp;&nbsp;&nbsp;<kbd style="color:red">S</kbd> - END and fill+stroke the shape.

          </td>



          <td style="vertical-align: top;  color:rgb(104, 102, 148);padding: 10px;">
            <h3 style="margin-top: 0px;">SELECTING AND DRAGGING:</h3>
            1.Select objects with <kbd style="color:rgb(142, 139, 205)">Tab</kbd>. <br />

            2.To drag the selection, turn on the drag-lock with <kbd style="color:rgb(142, 139, 205)">SPACEBAR</kbd>,
            then move the mouse. (Press it again to turn it off.)
            <br />
            3. Stamp a selection with <kbd style="color:rgb(142, 139, 205)">W</kbd> while dragging.
            <br />
            4. Scale a selection down and up with <kbd style="color:rgb(142, 139, 205)">[</kbd> and <kbd
              style="color:rgb(142, 139, 205)">]</kbd>.
            <br />
            5. Rotate a selection forwards and backwards by 15 degrees with <kbd
              style="color:rgb(142, 139, 205)">;</kbd> and <kbd style="color:rgb(142, 139, 205)">'</kbd>.
            <br />
            6. The <kbd style="color:rgb(142, 139, 205)">Esc</kbd> key will also cancel the selection and dragging.

            <div style="color:rgb(102, 148, 116);">
              <h3>ADJUSTING STROKE WIDTH:</h3>
              1. To thin or thicken the stroke, use <kbd style="color:rgb(148, 212, 167);">C</kbd> and <kbd
                style="color:rgb(148, 212, 167);">V</kbd>.
            </div>

          </td>
        </tr>
      </table>




    </div>


    <div id="canvasContainer">

      <div style="z-index: 1;">
        <canvas id="nibgliderCanvas" tabindex="0" resize></canvas>
      </div>
      <div class="corner-div">
        
        

        <div id="keyboardContainer">

          <div id="keyboardKeysContainer">



            <!-- 
                █████████████████████ BEGIN TOP ROW:█████████████████████
                esc F1 F2 F3 F4 F5 F6 F7 F8 F9 F10 F11 F12 F13 F14
              -->

            <!--
              
              <button tabindex="-1" id="Escape" class="escKey keyboardkey functionRow"></button>
              <button tabindex="-1" id="F1" class="f1Key keyboardkey functionRow "></button>
              <button tabindex="-1" id="F2"  class="f2Key keyboardkey functionRow "></button>
              <button tabindex="-1" id="F3"  class="f3Key keyboardkey functionRow "></button>
              <button tabindex="-1" id="F4"  class="f4Key keyboardkey functionRow "></button>
              <button tabindex="-1" id="F5"  class="f5Key keyboardkey functionRow "></button>
              <button tabindex="-1" id="F6"  class="f6Key keyboardkey functionRow "></button>
              <button tabindex="-1" id="F7"  class="f7Key keyboardkey functionRow "></button>
              <button tabindex="-1" id="F8"  class="f8Key keyboardkey functionRow "></button>
              <button tabindex="-1" id="F9"  class="f9Key keyboardkey functionRow "></button>
              <button tabindex="-1" id="F10"  class="f10Key keyboardkey functionRow "></button>
              <button tabindex="-1" id="F11"  class="f11Key keyboardkey functionRow "></button>
              <button tabindex="-1" id="F12"  class="f12Key keyboardkey functionRow"></button>
              <button tabindex="-1" id="F13"  class="f13Key keyboardkey functionRow"></button>
              <button tabindex="-1" id="F14"  class="f14Key keyboardkey functionRow"></button>
    
            -->

            <!-- 
                END TOP ROW 
              -->








            <!-- 
                ██████████████BEGIN SECOND ROW: █████████████████████
                      tab Q W E R T Y U I O P [ ] \ 
              -->

            <button tabindex="-1" data-key="tab" id="Tab" class="keyboardkey tabKey OtherKey enabledButton selectionButton">Select Objects</button>

            <button data-key="q" tabindex="-1" id="KeyQ" class="keyboardkey "></button>
            <button data-key="w" tabindex="-1" id="KeyW" class="keyboardkey wKey operationButton enabledButton">stamp</button>
            <button data-key="e" tabindex="-1" id="KeyE" class="keyboardkey eKey endButton">              <b>END:</b> <br />fill
            </button>
            <button data-key="r" tabindex="-1" id="KeyR" class="keyboardkey rKey endButton"><b>END:</b><br />close
              stroke</button>
            <button data-key="t" tabindex="-1" id="KeyT" class="keyboardkey tKey"></button>
            <button data-key="y" tabindex="-1" id="KeyY" class="keyboardkey yKey "></button>
            <button data-key="u" tabindex="-1" id="KeyU" class="keyboardkey uKey "></button>

            <button data-key="i" tabindex="-1" id="KeyI" class="keyboardkey iKey "></button>
            <button data-key="o" tabindex="-1" id="KeyO" class="keyboardkey oKey "></button>
            <button data-key="p" tabindex="-1" id="KeyP" class="keyboardkey pKey "></button>


            <button data-key="[" tabindex="-1" id="BracketLeft"
              class="keyboardkey  bracketLeftKey operationButton enabledButton">scale
              -</button>
            <button data-key="]" tabindex="-1" id="BracketRight"
              class="keyboardkey  bracketRightKey operationButton enabledButton">scale
              +</button>
            <button data-key="\" tabindex="-1" id="Backslash" class="keyboardkey  backslashKey"></button>
            <!-- 
                END SECOND ROW 
              -->




            <!-- 
              ██████████████  BEGIN THIRD ROW: ██████████████
                   capslock a s d f g h j k l ; '
              -->

            <button data-key="capslock" tabindex="-1" id="CapsLock"
              class="keyboardkey capsLockKey OtherKey hidden"></button>


            <button data-key="a" tabindex="-1" id="KeyA" class="keyboardkey KeyA endButton"
              style="transform: translate(-27%, 0%)"><b>END:</b><br />stroke path</button>
            <button data-key="s" tabindex="-1" id="KeyS" class="keyboardkey sKey endButton"
              style="transform: translate(-27%, 0%)">
           
              <b>END:</b><br/>fill & stroke</button>
            <button data-key="d" tabindex="-1" id="KeyD" class="keyboardkey dKey "
              style="transform: translate(-27%, 0%)"></button>
            <button data-key="f" tabindex="-1" id="KeyF" class="keyboardkey fKey drawingButton"
              style="transform: translate(-27%, 0%)">add</br>point</button>
            <button data-key="g" tabindex="-1" id="KeyG" class="keyboardkey gKey"
              style="transform: translate(-27%, 0%)"></button>
            <button data-key="h" tabindex="-1" id="KeyH" class="keyboardkey hKey "
              style="transform: translate(-27%, 0%)"></button>
            <button data-key="j" tabindex="-1" id="KeyJ" class="keyboardkey jKey "
              style="transform: translate(-27%, 0%)"></button>
            <button data-key="k" tabindex="-1" id="KeyK" class="keyboardkey kKey "
              style="transform: translate(-27%, 0%)"></button>
            <button data-key="l" tabindex="-1" id="KeyL" class="keyboardkey lKey "
              style="transform: translate(-27%, 0%)"></button>
            <button data-key=";" tabindex="-1" id="Semicolon" class="keyboardkey semicolonKey operationButton enabledButton"
              style="transform: translate(-27%, 0%)">rotate <span style="font-size:30px">⥀</span></button>
            <button data-key="'" tabindex="-1" id="Quote" class="keyboardkey  singleQuoteKey operationButton enabledButton"
              style="transform: translate(-27%, 0%)">rotate <span style="font-size:30px">⥁</span></button>
            <button data-key="return" tabindex="-1" id="Enter" class="keyboardkey returnKey OtherKey hidden"
              style="transform: translate(-5%, 0%)">return</button>



            <!-- 
                END THIRD ROW 
              -->




            <!-- 
                ██████████████ BEGIN FOURTH ROW: █████████████████████
                shiftleft Z X C V B N M , . / shiftright
              -->
            <button data-key="shift" tabindex="-1" id="ShiftLeft"
              class="keyboardkey shiftKeyLeft OtherKey hidden"></button>

            <button data-key="z" tabindex="-1" id="KeyZ" class="keyboardkey KeyZ "
              style="transform: translate(38%, 0%)"></button>
            <button data-key="x" tabindex="-1" id="KeyX" class="keyboardkey xKey "
              style="transform: translate(38%, 0%)"></button>

            <button data-key="c" tabindex="-1" id="KeyC" class="keyboardkey cKey stepper1Decrement enabledButton"
              style="transform: translate(38%, 0%)">-
              <br />stroke<br />width</button>



            <button data-key="v" tabindex="-1" id="KeyV" class="keyboardkey vKey stepper1Increment enabledButton"
              style="transform: translate(38%, 0%)">+
              <br />stroke<br />width</button>
            <button data-key="b" tabindex="-1" id="KeyB" class="keyboardkey bKey "
              style="transform: translate(38%, 0%)">
              </button>
            <button data-key="n" tabindex="-1" id="KeyN" class="keyboardkey nKey "
              style="transform: translate(38%, 0%)"></button>
            <button data-key="m" tabindex="-1" id="KeyM" class="keyboardkey mKey "
              style="transform: translate(38%, 0%)"></button>
            <button data-key="," tabindex="-1" id="Comma" class="keyboardkey commaKey "
              style="transform: translate(38%, 0%)"></button>
            <button data-key="." tabindex="-1" id="Period" class="keyboardkey periodKey "
              style="transform: translate(38%, 0%)"></button>
            <button data-key="/" tabindex="-1" id="Slash" class="keyboardkey forwardSlashKey OtherKey"
              style="transform: translate(38%, 0%)"></button>

            <button data-key="shift" tabindex="-1" id="ShiftRight" class="keyboardkey shiftKeyRight OtherKey hidden"
              style="transform: translate(15%, 0%)"></button>

            <!-- 
                END FOURTH ROW 
              -->




            <!-- 
                BEGIN FIFTH ROW:
                █████████████████████ spacebarKey █████████████████████
               -->

            <button tabindex="-1" data-key="spacebar" id="Space"
              class="keyboardkey spacebarKey OtherKey enabledButton selectionButton">Drag Lock</button>

            <!-- END FIFTH ROW -->


          </div>
        </div><!-- END keyboardContainer-->

      </div>
    </div>


    <article>
    <h2>Description of Bimodal Control UI Theory</h2>
    
    <p>In the vector-drawing demo above, the mouse and keyboard
      were given separate roles.
      <ul>
<li><b>The mouse for cursor steering. </b>The mouse was given the role of steering the cursor and
navigation.  </li>
<li><b>The keyboard for function activation. </b>The keyboard was given the role of activation ("click").</li>

</ul>

<p>Here, each input device operates in its own "modality," focusing on a specific type of interaction.
  Previously the two were conjoined into one device.
</p>


<h3>Division of Tasks</h3>
    <p>Bimodal Control UI theory separates into two physical locations:
    <ol>
      <li><b>steering, navigating, and guiding activity</b>
        <ul>
          <li>e.g. cursor XY(Z) movement (via mouse or 3D controller). the movement of the crosshair, etc. </li>
          
        </ul>
      </li>
    <br/>
  
      <li><b>triggering of functions</b>
      <ul><li>e.g. mouse button "clicks", tapping an object on a touchscreen, pressing a button on an XR controllers</li>
        
      </ol>

    </li>
  </ul>

  <p>Importantly, these are still fused today and have not been separated.  But the benefits are evident in the vector-drawing demo.</p>

  


  <h3>More Bimodal Control UI Examples</h3>
  <p>Importantly, Bimodal Control UI Theory is not limited to
the specific context of changing the desktop computer UI by moving mouse clicks to the keyboard keys.  
That is the interactivity of a desktop computer hardware setup, altered in
one way that can be explained by bimodal control theory.  
Bimodal Control UI theory is actually the intentional separation 
of input tasks; the user shifts between actions in separate
device locations.  The effect is the alternation of input activity in two
locations.  We provide some other examples below.
  </p>
<!--
  <p>Taking the desktop computer setup: a keyboard key on a keyboard isn't the only device
  that can serve as the activating button.  A button on 
  a different device sitting near the desktop computer can serve as the click too,
  because it isn't located on the mouse, and the dynamic is similar.  That said, 
  the keyboard often carries an overwhelming advantage which is that 
  it features many keys, which means it can activate a multitude of functions.
  Already, it is located near the desktop computer.
  
  <p>
    The keyboard keys were switched out one time for
    the stationary LED touchscreen buttons that 
    just provide haptic vibration feedback on the Loupedeck.
    Because only a light touch is needed to activate them compared to the keyboard keys presses,
    this is even more valuable when a large amount of repetition is occurring because
    even less fatigue occurs.
  </p>-->




  <h4>Dual-Input Web Hyperlink Browsing</h4>
  
  <p>In some instances, the dual-input setup
    that represents bimodal control theory may
    not feature a mouse or XY steering device
    at all.
  </p>
  
  <p>In <a href="https://chromewebstore.google.com/detail/npsurfer/adooldnhbmjlcpekjbcmeiphkdfhgffc?hl=en&authuser=0">NPSurfer</a>, 
    a web surfing plug-in, avoids using
    the mouse altogether for activating web page links. 
    Instead, a 3x3 grid is overlayed on the page when
    the user decides navigation to links should occur.  The division of 
    the page with this 3x3 grid corresponds to the keys in the number pad.
    <p>
      <p>
    For this plug-in, there is a separation keyboard tasks for to both hands.
   
    <ol>
      <li>One hand selects which region the link is located by
        way of a key that corresponds to the grid (3x3 grid 
        divides the web page temporarily and corrrespond to number keys).</li>
        <li>    The other hand activates the links labels that
          show up within that specific cell of the grid.
      </li>
    </ol>
  </p>

  <h4>Dual-Input Tablet Hardware Input</h4>
  <p>
  For an alternative touchscreen tablet UI, Noctivagous
  has discussed plans for a touchscreen paired with a column
  of LED-backed buttons to the left of the screen. 
  The dual-input occurs by holding down one or more of the 
  LED-screen-backed buttons that sits to the left
  of the touchscreen, then pressing the screen.

 <ol>
      <li>One hand either momentarily presses or holds down the specific LED-screen-backed key(s) to the left
        of the touchscreen.
      </li>
        <li>    The other hand presses the object or objects on the touchscreen
          which are the recipients/target(s) of that button's function.
      </li>
    </ol>
  </p>

  <p>Deleting an object then involves pressing the "Delete" button
    to the left of the touchscreen on the tablet with one hand
    while touching the objects with the right hand.

    <br/><br/><br/><br/>

    <h4>Dual-Input Manipulation of Text Fields and Sliders</h4>

    <p>In Noctivagous software, the mouse is used to hover
      over the textfield.  The textfield becomes outlined
      and its textfield is highlighted, and then the user begin typing
      on top (to replace) what is in the textfield immediately 
      without having to clicking inside the textfield to
      put a cursor inside.
    </p>

    <p>A second functionality built in is that if the
      user hovers over a numeric textfield with the cursor
      and presses "[" or "]", the textfield value will decrement or
      increment.  Againt, the user does not click inside
      the textfield.  It only requires hovering over
      it with the cursor and then "[" or "]" are pressed,
      (since these characters are not in any value of the
      numeric textfield).  Pressing Shift+"[" or Shift+"]"
      will decrement or increment by a higher value, and pressing
      option will be a smaller value. 
      This also works for slider controls: hovering over the slider
      and pressing "[" or "]" will decrement or increment the
      value.
    </p>

    <h3>The Bimodal Control UI Theory Can Improve All Software UI</h3>

    <p>Important to mention about the Bimodal Control UI Theory
      is that once it is established in software, it carries implications
     s across the whole of desktop software.  It can be applied
     to many specific conventions of desktop software, such as
     node-based programming in which the programmer connects nodes.
     The nodes can be connected with lines rapidly or detached
     from the nodes with greater control by the user because they
     use two inputs categorized into steering and activation. 
     The nodes themselves can be dragged around in the same
     way as the drag-lock in the vector-drawing demo. 
    </p>


  </article>



    <article>
      <h2>More About The Vector-Drawing Demo</h2>

 <p>
The demo above is limited to drawing straight lines, but a programmer
can use the same vector line segments as the basis for:
    <ul>
      <li>the diameter of a circle.</li>
      <li>the radius of a circle.</li>
      <li>the diagonal of a rectangle.</li>
      <li>the radius of a circle inscribing a regular polygon.</li>
      <li>points of an arc</li>
      <li>points of a spline</li>
      <li>etc.</li>

    </ul>
    
      <p>In <i>Floating Marker</i>, 
        curves have been implemented with these straight segments through the 
        b-spline (similar to Bezier paths). In combination with the dual-input UI,
        Noctivagous uses its own data structure
        made of composite spline points that bow (bend) the line, as shown in the video below.  <!-- The b-spline has the characteristic
        that it is rather pliable.  It can be shaped for different purposes
        programmatically in combination with the dual-input UI.  For example, Noctivagous uses its own data structure
        made of composite spline points that bow (bend) the line, as shown in the video below.--></p>
    <p>
      <center>
      <iframe  style="aspect-ratio: 163.1 / 108;width:100%;height:100%;max-width:900px;"
      src="https://www.youtube.com/embed/JTjfK3A7_-0" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
    </center>  
    </p>

   
   
  <h2>More Than Just for Making Vector Graphics</h2>
    
    <p>
For the software developer, there are other 
uses of the dual-input UI are possible besides making vector-graphics.

      <p>The vector line can serve as:</p>
    <ul>
      <li>a polyline (polygonal shape) that selects objects inside (whether they are files or something else).</li>
      <li>the means of connecting nodes in node-based/patch-based programming.
      	<ul><li>this has already been tested and is far superior to using the mouse for making node scripting diagrams</li></ul>
      </li>
      <li>the diagonal of the live selection rectangle (such as when selecting files on a desktop).
            	<ul><li>This is provided feature for selecting objects in the vector-drawing program Floating Marker.</li></ul>
      </li>
    </ul>
    
      <p>In the same way that vector shapes are dragged, the drag-lock can be used to move windows
        on the screen.  A different OS GUI can come about: the scale buttons allow the user to shrink windows.
        <b>It is possible to implement an entire desktop UI in the dual-input UI,
        with no mouse clicks.</b>

<!--	<p>Action-On-Hover </p>-->

       
    <h2>Relationship to History</h2>
      
      <p>
      During the original 1968 demo
      of the mouse by Douglas Engelbart, there was
      a <a href="https://dougengelbart.org/content/view/273/">five-key device sitting to the left of the keyboard</a>.
      The mouse was placed to the right of the keyboard.  
      This five-key device was later dropped at Xerox PARC for the Alto, which set
      the model for the Apple Lisa and Macintosh,
      but it was included as part of Engelbart's setup.
      <p>

        <p>
    In professional media production software today, 
    such as video editors and 3D modeling programs, 
    the mouse is used to simulate a hand
    on the screen, but that would be a single finger, only able to
    click one button at a time.
    
    <p>
    The dual-input UI breaks away from this confining setup and repurposes
    the keyboard keys as a set of buttons for a machine.  Using it feels
    more like interacting with the computer mechanically because
    the keyboard and mouse are reconfigured to provide mechanical controls.
    This is more appropriate for software, especially applications
    like video editors where there are constant interactions
    with mechanisms, like the timeline.  Mechanisms pervade user interface
    but have always been regarded as as something more vague in experience.  
    For example, the scrollbar is a mechanism.  The system menu
    is also a machine containing menu items that drop down.

    <p>
    For the future of software, this dual-input is the best modification for
    software running on desktop computers as they are owned by consumers across the world,
    if the goal is the match a mechanical controls with the user interface.

    <p>

    The dual-input UI can provide the core UI component of
    a new type of software, and this demo on this page
    is just what is provided as an introduction, so it isn't
    going to address every aspect all at once.
    There are other points to discuss about implementing
    it comprehensively, such as that text fields, sliders,
    and everything else should be modified to match what
    it provides.

    <p>
    Once practiced for a period of time, the dual-input UI becomes 
    natural and preferred over the standard use of the mouse
    for software.
    </p>

    <h2>The dual-input UI Comes from <i>Floating Marker</i>, a Vector-Drawing App</h2>

    <p>An app under development, called <i>Floating Marker</i>, is the origin of
      the dual-input UI.  For the benefit of developers who use GitHub,
      the dual-input UI is demonstrated on this page. Its applicability
      extends beyond vector-drawing to software situations of all kinds.
      It can take over the positioning of windows, the dragging of nodes in node-based programming,
      the connecting of nodes (with lines), and the changing of values in sliders and other controls.  

      <p>
      All desktop computers are equipped with
      keyboard and mouse, and the dual-input UI is a convenient upgrade for interactive 
      vector graphics software.
      
    
  

   
    
    


    <h2>Full Description of the dual-input UI</h2>


    <p>The dual-input UI is an improved software user interface for the desktop computer.

      <br><br>A software program that implements the dual-input UI treats the keys
      on a keyboard as click buttons. The mouse buttons are ignored except for
      the purpose of accommodating the old habits that all users have.
      After a person becomes accustomed to the dual-input UI, he or she will
      want it implemented across all of desktop user interfaces.

      <!-- Although this can be explained, before reading further, please try out the vector-drawing demo below.
      -->

    <p>
      The concept is that there is currently too much work assigned to an individual mouse hand.
      Compared to the dual-input UI, the mouse hand is currently overstressed.
      It has to do two things at once: coordinate the position of the cursor <i>and</i> click the buttons with the index
      finger.

      <p>
      In a vector-drawing program, especially, this is too much; the
      standard mouse interface is too simplistic for drawing vectors. Thus, to
      establish a normal situation for
      drawing vectors with a mouse, it's important first to modify the overall interface. 
      
      <!-- It later is applied to other parts of the desktop UI,
      outside of vector-drawing.-->


      <!--
<p>The dual-input UI is not in contradiction with the history of the mouse, as Douglas Engelbart's
  1968 demo of the mouse in fact also featured a .  During the demo, to the left of his keyboard
  he was using a five-key device in tandem with the mouse, which also had click buttons.  
  That five-key device did not make it into personal computers but its essence is the same as the dual-input UI.
 </p>
-->



    <p>Separating the click from the mouse divides the labor of
      directing cursor activity to two hands instead of one. This leads to a leap in possible dexterity.
      Each hand has been given its own role: the mouse hand just moves the cursor and
      the clicking hand just clicks with keys. This opens up a totally different interactive
      dynamic with the desktop computer, because previously there was never such alternation occuring between
      two hands (move, click, move, click).  But importantly, many more "click" buttons are available,
      because any alphanumeric key can serve as one.
    </p>


    <h1>Implementing Selection And Dragging of Objects in The dual-input UI</h1>

    <p>


    <h2>The <kbd>Tab</kbd> Key Is Used for The Selection Click</h2>
    <p>
      As shown in the demo above, to select an individual object, you press the
      <kbd>tab</kbd> key, and it is selected immediately underneath the cursor
      as if you had pressed <kbd>shift</kbd>+<kbd>left mouse button</kbd>. The

      <kbd>tab</kbd> key
      selects and de-selects. It is the <i>selection
        click</i>.



    <p>Though any key could be used for this, <kbd>tab</kbd>
      has been chosen because of its location on the keyboard
      that makes the keyboard behave as live controls instead
      of character entry for a program.

      <p>
      The purpose of assigning <kbd>shift</kbd>+<kbd>left mouse button</kbd>
      to the <kbd>tab</kbd> key is that the dual-input UI works better with the <kbd>shift</kbd> modifier for selections
      most of the time. The interactive dynamic has changed, and it is far easier to select 
      multiple objects at a time with the dual-input UI.
      <!-- <kbd>shift</kbd> is implemented.-->
      Tweaks and modifications like this are needed to make the dual-input UI translate existing conventions.
      Just like before, clicking outside of the selection de-selects everything.
    </p>

    <h2>The <kbd>Spacebar</kbd> Implements a Drag-Lock on The Current Selection</h2>
    <p>
      In a convention specific to the dual-input UI, the <kbd>tab</kbd> key has been paired with the <kbd>spacebar</kbd>
      key to move objects around the screen.  It is possible to use any combination of keys, but
      these are very large and they will be tapped frequently as buttons of a machine.    

    <p>
      To drag an object,  press
      the <kbd>spacebar</kbd> key after the object has been selected (using <kbd>tab</kbd> click), and the
      object moves in lock step with the cursor. This is a drag lock, affixing objects to the
      cursor relative to their position at the time of the drag lock. To release the drag lock, press the
      <kbd>spacebar</kbd> key again
      and then the objects are left at their location.

    <p>
      For ease of providing upfront terminology this is called a drag-lock, but it is also called
      "carting" by Noctivagous, in place of "dragging". It is named as such because a cart moves its contents
      smoothly using wheels on the ground whereas the dragging of something on the ground makes lots of noise.
      That is the degree of UI improvement that carting (a drag-lock) provides.
    </p>

    <h2>The <kbd>Escape</kbd> Key Cancels All Drag Locks And Selections</h2>

    <p>If the <kbd>Escape</kbd> is pressed and there is any drag lock occurring, it will
      be turned off. The current selection will be canceled as well.
      Using the <kbd>Escape</kbd> for this is not only a convenience, it fits into the whole
      of using of the keyboard to click when using the dual-input UI.</p>


    <h2>The Opportunities That Arise When The Drag Lock Is Used</h2>

    <p>Moving objects around on screen is very smooth when a drag lock is
      used in the way described above. But in addition to this, it provides
      opportunities to operate with the selection or apply functions to it
      in real time.
    </p>

    <p>In a vector-drawing program, the drag-locked selection can be scaled up or down with
      the bracket keys (<kbd>[</kbd> and <kbd>]</kbd>).

      In the demo, the two keys below the bracket keys (<kbd>;</kbd> and <kbd>'</kbd>)
      rotate the selection by an increment of 15 degrees clockwise and counterclockwise.

      The selection can be stamped
      with the <kbd>E</kbd> key during the drag-lock. So this means that transformed copies of
      the dragged selection can occur in real time. This is what Floating Marker uses for
      its vector-drawing user interface.

    </p>

    <!--For example, in a desktop user interface, if the <kbd>K</kbd> key
is used for copying an object into multiple folders.</p>-->


</article>


  </div>


  <script src="nibglider.js"></script>
  <script src="keyboard.js"></script>
  <script src="nibgliderKeyCommands.js"></script>


</body>

</html>